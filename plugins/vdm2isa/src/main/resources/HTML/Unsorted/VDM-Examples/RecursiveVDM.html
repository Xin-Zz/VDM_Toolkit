<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>Theory RecursiveVDM</title>
</head>


<body>
<div class="head">
<h1>Theory RecursiveVDM</h1>
</div>

<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="comment1">(*:maxLineLen=78:*)</span>
<span class="keyword1"><span class="command">theory</span></span> RecursiveVDM
<span class="keyword2"><span class="keyword">imports</span></span> <a href="VDMToolkit.html">VDMToolkit</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="comment1">(**************************************************************************************************)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‚ÄπIntroduction\label{sec:Intro}‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπThis paper describes a translation strategy for a variety of recursive definitions from 
VDM to Isabelle/HOL. The strategy takes 
into account the differences in how termination and well-foundedness 
are represented in both formalisms. 

Beyond overcoming technical practicalities, which we discuss, a major objective is to create
translation strategy templates. These templates must cover a wide variety of VDM 
recursive definitions, as well as having their proof obligations being highly automated.
The result is an extension to a VDM to Isabelle/HOL translation strategy and implementation 
as a plugin to VDMJ~<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> Battle09<span class="antiquote"><span class="antiquote">}</span></span></span></span> and extension to VDM-VSCode <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> AdvancedVSCodePaper<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

Isabelle uses literate programming, where formal specification, proofs and documentation are
all within the same environment. We omit proofs scripts below; the full VDM and Isabelle sources 
and proofs can be found at the VDM toolkit repository at
 <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ./plugins/vdm2isa/src/main/resources/RecursiveVDM.*‚Ä∫</span></span></span></span><span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚Åã</span></span>‚Äπin~<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">üåê</span></span>‚Äπhttps://github.com/leouk/VDM_Toolkit‚Ä∫</span></span>‚Ä∫</span></span>.

In the next section, we present background on VDM and Isabelle recursion and measure relations.
In Section~\ref{sec:VDMTypes} we briefly discuss VDM basic types translation and their
consequence for recursion. Next, Section~\ref{sec:Recursion} describes how both VDM
and Isabelle recursive definitions work and how they differ. Our translation strategy
is then presented in Section~\ref{sec:Strategy} for basic types, sets, maps, and 
complex recursive patterns. Finally, we conclude in Section~\ref{sec:Conclusion}. 
‚Ä∫</span></span>

<span class="comment1">(**************************************************************************************************)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‚ÄπBackground\label{sec:Background}‚Ä∫</span></span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπThe VDM to Isabelle/HOL translator caters for a wide range of the VDM AST. It copes with all kinds 
of expressions, a variety of patterns, almost all types, imports and exports, functions and specifications,
traces, and some of state and operations. Even though not all kinds of VDM patterns are allowed,
the translator copes with most, and where it does not, a corresponding equivalent is possible. Among the 
expressions, map comprehension is of note, given its complexity. Details can be found at 
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> NimFull <span class="quasi_keyword"><span class="quasi_keyword">and</span></span> AdvancedVSCodePaper<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

One particular area we want to extend translation is over recursively defined functions. 
VDM requires the user to define a measure function to justify why recursion will terminate. It then generates
proof obligations to ensure totality and termination. 

Finally, our translation strategy follows the size-change termination (SCT) proof 
strategy described in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> SCT_POPL <span class="quasi_keyword"><span class="quasi_keyword">and</span></span> SCNP_POPL<span class="antiquote"><span class="antiquote">}</span></span></span></span>. In particular, its SCP (polynomial) and SCNP (non-polynomial)
subclass of recursive definitions within the SCT, which permits efficient termination certificate checking. 
Effectively, if every infinite computation would give rise to an infinitely decreasing value sequence 
(according to the size-change principle), then no infinite computation is possible. Termination problems in 
this class have a global ranking function of a certain form, which can be found using SAT solving, hence 
increasing automation.

<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ùô</span></span>‚ÄπANYTHING ELSE? Related work?‚Ä∫</span></span>
‚Ä∫</span></span>

<span class="comment1">(**************************************************************************************************)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‚ÄπVDM basic types in Isabelle\label{sec:VDMTypes}‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπIsabelle represents natural numbers (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">‚Ñï</span></span>‚Ä∫</span></span></span></span>) as a (data) type with two constructors (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">0</span></span><span class="main"><span class="main">::</span></span><span class="main"><span class="main">‚Ñï</span></span>‚Ä∫</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚ÄπSuc <span class="free"><span class="free">n</span></span>‚Ä∫</span></span></span></span>), 
  where all numbers are projections over such constructions (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπe.g.‚Ä∫</span></span>~<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="numeral"><span class="numeral">3</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">(</span></span>Suc <span class="main"><span class="main">(</span></span>Suc <span class="main"><span class="main">(</span></span>Suc <span class="main"><span class="main">0</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span>"</span></span> <span class="keyword1"><span class="keyword"><span class="keyword1"><span class="keyword">by</span></span></span></span> <span class="operator"><span class="operator">simp</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>).   
  Isabelle integers (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">‚Ñ§</span></span>‚Ä∫</span></span></span></span>) are defined as a quotient type involving two natural numbers. Isabelle quotient types are 
  injections into a constructively defined type. Like with integers, other
  Isabelle numeric types (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπe.g.,‚Ä∫</span></span>~rationals <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">‚Ñö</span></span>‚Ä∫</span></span></span></span>, reals <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">‚Ñù</span></span>‚Ä∫</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπetc‚Ä∫</span></span>.) are defined in terms of some
  involved natural number construction. Type conversions (or coercions) are then defined to allow users to jump
  between type spaces. Nevertheless, Isabelle has no implicit type widening rule for <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">‚Ñï</span></span>‚Ä∫</span></span></span></span>; instead, it takes 
  conventions like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">lemma</span></span>[show_types] <span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">(</span></span><span class="main"><span class="main">0</span></span> <span class="main"><span class="main">-</span></span> <span class="free"><span class="free">x</span></span><span class="main"><span class="main">::</span></span><span class="main"><span class="main">‚Ñï</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">0</span></span>‚Ä∫</span></span> <span class="keyword1"><span class="keyword"><span class="keyword1"><span class="keyword">by</span></span></span></span> <span class="operator"><span class="operator">simp</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. For expressions involving 
a mixutre of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">‚Ñ§</span></span>‚Ä∫</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">‚Ñï</span></span>‚Ä∫</span></span></span></span> typed terms, explicit user-defined
  type coercions are needed (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπe.g.,‚Ä∫</span></span>~<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">lemma</span></span>[show_types] <span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">(</span></span><span class="numeral"><span class="numeral">2</span></span><span class="main"><span class="main">::</span></span><span class="main"><span class="main">‚Ñï</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">-</span></span> <span class="main"><span class="main">(</span></span><span class="numeral"><span class="numeral">3</span></span><span class="main"><span class="main">::</span></span><span class="main"><span class="main">‚Ñ§</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">-</span></span><span class="main"><span class="main">1</span></span>‚Ä∫</span></span> <span class="keyword1"><span class="keyword"><span class="keyword1"><span class="keyword">by</span></span></span></span> <span class="operator"><span class="operator">simp</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>).
 
   VDM expressions with basic-typed (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπ<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ùô</span></span>‚Äπnat‚Ä∫</span></span>‚Ä∫</span></span>, <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπ<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ùô</span></span>‚Äπint‚Ä∫</span></span>‚Ä∫</span></span>) variables have specific type widening rules.
  For example, even if both variables are <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπ<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ùô</span></span>‚Äπnat‚Ä∫</span></span>‚Ä∫</span></span>, the result might be <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπ<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ùô</span></span>‚Äπint‚Ä∫</span></span>‚Ä∫</span></span>. 
(<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπe.g.,‚Ä∫</span></span>~in VDM <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ0 - x:nat = -x:int‚Ä∫</span></span></span></span>). Therefore, our translation 
  strategy considers VDM <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπ<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ùô</span></span>‚Äπnat‚Ä∫</span></span>‚Ä∫</span></span> as the Isabelle type <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚ÄπVDMNat‚Ä∫</span></span></span></span>, which is just a type synonym for <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">‚Ñ§</span></span>‚Ä∫</span></span></span></span>. This 
  simplifies the translation process to Isabelle, such that no type coercions are necessary to encode all VDM type widenning rules. 
  On the other hand, this design decision means encoding of recursive functions over <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπ<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ùô</span></span>‚Äπnat‚Ä∫</span></span>‚Ä∫</span></span> to be more complicated 
  than expected, given VDM <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπ<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ùô</span></span>‚Äπnat‚Ä∫</span></span>‚Ä∫</span></span> is represented as Isabelle's <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">‚Ñ§</span></span>‚Ä∫</span></span></span></span>.

  Despite this design decision over basic types and their consequences, recursion
over VDM <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπ<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ùô</span></span>‚Äπint‚Ä∫</span></span>‚Ä∫</span></span>, sets or maps will still be involved. That is because these types 
are not constructively defined in Isabelle.‚Ä∫</span></span>

<span class="comment1">(**************************************************************************************************)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‚ÄπRecursion in VDM and in Isabelle\label{sec:Recursion}‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπRecursive definitions are pervasive in VDM models. 
An important aspect of every recursive definition
is an argument that justifies its termination. Otherwise, the recursion might go on 
in an infinite loop.

In VDM, this is defined using a recursive measure:~it has the same input type signature as
the recursive definition, and returns a <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπ<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ùô</span></span>‚Äπnat‚Ä∫</span></span>‚Ä∫</span></span>, which <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ùô</span></span>‚Äπmust‚Ä∫</span></span> monotonically decrease 
at each recursive call, eventually reaching zero. This is how termination of recursive definitions 
are justified in VDM. 

A simple example of VDM recursive definition is one for calculating the factorial of a given natural number
%
\begin{vdmsl}[frame=none,basicstyle=\ttfamily\scriptsize]
   factorial: nat -&gt; nat 
   factorial(n) == if n = 0 then 1 else n * factorial(n - 1)
   -- For the measure below, VDMJ produces a measure function as: 
   -- measure_factorial: nat -&gt; nat
   -- measure_factorial(n) == n
   measure n;   
\end{vdmsl} 
%
\noindent The VDM recursive measure simply uses the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπn‚Ä∫</span></span></span></span> input itself. This works because the only recursive 
call is made with a decreasing value of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπn‚Ä∫</span></span></span></span>, until it reaches <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ0‚Ä∫</span></span></span></span> and terminates. VDMJ generates 
three proof obligations for the definition above.
%
\begin{vdmsl}[frame=none,basicstyle=\ttfamily\scriptsize]
Proof Obligation 1: (Unproved)
factorial; measure_factorial: total function obligation at line 10:12
(forall n:nat &amp; is_(measure_factorial(n), nat))

Proof Obligation 2: (Unproved)
factorial: subtype obligation at line 6:57
(forall n:nat &amp; (not (n = 0) =&gt; (n - 1) &gt;= 0))

Proof Obligation 3: (Unproved)
factorial: recursive function obligation at line 5:4
(forall n:nat &amp; (not (n = 0) =&gt; 
    measure_factorial(n) &gt; measure_factorial((n - 1))))
\end{vdmsl} 
%
\noindent They are trivial to discharge in Isabelle given the measure definition expanded is just 
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">lemma</span></span> <span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">‚àÄ</span></span> <span class="bound"><span class="bound">n</span></span><span class="main"><span class="main">::</span></span><span class="main"><span class="main">‚Ñï</span></span> <span class="main"><span class="main">.</span></span> <span class="main"><span class="main">¬¨</span></span> <span class="bound"><span class="bound">n</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">0</span></span> <span class="main"><span class="main">‚ü∂</span></span> <span class="bound"><span class="bound">n</span></span> <span class="main"><span class="main">-</span></span> <span class="main"><span class="main">1</span></span> <span class="main"><span class="main">‚â•</span></span> <span class="main"><span class="main">0</span></span>‚Ä∫</span></span> <span class="keyword1"><span class="keyword"><span class="keyword1"><span class="keyword">by</span></span></span></span> <span class="operator"><span class="operator">simp</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">lemma</span></span> <span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">‚àÄ</span></span> <span class="bound"><span class="bound">n</span></span><span class="main"><span class="main">::</span></span><span class="main"><span class="main">‚Ñï</span></span> <span class="main"><span class="main">.</span></span> <span class="main"><span class="main">¬¨</span></span> <span class="bound"><span class="bound">n</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">0</span></span> <span class="main"><span class="main">‚ü∂</span></span> <span class="bound"><span class="bound">n</span></span> <span class="main"><span class="main">&gt;</span></span> <span class="bound"><span class="bound">n</span></span> <span class="main"><span class="main">-</span></span> <span class="main"><span class="main">1</span></span>‚Ä∫</span></span> <span class="keyword1"><span class="keyword"><span class="keyword1"><span class="keyword">by</span></span></span></span> <span class="operator"><span class="operator">simp</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

Moreover, even though measures over recursive type structures are impossible to define in VDM, they are 
easily described in Isabelle. For example, it is not possible to write a measure in VDM for a 
recursive function over a recursive record defining a linked list, such as <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚ÄπR :: v: nat n: R‚Ä∫</span></span></span></span>. 
This is automatically generated for our representation of VDM records in Isabelle as a datatype.
Other complex recursive patterns are hard/impossible to represent in VDM (see Section~\ref{sec:Complex}).   
  
In Isabelle, recursive definitions can be provided through primitive recursion over inputs are 
constructively defined, or more general function definitions that produces proof obligations. 
The former insists on definition for each type constructor and only provides simplification rules; whereas
the latter allow for more sophisticated input patterns and provides simplification, elimination and 
induction rules, as well as partial function considerations. For the purposes of this paper, we only 
consider function definitions. Readers can find more about these differences in~<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> IsaFunctionPackage<span class="antiquote"><span class="antiquote">}</span></span></span></span>. 

Isabelle recursive functions requires a proof obligation that parameters represent a constructive and 
compatible pattern, and that recursive calls terminate. Constructive patterns relates to all constructors 
in data type being used in the recursion inputs (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπe.g.,‚Ä∫</span></span>~one equation for each of the constructors of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">‚Ñï</span></span>‚Ä∫</span></span></span></span>, 
hence one involving <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">0</span></span><span class="main"><span class="main">::</span></span><span class="main"><span class="main">‚Ñï</span></span>‚Ä∫</span></span></span></span> and another involving <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚ÄπSuc <span class="free"><span class="free">n</span></span>‚Ä∫</span></span></span></span>). Compatible patterns relates to multiple ways 
patterns can be constructed will boil down to the pattern completeness cases (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπe.g.,‚Ä∫</span></span>~<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="free"><span class="free">n</span></span> <span class="main"><span class="main">+</span></span> <span class="numeral"><span class="numeral">2</span></span><span class="main"><span class="main">::</span></span><span class="main"><span class="main">‚Ñï</span></span>‚Ä∫</span></span></span></span> being 
simply multiple calls over defined constructors like <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚ÄπSuc <span class="main"><span class="main">(</span></span>Suc <span class="free"><span class="free">n</span></span><span class="main"><span class="main">)</span></span>‚Ä∫</span></span></span></span>). This is important to ensure that recursion 
is well structured (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπi.e.,‚Ä∫</span></span>~recursive calls will not get stuck because some constructs are not available). 
For example, if you miss the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">0</span></span><span class="main"><span class="main">::</span></span><span class="main"><span class="main">‚Ñï</span></span>‚Ä∫</span></span></span></span> case, eventually the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚ÄπSuc <span class="free"><span class="free">n</span></span>‚Ä∫</span></span></span></span> case will reach zero and fail, as no patterns for zero exist. 
The proof obligation for termination establishes that the recursion is well-founded. This has to be proved whenever 
properties of the defined function are meant to be total. 

Isabelle function definitions can be given with either <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="free"><span class="free">fun</span></span>‚Ä∫</span></span></span></span> or <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="free"><span class="free">function</span></span>‚Ä∫</span></span></span></span> syntax. The
former attempts to automatically prove the pattern constructive and compatible proofs and finds a measure 
for the termination proof obligation. The latter requires the user to do these proofs manually 
by providing a measure relation. It is better suited for cases where <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="free"><span class="free">fun</span></span>‚Ä∫</span></span></span></span> declarations fail, 
which usually involve complex or ill-defined recursion. 

The termination relation must be well-formed, which means have a
well-ordered induction principle over a partially ordered relation defined as
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span>[display,show_types] wf_def<span class="antiquote"><span class="antiquote">}</span></span></span></span><span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚Åã</span></span>‚ÄπFor 
details on what well-ordered induction means in Isabelle, see the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">class</span><span class="hidden">&gt;</span></span></span>‚Äπwellorder‚Ä∫</span></span> theorem <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> wf<span class="antiquote"><span class="antiquote">}</span></span></span></span> in 
theory <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚ÄπWellfounded.thy‚Ä∫</span></span></span></span> within Isabelle's distribution.‚Ä∫</span></span>. 
For example, an Isabelle definition of factorial that it automatically discovers all three proofs can be given as‚Ä∫</span></span>
<span class="comment1">(*
find_theorems name:wellorder
print_locale! wellorder *)</span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">factorial</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‚Äπ<span class="main">‚Ñï</span> <span class="main">‚áí</span> <span class="main">‚Ñï</span>‚Ä∫</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">‚Äπ<span class="free">factorial</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">*</span> <span class="main">(</span><span class="free">factorial</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>‚Ä∫</span></span> 
<span class="comment1">(*
fun 
  factorial' :: ‚Äπ‚Ñ§ ‚áí ‚Ñ§‚Ä∫
  where 
  "factorial' n = (if n = 0 then 1 else n * (factorial' (n - 1)))" 

function 
  factorial' :: ‚Äπ‚Ñ§ ‚áí ‚Ñ§‚Ä∫
  where 
  "factorial' n = (if n = 0 then 1 else n * (factorial' (n - 1)))" 
  by (pat_completeness, auto)
termination 
  sledgehammer
*)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπThis Isabelle definition is pretty much 1-1 with the VDM definition. 
Nevertheless, as mentioned above, VDM basic types widening rules 
necessitated we translate them to <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚ÄπVDMNat‚Ä∫</span></span></span></span>, which is just <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">‚Ñ§</span></span>‚Ä∫</span></span></span></span>. 
The same version of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπfactorial‚Ä∫</span></span></span></span> defined for <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">‚Ñ§</span></span>‚Ä∫</span></span></span></span> will fail with 
the error that ``<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚ÄπCould not find lexicographic termination order‚Ä∫</span></span>''. That is, 
Isabelle manages to discharge the pattern proofs for <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">‚Ñ§</span></span>‚Ä∫</span></span></span></span>, but not the termination one. 
This is because the user must provide a projection relation from the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">‚Ñ§</span></span>‚Ä∫</span></span></span></span> 
quotient type back into the constructive type <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">‚Ñï</span></span>‚Ä∫</span></span></span></span>.

Even if we could avoid these VDM basic types translation technicality, 
the same problem would occur for VDM recursion over non constructive types, 
such as sets or maps. That is, Isabelle only allow recursion over finite sets, 
which are not defined constructively but inductively. 
Similarly, Isabelle maps are defined with specialised HOL functions, 
again with domains that are not constructively defined. The only easy 
recursive definition translation from VDM to Isabelle are those
involving lists, given lists in Isabelle are defined constructively and VDM 
sequences maps directly to them.      

Therefore, defining recursive functions over non-constructive types entail 
more involved compatibility and completeness proofs.
They also usually lead to partial function definitions, given Isabelle cannot 
tell whether termination is immediately obvious. 
In VDM, however, recursive functions on sets (as well as map domains) are common, 
hence the need for extending our translation strategy.‚Ä∫</span></span>

<span class="comment1">(**************************************************************************************************)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‚ÄπVDM recursion translation strategy\label{sec:Strategy}‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπWe want to identify a translation strategy that will cater for such issues described above not only 
for basic types, but also for sets, sequences, maps, <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπetc‚Ä∫</span></span>. This is important to ensure that the
translator will cater for most commonly used VDM recursion definition patterns.   

As mentioned in~<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> VDMJAnnotations <span class="quasi_keyword"><span class="quasi_keyword">and</span></span> AdvancedVSCodePaper<span class="antiquote"><span class="antiquote">}</span></span></span></span>, it is possible to define formal annotations 
(as comments), which VDMJ will process and make available for its plugins. For our translation
strategy, we create a new annotation called <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ@IsaMeasure‚Ä∫</span></span></span></span>. It defines a user-provided well-founded 
measure relation that will participate in the Isabelle proofs of termination. For example, for the 
factorial function above, the user would have to write
%
\begin{vdmsl}[frame=none,basicstyle=\ttfamily\scriptsize]
  factorial: nat -&gt; nat 
  factorial(n) == if n = 0 then 1 else n * factorial(n-1)
  --@IsaMeasure( { (n -1, n) | n : nat &amp; n &lt;&gt; 0 } )
  measure n;
\end{vdmsl}
%
\noindent This measure relation corresponds to the relationship between the recursive 
call (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπfactorial(n-1)‚Ä∫</span></span></span></span>) and its defining equation (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπfactorial(n)‚Ä∫</span></span></span></span>), where the 
filtering condition determines for which values of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπn‚Ä∫</span></span></span></span>
should the relation refer to (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπe.g.,‚Ä∫</span></span>~non-zero values). More interesting measure 
relation examples are defined in Section~\ref{subsec:Complex}.  

During translation, the plugin will typecheck the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ@IsaMeasure‚Ä∫</span></span></span></span> annotation 
(<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπi.e.,‚Ä∫</span></span>~it is a type correct relation over the function signature).
Next, it will translate the annotation and some automation lemmas as series of 
Isabelle definitions to be used during the proof
of termination of translated VDM recursive functions. If no annotation is provided, 
following similar principles from Isabelle, then the plugin will try to automatically 
infer what the measure relation should be based on the structure of the recursive 
function definition. When this fails, then the user is informed. Still, even if
 measure-relation synthesis succeeds, the user still have to appropriately use it 
during Isabelle's termination proof. 

In what follows, we will detail the translation strategy for each relevant VDM type. 
For details over the overall translation strategy, see examples in the 
distribution<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚Åã</span></span>‚Äπ<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">üåê</span></span>‚Äπhttps://github.com/leouk/VDM_Toolkit‚Ä∫</span></span>‚Ä∫</span></span> and~<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> NimFull<span class="antiquote"><span class="antiquote">}</span></span></span></span>. That 
is, we impose various implicit VDM checks as explicit predicates. For example, VDM 
sets are always finite, and type invariants over set elements must hold for every element.‚Ä∫</span></span>

<span class="comment1">(*-------------------------------------------------------------------------------------------------*)</span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‚ÄπRecursion over VDM basic types (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπ<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ùô</span></span>‚Äπnat‚Ä∫</span></span>‚Ä∫</span></span>, <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπ<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ùô</span></span>‚Äπint‚Ä∫</span></span>‚Ä∫</span></span>)\label{subsec:VDMNat}‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπFollowing the general translation strategy~<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> NimFull<span class="antiquote"><span class="antiquote">}</span></span></span></span>, we first encode the implicit precondition of 
factorial that insists that the given parameter <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="free"><span class="free">n</span></span>‚Ä∫</span></span></span></span> is a <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚ÄπVDMNat‚Ä∫</span></span></span></span>, alongside a list of defining constants 
that are useful for proof strategy synthesis.‚Ä∫</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pre_vdm_factorial</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‚ÄπVDMNat <span class="main">‚áí</span> <span class="main">ùîπ</span>‚Ä∫</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">pre_vdm_factorial</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">‚â°</span> inv_VDMNat <span class="free"><span class="bound"><span class="entity">n</span></span></span>‚Ä∫</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> pre_vdm_factorial_defs <span class="main">=</span> pre_vdm_factorial_def inv_VDMNat_def 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπNext, we define the factorial function through recursion. When the precondition fails, 
  we return <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπundefined‚Ä∫</span></span></span></span>, which is a term that cannot be reasoned with in Isabelle (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπi.e.,‚Ä∫</span></span>~it is a dead end).
   Otherwise, we define factorial pretty much as in the VDM definition.

The <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="free"><span class="free">domintros</span></span>‚Ä∫</span></span></span></span> tag tells Isabelle to generate domain predicates, in case this function is not total. 
Domain predicates are important to our strategy because every VDM function will be undefined, when
applied outside its precondition. It also generates domain-predicate sensitive proof rules listed below.‚Ä∫</span></span>
<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>domintros<span class="main">)</span> <span class="entity">vdm_factorial</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‚ÄπVDMNat <span class="main">‚áí</span> VDMNat‚Ä∫</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">vdm_factorial</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> pre_vdm_factorial <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span>
                        <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">*</span> <span class="main">(</span><span class="free">vdm_factorial</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                      <span class="keyword1">else</span> undefined<span class="main">)</span>‚Ä∫</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπThe proof obligations for pattern compatibility and completeness are next.
 They are discharged with the usual Isabelle proof strategy for simple recursive patterns with the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">method</span></span> pat_completeness<span class="antiquote"><span class="antiquote">}</span></span></span></span> method.
  In the general case discussed in Section~\ref{subsec:Complex}), 
  the user might have goals to discharge.‚Ä∫</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">pat_completeness</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπVarious theorems are made available, such as: case analysis; and (partial) rules
for elimination, induction and simplification.
%Case analysis <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> vdm_factorial.cases<span class="antiquote"><span class="antiquote">}</span></span></span></span>
%Elimination rules (partial) <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> vdm_factorial.pelims<span class="antiquote"><span class="antiquote">}</span></span></span></span>
%Induction rules (partial) <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> vdm_factorial.pinduct<span class="antiquote"><span class="antiquote">}</span></span></span></span>
%Simplification rules (partial) <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> vdm_factorial.psimps<span class="antiquote"><span class="antiquote">}</span></span></span></span>

Note the last two are partial, module the domain predicate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">vdm_factorial_dom</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
which represents a well-founded relation that ensures termination. That is, if the user does not want
(or knows how) to prove termination, such domain predicates will follow every application of the 
factorial definition, hence imposing users the requirement that such well-founded relation is still missing.

If/when the termination proof is discharged, these p-rules can be simplified into total rules that 
do not depend on a domain predicate, given a well-founded relation has been provided. Domain predicates
will complicate user proofs, and also make proof strategy synthesis harder to automate.

Termination proof is discharged by establishing a well-founded relation associated with 
the function recursive call(s) with respect to its declaration. In our case, the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ@IsaMeasure‚Ä∫</span></span></span></span>
annotation is translated as an Isabelle abbreviation. We also implicitly add the filter that the 
function precondition holds:~this is important to ensure the termination proof never reaches the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπundefined‚Ä∫</span></span></span></span> case.  
The other filter comes from the negated test in the definition if-statement. More complex definitions will
have more involved filters. 
We use abbreviation instead of definition to avoid needing to expand the defined term.‚Ä∫</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">vdm_factorial_wf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‚Äπ<span class="main">(</span>VDMNat <span class="main">√ó</span> VDMNat<span class="main">)</span> set‚Ä∫</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">vdm_factorial_wf</span> <span class="main">‚â°</span> <span class="main">{</span> <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="bound">n</span><span class="main">)</span> <span class="main">|</span> <span class="bound">n</span> <span class="main">.</span> pre_vdm_factorial <span class="bound">n</span> <span class="main">‚àß</span> <span class="bound">n</span> <span class="main">‚â†</span> <span class="main">0</span> <span class="main">}</span>‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπGiven <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπvdm_factorial‚Ä∫</span></span></span></span> is a simple (non-mutual, single call-site, easy measure relation choice) recursion, 
  thankfully the setup is not as complex to establish well-foundedness. For recursions of this nature, we can 
  piggyback on some Isabelle machinery to help prove well foundedness by using the terms <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">gen_VDMNat_term</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">int_ge_less_than</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

  The first term is defined in terms of the second, which is a subset of our well-formed relation <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπvdm_factorial_wf‚Ä∫</span></span></span></span>. 
  Isabelle has proofs about the term's well formedness of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπint_ge_less_than‚Ä∫</span></span></span></span>.
  Thus, making the proof our term being well-founded trivial, and easily discovered with proof tools like
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span>. As part of the translation strategy, we then define (and automatically discover the proof of)
  the following lemma. This follows the strategy described in~<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> KrausSCNP<span class="antiquote"><span class="antiquote">}</span></span></span></span>. 
    %\url{https://www21.in.tum.de/~krauss/papers/scnp-wst.pdf}.‚Ä∫</span></span>
<span class="keyword1"><span class="command">lemma</span></span> l_vdm_factorial_term_wf<span class="main">:</span> <span class="quoted"><span class="quoted">‚Äπwf <span class="main">(</span>gen_VDMNat_term vdm_factorial_wf<span class="main">)</span>‚Ä∫</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wf_int_ge_less_than wf_Int1<span class="main">)</span> 

<span class="keyword1"><span class="command">termination</span></span> <span class="comment1">‚úê<span class="quoted"><span class="quoted">‚Äπtag invisible‚Ä∫</span></span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπFinally, we prove termination using the previously proved lemma using the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">method</span></span> relation<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  This simplifies the goal into well-formedness of termination relation and that the precondition implies it,
  both of which are easily proved with simplification in this case.‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">‚Äπ<span class="main">(</span>gen_VDMNat_term vdm_factorial_wf<span class="main">)</span>‚Ä∫</span></span><span class="main">)</span> <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπThis transforms the abstract domain predicate into two new subgoals as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span>[display]<span class="antiquote"><span class="antiquote">}</span></span></span></span>‚Ä∫</span></span>
  <span class="keyword1"><span class="command">using</span></span> l_vdm_factorial_term_wf <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">presburger</span> <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_vdm_factorial_defs int_ge_less_than_def<span class="main">)</span> <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπFor this simple example, these subgoals are proved with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span>. In general, the user will be
  have to either find the proof, or deal with domain predicates in proofs involving the recursive call.
 After the termination proof is discharged, Isabelle provides versions of rules 
for elimination, induction and simplification that are total and do not depend on 
the abstract domain predicate. 
‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπTo make sure our choice does not lead to the empty relation, we ensure
  that indeed the termination relation is in fact the same as the well founded predicate by proving the next goal.
  This is something users might want to do, but is not part of the translation strategy. In case the measure relation 
  is empty, the recursive call simplification rules will not be useful anyhow.‚Ä∫</span></span>
<span class="keyword1"><span class="command">lemma</span></span> l_vdm_factorial_term_valid<span class="main">:</span> 
  <span class="quoted"><span class="quoted">‚Äπ<span class="main">(</span>gen_VDMNat_term vdm_factorial_wf<span class="main">)</span> <span class="main">=</span> vdm_factorial_wf‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_vdm_factorial_defs<span class="main">)</span> <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> equalityI subsetI<span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_ge_less_than_def case_prod_beta<span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>

<span class="comment1">(*-------------------------------------------------------------------------------------------------*)</span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‚ÄπRecursion over VDM sets\label{subsec:VDMSet}‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπNext, we extend the translation strategy for basic types for VDM sets. For this, we will use a 
 recursively defined VDM function over sets that sums the set elements as
%
\begin{vdmsl}[frame=none,basicstyle=\ttfamily\scriptsize]
  sumset: set of nat -&gt; nat 
  sumset(s) == if s = {} then 0 else let e in set s in sumset(s - {e}) + e
  --@IsaMeasure({(x - { let e in set x in e }, x) | x : set of nat &amp; x &lt;&gt; {}}) 
  --@Witness(sumset({ 1 }))
  measure card s;
\end{vdmsl}
%
\noindent Like most common VDM recursion over sets, the function consumes the set by picking each 
set element and them calling the recursive call without the element picked, until the set is empty. 
The VDM measure states that the recursion is based on the cardinality of the input parameter. VDM 
measures are not suitable for Isabelle proofs, given Isabelle requires a relation;~hence,
VDM measures are ignored during translation. They might still be useful during proofs as potential 
witnesses to existentially-quantified goals.

In Isabelle, the implicit VDM checks are defined as the precondition, which ensures 
that the given set contains only natural numbers, and is finite, as defined by <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπinv_VDMSet'‚Ä∫</span></span></span></span>‚Ä∫</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pre_sumset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‚ÄπVDMNat VDMSet <span class="main">‚áí</span> <span class="main">ùîπ</span>‚Ä∫</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">pre_sumset</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">‚â°</span> inv_VDMSet' inv_VDMNat <span class="free"><span class="bound"><span class="entity">s</span></span></span>‚Ä∫</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> pre_sumset_defs <span class="main">=</span> pre_sumset_def inv_VDMSet'_defs inv_VDMNat_def

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπWe define the VDM recursive function in Isabelle next. It checks whether the given
      set satisfy the function precondition, returning <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπundefined‚Ä∫</span></span></span></span> if not.
      Each case is encoded pretty much 1-1 from VDM after that. The translation strategy for
      VDM <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπlet-in-set‚Ä∫</span></span></span></span> patterns uses Isabelle's Hilbert's choice operator (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">œµ</span></span> <span class="bound"><span class="bound">x</span></span> <span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">x</span></span> <span class="main"><span class="main">‚àà</span></span> <span class="free"><span class="free">s</span></span>‚Ä∫</span></span></span></span>).
    Note this naturally extends to VDM's <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπlet-be-st‚Ä∫</span></span></span></span> patterns as well.‚Ä∫</span></span>
<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>domintros<span class="main">)</span> <span class="entity">sumset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‚ÄπVDMNat VDMSet <span class="main">‚áí</span> VDMNat‚Ä∫</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">sumset</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> 
    <span class="main">(</span><span class="keyword1">if</span> pre_sumset <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">then</span> 
        <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">e</span> <span class="main">=</span> <span class="main">(</span><span class="main">œµ</span> <span class="bound">x</span> <span class="main">.</span> <span class="bound">x</span> <span class="main">‚àà</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="keyword1">in</span> <span class="free">sumset</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">-</span> <span class="main">{</span><span class="bound">e</span><span class="main">}</span><span class="main">)</span> <span class="main">+</span> <span class="bound">e</span><span class="main">)</span> 
     <span class="keyword1">else</span> undefined<span class="main">)</span>‚Ä∫</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπThe pattern completeness and compatibility goals are discharged with 
  the usual proof strategy of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">method</span></span> pat_completeness<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
        For more general examples, if that fails, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span> should be used.
       ‚Ä∫</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">pat_completeness</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπThe measure relation for termination is defined with the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ@IsaMeasure‚Ä∫</span></span></span></span> annotation above as 
   the smaller set after picking <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="free"><span class="free">e</span></span>‚Ä∫</span></span></span></span> (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπe.g.,‚Ä∫</span></span>~<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="free"><span class="free">s</span></span> <span class="main"><span class="main">-</span></span> <span class="main"><span class="main">{</span></span><span class="main"><span class="main">(</span></span><span class="main"><span class="main">œµ</span></span> <span class="bound"><span class="bound">e</span></span> <span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">e</span></span> <span class="main"><span class="main">‚àà</span></span> <span class="free"><span class="free">s</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">}</span></span>‚Ä∫</span></span></span></span>), 
    and the set used at the entry call, leading to the pairs <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">(</span></span><span class="free"><span class="free">s</span></span> <span class="main"><span class="main">-</span></span> <span class="main"><span class="main">{</span></span><span class="main"><span class="main">(</span></span><span class="main"><span class="main">œµ</span></span> <span class="bound"><span class="bound">e</span></span> <span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">e</span></span> <span class="main"><span class="main">‚àà</span></span> <span class="free"><span class="free">s</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">}</span></span><span class="main"><span class="main">,</span></span> <span class="free"><span class="free">s</span></span><span class="main"><span class="main">)</span></span>‚Ä∫</span></span></span></span>. 
    Finally, we ensure all the relation elements satisfy the function precondition (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπpre_sumset‚Ä∫</span></span></span></span>),
   and that the if-test is negated.
‚Ä∫</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">sumset_wf_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‚Äπ<span class="main">(</span>VDMNat VDMSet <span class="main">√ó</span> VDMNat VDMSet<span class="main">)</span> set‚Ä∫</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">sumset_wf_rel</span> <span class="main">‚â°</span> <span class="main">{</span> <span class="main">(</span><span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="main">œµ</span> <span class="bound">e</span> <span class="main">.</span> <span class="bound">e</span> <span class="main">‚àà</span> <span class="bound">s</span><span class="main">)</span><span class="main">}</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">|</span> <span class="bound">s</span> <span class="main">.</span> pre_sumset <span class="bound">s</span> <span class="main">‚àß</span> <span class="bound">s</span> <span class="main">‚â†</span> <span class="main">{}</span><span class="main">}</span>‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπGiven this is a simple (non-mutual, single call-site, easy set element choice) recursion, again
   we can piggyback on Isabelle machinery by using the terms <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">gen_set_term</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and 
   <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">finite_psubset</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>

  They establishes that a relation where the first element is strictly smaller set than the 
  second element in the relation pair is well-formed. This makes the proof of well-foundedness easy 
  for <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπsumset_wf_rel‚Ä∫</span></span></span></span> through <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span>. ‚Ä∫</span></span>
<span class="keyword1"><span class="command">lemma</span></span> l_sumset_rel_wf<span class="main">:</span> <span class="quoted"><span class="quoted">‚Äπwf <span class="main">(</span>gen_set_term sumset_wf_rel<span class="main">)</span>‚Ä∫</span></span>
  <span class="keyword1"><span class="command">using</span></span> l_gen_set_term_wf <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>

<span class="keyword1"><span class="command">termination</span></span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπNext, we tackle the termination proof, with the same setup with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">method</span></span> relation<span class="antiquote"><span class="antiquote">}</span></span></span></span> again.‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> <span class="quoted">"termination"</span><span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span>gen_set_term sumset_wf_rel<span class="main"><span class="main">)</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command">using</span></span> l_sumset_rel_wf <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπUnfortunately, using <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span> fails to discharge the second subgoal <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span>[display]<span class="antiquote"><span class="antiquote">}</span></span></span></span>‚Ä∫</span></span>
  <span class="keyword1"><span class="command">oops</span></span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπFortunately, for most simple situations, this is easy to decompose in general. The translation strategy takes the 
    <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ@IsaMeasure‚Ä∫</span></span></span></span> expression and decompose its parts, such that the filtering predicates are assumptions, and
    the element in the relation belong to the well-formed measure chosen. For the concrete set example, this is defined 
  in the next lemma, which require some manual intervention to tell Isabelle what definitions to unfold and simplify with. 
  Then, Isabelle's <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span> can finish the proof.‚Ä∫</span></span>

<span class="keyword1"><span class="command">lemma</span></span> l_pre_sumset_sumset_wf_rel<span class="main">:</span> 
  <span class="quoted"><span class="quoted">‚Äπpre_sumset <span class="free">s</span> <span class="main">‚üπ</span> <span class="free">s</span> <span class="main">‚â†</span> <span class="main">{}</span> <span class="main">‚üπ</span> <span class="main">(</span><span class="free">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="main">œµ</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">‚àà</span> <span class="free">s</span><span class="main">)</span><span class="main">}</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">‚àà</span> <span class="main">(</span>gen_set_term sumset_wf_rel<span class="main">)</span>‚Ä∫</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> gen_set_term_def <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_sumset_defs<span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Diff_subset member_remove psubsetI remove_def some_in_eq<span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπThe intuition behind this lemma is that, elements in the measure relation satisfy well-formedness under the function 
  precondition and the filtering case (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="free"><span class="free">s</span></span> <span class="main"><span class="main">‚â†</span></span> <span class="main"><span class="main">{}</span></span>‚Ä∫</span></span></span></span>) where the recursive call is made. That is, the precondition and 
  filtering condition help establish the terminating relation. For this particular proof, the only aspect needed from the 
  precondition (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπpre_sumset‚Ä∫</span></span></span></span>) is that the set is finite. 

  With this, we can try the termination proof again, which now <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span> find proofs for all subgoals.‚Ä∫</span></span>
<span class="keyword1"><span class="command">termination</span></span><span class="comment1">‚úê<span class="quoted"><span class="quoted">‚Äπtag invisible‚Ä∫</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> <span class="quoted">"termination"</span><span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span>gen_set_term sumset_wf_rel<span class="main"><span class="main">)</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command">using</span></span> l_sumset_rel_wf <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command">using</span></span> l_pre_sumset_sumset_wf_rel <span class="keyword1"><span class="command">by</span></span> <span class="operator">presburger</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">lemma</span></span> l_pre_vdm_factorial_wf_rel'<span class="main">:</span> <span class="quoted"><span class="quoted">"pre_vdm_factorial <span class="free">n</span> <span class="main">‚üπ</span> <span class="free">n</span> <span class="main">‚â†</span> <span class="main">0</span> <span class="main">‚üπ</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span> <span class="main">‚àà</span> gen_VDMNat_term vdm_factorial_wf"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> gen_VDMNat_term_def gen_VDMInt_term_def
  <span class="keyword1"><span class="command">using</span></span> l_vdm_factorial_term_valid <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπNote we omit such lemma over termination and precondition for the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚ÄπVDMNat‚Ä∫</span></span></span></span> case in Section~\ref{subsec:VDMNat}. 
  The translation strategy does define it following the same recipe:~recursive function precondition and filtering predicate 
  as assumptions, and chosen termination relation element containment, where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span> find the proof once more.‚Ä∫</span></span>
<span class="keyword1"><span class="command">lemma</span></span> l_pre_vdm_factorial_wf_rel<span class="main">:</span> <span class="quoted"><span class="quoted">‚Äπ<span class="main">‚ü¶</span>pre_vdm_factorial <span class="free">n</span><span class="main">;</span> <span class="free">n</span> <span class="main">‚â†</span> <span class="main">0</span><span class="main">‚üß</span> <span class="main">‚üπ</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span> <span class="main">‚àà</span> gen_VDMNat_term vdm_factorial_wf‚Ä∫</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> gen_VDMNat_term_def gen_VDMInt_term_def <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command">using</span></span> inv_VDMNat_def l_less_than_VDMNat_subset_int_ge_less_than pre_vdm_factorial_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπWe also choose to show the relation finite subset trick to
make well-founded induction proofs easier does not compromise the well founded relation itself.‚Ä∫</span></span>
<span class="keyword1"><span class="command">lemma</span></span> l_sumset_wf_rel_valid<span class="main">:</span> <span class="quoted"><span class="quoted">‚Äπgen_set_term sumset_wf_rel <span class="main">=</span> sumset_wf_rel‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> equalityI subsetI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span> <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command">using</span></span> l_pre_sumset_sumset_wf_rel <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπFinally, even though this was not necessary for this proof, we encourage users to always provide a witness for the top recursive call.
  This is done by using the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ@Witness‚Ä∫</span></span></span></span> annotation~<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> EdwardWitness <span class="quasi_keyword"><span class="quasi_keyword">and</span></span> AdvancedVSCodePaper<span class="antiquote"><span class="antiquote">}</span></span></span></span>:~it provides a concrete example for the function 
  input parameters. This witness is useful for existentially quantified predicates present in more involved termination proofs (see Section~\ref{subsec:Complex}).‚Ä∫</span></span>

<span class="comment1">(*-------------------------------------------------------------------------------------------------*)</span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‚ÄπRecursion over VDM maps\label{subsec:VDMMap}‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπRecursive functions over VDM maps are a special case of VDM sets, given map recursion usually 
iterates over the map's domain. For example, the function that sums the elements of the map range 
can be defined as  
%
\begin{vdmsl}[frame=none,basicstyle=\ttfamily\scriptsize]
  sum_elems: map nat to nat -&gt; nat
  sum_elems(m) == 
    if m = {|-&gt;} then 0 else let d in set dom m in m(d) + sum_elems({d}&lt;-:m)
  --@IsaMeasure({({d} &lt;-: m, m) | m : map nat to nat, d: nat &amp; 
                      m &lt;&gt; {} and d in set dom m})
  --@Witness( sum_elems({ 1 |-&gt; 1 }) )
  measure card dom m;
\end{vdmsl}
%
\noindent As with sets, it iterates over the map by picking a domain element, performing the necessary 
computation, and then recurse on the map filtered by removing the chosen element, until the map is 
empty and the function terminates. As before, the measure relation follows the same pattern:~recursive call 
site related with defining site, where both the if-test and the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπlet-in-set‚Ä∫</span></span></span></span> choice is part of the filtering predicate.

Following the general translation strategy for maps~<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> NimFull<span class="antiquote"><span class="antiquote">}</span></span></span></span>, we define the function precondition using <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπinv_Map‚Ä∫</span></span></span></span>
It insists that both the map domain and range are finite, and that all domain and range elements satisfy their corresponding type invariant. 
Note that if the recursion was defined over sets other than the domain and range, Isabelle might require you to prove such set is finite. 
Given both domain and range sets are themselves finite, this should be easy enough to do, if needed. 
‚Ä∫</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pre_sum_elems</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‚Äπ<span class="main">(</span>VDMNat <span class="main">‚áÄ</span> VDMNat<span class="main">)</span> <span class="main">‚áí</span> <span class="main">ùîπ</span>‚Ä∫</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">pre_sum_elems</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">‚â°</span> inv_Map inv_VDMNat inv_VDMNat <span class="free"><span class="bound"><span class="entity">m</span></span></span>‚Ä∫</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> pre_sum_elems_defs <span class="main">=</span> pre_sum_elems_def inv_Map_defs inv_VDMNat_def 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπVDM maps in Isabelle (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">(</span></span>VDMNat <span class="main"><span class="main">‚áÄ</span></span> VDMNat<span class="main"><span class="main">)</span></span>‚Ä∫</span></span></span></span>) are defined as a HOL function which maps to an optional result. 
That is, if the element is in the domain, the map results in a non {\texttt{<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ùô</span></span>‚Äπnil‚Ä∫</span></span>}} value, whereas if the element
does not belong to the domain, the map results in a {\texttt{<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ùô</span></span>‚Äπnil‚Ä∫</span></span>}} value. This effectively makes all maps total,
where values outside the domain map to {\texttt{<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ùô</span></span>‚Äπnil‚Ä∫</span></span>}}. The Isabelle translation and compatibility proof follows 
patterns used before and are given as‚Ä∫</span></span>
<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>domintros<span class="main">)</span> <span class="entity">sum_elems</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‚Äπ<span class="main">(</span>VDMNat <span class="main">‚áÄ</span> VDMNat<span class="main">)</span> <span class="main">‚áí</span> VDMNat‚Ä∫</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">sum_elems</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> 
      <span class="main">(</span><span class="keyword1">if</span> pre_sum_elems <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="keyword1">then</span>
          <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> Map.empty <span class="keyword1">then</span> <span class="main">0</span>
          <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">d</span> <span class="main">=</span> <span class="main">(</span><span class="main">œµ</span> <span class="bound">e</span> <span class="main">.</span> <span class="bound">e</span> <span class="main">‚àà</span> dom <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="keyword1">in</span> the<span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="bound">d</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">sum_elems</span> <span class="main">(</span><span class="main">{</span><span class="bound">d</span><span class="main">}</span> <span class="main">-‚óÉ</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
       <span class="keyword1">else</span> undefined<span class="main">)</span>‚Ä∫</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">pat_completeness</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπSimilarly, the well-formed relation from <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ@IsaMeasure‚Ä∫</span></span></span></span> is translated next, where the precondition is also included 
as part of the relation's filter. The <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">{</span></span><span class="free"><span class="free">d</span></span><span class="main"><span class="main">}</span></span><span class="main"><span class="main">-‚óÉ</span></span><span class="free"><span class="free">m</span></span>‚Ä∫</span></span></span></span> corresponds to VDM domain anti-filtering operator <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ&lt;-:‚Ä∫</span></span></span></span>.‚Ä∫</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">sum_elems_wf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‚Äπ<span class="main">(</span><span class="main">(</span>VDMNat <span class="main">‚áÄ</span> VDMNat<span class="main">)</span> <span class="main">√ó</span> <span class="main">(</span>VDMNat <span class="main">‚áÄ</span> VDMNat<span class="main">)</span><span class="main">)</span> VDMSet‚Ä∫</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">sum_elems_wf</span> <span class="main">‚â°</span> <span class="main">{</span> <span class="main">(</span><span class="main">(</span><span class="main">{</span><span class="bound">d</span><span class="main">}</span> <span class="main">-‚óÉ</span> <span class="bound">m</span><span class="main">)</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span> <span class="main">|</span> <span class="bound">m</span> <span class="bound">d</span> <span class="main">.</span> pre_sum_elems <span class="bound">m</span> <span class="main">‚àß</span> <span class="bound">m</span> <span class="main">‚â†</span> Map.empty <span class="main">‚àß</span> <span class="bound">d</span> <span class="main">‚àà</span> dom <span class="bound">m</span> <span class="main">}</span>‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπFor the well-formed lemma over the recursive measure relation, there are no available Isabelle help, 
and projecting the domain element of the maps within the relation is awkward. Thus, we have to prove the 
lemma directly. This will not be automatic in general. This is one difference in terms of translation of VDM 
recursive functions over sets and maps.

Fortunately, the proof strategy for such situations is somewhat known:~it follows a similar strategy to
the proof of well formedness of the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπfinite_psubset‚Ä∫</span></span></span></span> as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> wf_finite_psubset<span class="antiquote"><span class="antiquote">}</span></span></span></span>. The proof uses
the VDM measure expression to extract the right projection of interest, then follows the proof for <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπfinite_psubset‚Ä∫</span></span></span></span>. 
Finally, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span> can figure out the final steps.   
‚Ä∫</span></span>
<span class="keyword1"><span class="command">lemma</span></span> l_sum_elems_wf<span class="main">:</span> <span class="quoted"><span class="quoted">‚Äπwf sum_elems_wf‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> wf_measure<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">Œª</span></span> <span class="bound"><span class="bound">m</span></span> <span class="main"><span class="main">.</span></span> card <span class="main"><span class="main">(</span></span>dom <span class="bound"><span class="bound">m</span></span><span class="main"><span class="main">)</span></span>‚Ä∫</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> wf_subset<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_def inv_image_def less_than_def less_eq<span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> case_prod_beta<span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> exE conjE<span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_VDMMap_filtering_card pre_sum_elems_defs<span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπThe precondition subgoal and the termination proof follow the same patterns as before. Again,
their proof was discovered with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span>, yet this will not be the case in general.‚Ä∫</span></span>
<span class="keyword1"><span class="command">lemma</span></span> l_pre_sum_elems_sum_elems_wf<span class="main">:</span> <span class="quoted"><span class="quoted">‚Äπ<span class="main">‚ü¶</span>pre_sum_elems <span class="free">m</span><span class="main">;</span> <span class="free">m</span> <span class="main">‚â†</span> Map.empty<span class="main">‚üß</span> <span class="main">‚üπ</span> <span class="main">(</span><span class="main">{</span><span class="main">(</span><span class="main">œµ</span> <span class="bound">e</span><span class="main">.</span> <span class="bound">e</span> <span class="main">‚àà</span> dom <span class="free">m</span><span class="main">)</span><span class="main">}</span> <span class="main">-‚óÉ</span> <span class="free">m</span><span class="main">,</span> <span class="free">m</span><span class="main">)</span> <span class="main">‚àà</span> sum_elems_wf‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_sum_elems_defs<span class="main">)</span> <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> domIff empty_iff some_in_eq<span class="main">)</span> <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>

<span class="keyword1"><span class="command">termination</span></span>  <span class="comment1">‚úê<span class="quoted"><span class="quoted">‚Äπtag invisible‚Ä∫</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> <span class="quoted">"termination"</span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> l_sum_elems_wf<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command">using</span></span> l_pre_sum_elems_sum_elems_wf <span class="keyword1"><span class="command">by</span></span> <span class="operator">presburger</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπFinally, we also prove that the well founded termination relation (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπsum_elems_wf‚Ä∫</span></span></span></span>) is not 
empty, as we did for sets and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπ<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ùô</span></span>‚Äπnat‚Ä∫</span></span>‚Ä∫</span></span> recursion. Note that here the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ@Witness‚Ä∫</span></span></span></span> annotation is 
useful in discharging the actual value to use as the witness demonstrating the relation is not empty.‚Ä∫</span></span>
<span class="keyword1"><span class="command">lemma</span></span> l_sum_elems_wf_valid<span class="main">:</span> <span class="quoted"><span class="quoted">‚Äπsum_elems_wf <span class="main">‚â†</span> <span class="main">{}</span>‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span> <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> equalityE<span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subset_eq<span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main">[</span><span class="main">1</span> <span class="main">‚Ü¶</span> <span class="main">1</span><span class="main">]</span>‚Ä∫</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_sum_elems_defs<span class="main">)</span> <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>

<span class="comment1">(*-------------------------------------------------------------------------------------------------*)</span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‚ÄπVDM recursion involving complex measures\label{subsec:Complex}‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπThe class of recursive examples shown so far have cover a wide range of 
situations, and have a good level of automation. Nevertheless, the same strategy can
also be applied for me complex recursive definitions. The cost for the VDM user
is the need of a more involved <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ@IsaMeasure‚Ä∫</span></span></span></span> definition and the highly likely need for
extra user-defined lemmas. These lemmas can be defined in VDM itself using 
the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ@Lemma‚Ä∫</span></span></span></span> annotation, which will be translated to Isabelle as any other boolean 
expression would.

To illustrate this, we define in VDM the (in)famous Ackermann 
function<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚Åã</span></span>‚Äπ<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">üåê</span></span>‚Äπhttps://en.wikipedia.org/wiki/Ackermann_function‚Ä∫</span></span>‚Ä∫</span></span>, 
which is a staple example of complex recursion, as  
%
\begin{vdmsl}[frame=none,basicstyle=\ttfamily\scriptsize]
    ack: nat * nat -&gt; nat 
    ack(m,n) == if m = 0 then n+1
           else if n = 0 then ack(m-1, 1)
           else               ack(m-1, ack(m, (n-1)))
    --@IsaMeasure( pair_less_VDMNat )
    --@Witness( ack(2, 1) )
    measure is not yet specified;
\end{vdmsl}
%
\noindent Note that the VDM measure is not defined, and that the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ@IsaMeasure‚Ä∫</span></span></span></span>
uses a construct from Isabelle called <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπpair_less‚Ä∫</span></span></span></span>. It is part of Isabelle's 
machinery of concrete orders for SCNP problems <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> KrausSCNP<span class="antiquote"><span class="antiquote">}</span></span></span></span>. 
It considers recursions over multiple parameters, where some might 
increase the number of calls (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚Äπe.g.‚Ä∫</span></span>~size-change). We are not aware of a 
mechanism to define such measures in VDM. 

We instantiate <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπpair_less‚Ä∫</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚ÄπVDMNat‚Ä∫</span></span></span></span>. It is defined as the lexicographic 
product over the transitive closure of a totally ordered relation between <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚ÄπVDMNat‚Ä∫</span></span></span></span> 
inputs<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚Åã</span></span>‚ÄπDetails of this definition in the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚ÄπVDMToolkit.thy‚Ä∫</span></span></span></span> file within the 
distribution in~<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">üåê</span></span>‚Äπhttps://github.com/leouk/VDM_Toolkit‚Ä∫</span></span>.‚Ä∫</span></span>. 

If VDM measures were over relations, the Ackermann measure could be defined defined in VDM,
assuming a standard definition of transitive closure<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚Åã</span></span>‚ÄπThe <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπvdmlib/Relations.vdmsl‚Ä∫</span></span></span></span> provides 
such definition in the VDM toolkit distribution.‚Ä∫</span></span>, as
%
\begin{vdmsl}[frame=none,basicstyle=\ttfamily\scriptsize]
  pair_less_VDMNat: () -&gt; set of ((nat * nat) * (nat * nat))
  pair_less_VDMNat() == lex_prod[nat, nat](less_than_VDMNat(), less_than_VDMNat());
  
  less_than_VDMNat: () -&gt; set of (nat * nat)
  less_than_VDMNat() == transitive_closure[nat]({ mk_(z', z) | z', z : nat &amp; z' &lt; z });
  
  lex_prod[@A,@B]: set of (@A * @A) * set of (@B * @B) -&gt; set of ((@A * @B) * (@A * @B))
  lex_prod(ra,rb) == 
      { mk_(mk_(a, b), mk_(a', b')) | a, a': @A, b, b': @B &amp; 
          mk_(a,a') in set ra or a = a' and mk_(b, b') in set rb };
\end{vdmsl}
%
That is, the lexicographic product of possibilities that are ordered in its parameters. 
The translation process is the same as above and produces the Isabelle below. ‚Ä∫</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pre_ack</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‚ÄπVDMNat <span class="main">‚áí</span> VDMNat <span class="main">‚áí</span> <span class="main">ùîπ</span>‚Ä∫</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">pre_ack</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">‚â°</span> inv_VDMNat <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">‚àß</span> inv_VDMNat <span class="free"><span class="bound"><span class="entity">n</span></span></span>‚Ä∫</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> pre_ack_defs <span class="main">=</span> pre_ack_def inv_VDMNat_def

<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>domintros<span class="main">)</span> <span class="entity">ack</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‚ÄπVDMNat <span class="main">‚áí</span> VDMNat <span class="main">‚áí</span> VDMNat‚Ä∫</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">ack</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> pre_ack <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span>
                  <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">+</span><span class="main">1</span>
             <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">ack</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="main">1</span>
             <span class="keyword1">else</span>               <span class="free">ack</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="free">ack</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">)</span>
             <span class="keyword1">else</span>               undefined<span class="main">)</span>‚Ä∫</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">pat_completeness</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">ack_wf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‚Äπ<span class="main">(</span><span class="main">(</span>VDMNat <span class="main">√ó</span> VDMNat<span class="main">)</span> <span class="main">√ó</span> <span class="main">(</span>VDMNat <span class="main">√ó</span> VDMNat<span class="main">)</span><span class="main">)</span> VDMSet‚Ä∫</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">ack_wf</span> <span class="main">‚â°</span> pair_less_VDMNat‚Ä∫</span></span>

<span class="keyword1"><span class="command">termination</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted">ack_wf</span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> wf_pair_less_VDMNat <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inv_VDMNat_def l_pair_less_VDMNat_I1 pre_ack_def<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inv_VDMNat_def pre_ack_def<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inv_VDMNat_def pair_less_VDMNat_def pre_ack_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπWe also show that this version of Ackermann with <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚ÄπVDMNat‚Ä∫</span></span></span></span> is equivalent to
  the usual Isabelle definition using <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">‚Ñï</span></span>‚Ä∫</span></span></span></span>. We omit details here, but have proved
that they are equivalent by induction‚Ä∫</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ack'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‚Äπ<span class="main">‚Ñï</span> <span class="main">‚áí</span> <span class="main">‚Ñï</span> <span class="main">‚áí</span> <span class="main">‚Ñï</span>‚Ä∫</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ack'</span> <span class="main">0</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>             <span class="main">=</span> Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ack'</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">0</span>       <span class="main">=</span> <span class="free">ack'</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">1</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ack'</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">ack'</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">(</span><span class="free">ack'</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ack''</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‚Äπ<span class="main">‚Ñï</span> <span class="main">‚áí</span> <span class="main">‚Ñï</span> <span class="main">‚áí</span> <span class="main">‚Ñï</span>‚Ä∫</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">ack''</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">ack''</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="free">ack''</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="free">ack''</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>‚Ä∫</span></span>
<span class="keyword1"><span class="command">lemma</span></span> l_ack''_1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">‚Äπack'' <span class="main">0</span> <span class="free">n</span> <span class="main">=</span> Suc <span class="free">n</span>‚Ä∫</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> l_ack''_2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">‚Äπack'' <span class="main">(</span>Suc <span class="free">m</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> ack'' <span class="free">m</span> <span class="main">1</span>‚Ä∫</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> l_ack''_3<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">‚Äπack'' <span class="main">(</span>Suc <span class="free">m</span><span class="main">)</span> <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> ack'' <span class="free">m</span> <span class="main">(</span>ack'' <span class="main">(</span>Suc <span class="free">m</span><span class="main">)</span> <span class="free">n</span><span class="main">)</span>‚Ä∫</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">theorem</span></span> ack_correct<span class="main">:</span> <span class="quoted"><span class="quoted">‚Äπack' <span class="free">m</span> <span class="free">n</span> <span class="main">=</span> ack <span class="free">m</span> <span class="free">n</span>‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="quoted">‚Äπ<span class="free">m</span>‚Ä∫</span></span> <span class="quoted"><span class="quoted">‚Äπ<span class="free">n</span>‚Ä∫</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ack'.induct<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_ack_defs<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚Äπ
In general, each complex recursion function will require such a setup. Fortunately, 
Isabelle has a number of options available. Yet, in general, the more complex the recursion, 
the more users will have to provide further machinery. For example, the next two 
examples for Nipkow's permutation function~<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> TermRewriting<span class="antiquote"><span class="antiquote">}</span></span></span></span> and Takeuchi's 
function<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚Åã</span></span>‚Äπ<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">üåê</span></span>‚Äπhttps://isabelle.in.tum.de/library/HOL/HOL-Examples/Functions.html‚Ä∫</span></span>‚Ä∫</span></span> 
require a rather ellaborate setup (see Appendix~\ref{app:Complex}).‚Ä∫</span></span>

<span class="comment1">(**************************************************************************************************)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‚ÄπDiscussion and conclusion\label{sec:Conclusion}‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπIn this paper we present a translation strategy from VDM to Isabelle
for recursive function over basic types, sets and maps. We also present how 
the strategy works for more complex recursion, such as the Ackermann's function.

The full VDM and Isabelle sources and proofs can be found at the VDM toolkit repository
at <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ./plugins/vdm2isa/src/main/resources/RecursiveVDM.*‚Ä∫</span></span></span></span><span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚Åã</span></span>‚Äπ<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">üåê</span></span>‚Äπhttps://github.com/leouk/VDM_Toolkit‚Ä∫</span></span>‚Ä∫</span></span>.‚Ä∫</span></span>

<span class="keyword1"><span class="command">paragraph</span></span> <span class="quoted"><span class="plain_text">‚ÄπFuture work.~We are implementing the translation strategy in the vdm2isa plugin,
which should be available for the VDM-VSCode <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> AdvancedVSCodePaper<span class="antiquote"><span class="antiquote">}</span></span></span></span> extension in the next release.‚Ä∫</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">lemma</span></span> l_sumset_rel_wf'<span class="main">:</span> <span class="quoted"><span class="quoted">‚Äπwf sumset_wf_rel‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> wf_measure<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">Œª</span></span> <span class="bound"><span class="bound">s</span></span> <span class="main"><span class="main">.</span></span> card <span class="bound"><span class="bound">s</span></span>‚Ä∫</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> wf_subset<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_def inv_image_def less_than_def less_eq<span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> case_prod_beta<span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> exE conjE<span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> card_Diff1_less_iff fst_conv inv_Map_defs<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> inv_Map_defs<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> pre_sumset_defs<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> snd_conv some_in_eq<span class="main">)</span><span class="comment1">‚úê<span class="quoted">‚Äπtag invisible‚Ä∫</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">paragraph</span></span> <span class="quoted"><span class="plain_text">‚ÄπAcknowledgements.~We appreciated discussions with Stephan Merz on 
pointers for complex well-founded recursion proofs in Isabelle, and with Nick
Battle on limits for VDM recursive measures.‚Ä∫</span></span>

<span class="comment1">(**************************************************************************************************)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‚ÄπFurther complex examples\label{app:Complex}‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚Äπ
%
\begin{vdmsl}[frame=none,basicstyle=\ttfamily\scriptsize]
    perm: int * int * int -&gt; int --nat
    perm(m,n,r) == if 0 &lt; r then perm(m, r-1, n) 
              else if 0 &lt; n then perm(r, n-1, m) else m
    pre ((0 &lt; r or 0 &lt; n) =&gt; m+n+r &gt; 0)
    measure maxs({m+n+r, 0});      

    tak: int * int * int -&gt; int
    tak(x,y,z) == if x &lt;= y then y  
                  else           tak(tak(x-1,y,z), tak(y-1,z,x), tak(z-1,x,y))
    measure is not yet specified;
\end{vdmsl}
%
\noindent The Takeuchi's function is particularly challenging in proofs and the translation strategy 
stands no chance of finding proofs for such definitions automatically.‚Ä∫</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‚ÄπNipkow's permutation function‚Ä∫</span></span>

<span class="keyword1"><span class="command">definition</span></span> 
  <span class="entity">pre_perm</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‚ÄπVDMInt <span class="main">‚áí</span> VDMInt <span class="main">‚áí</span> VDMInt <span class="main">‚áí</span> <span class="main">ùîπ</span>‚Ä∫</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">pre_perm</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">‚â°</span> 
      inv_VDMInt <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">‚àß</span> inv_VDMInt <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">‚àß</span> inv_VDMInt <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">‚àß</span> 
      <span class="main">(</span><span class="main">(</span><span class="main">0</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">‚à®</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">‚ü∂</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">+</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">+</span><span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span>‚Ä∫</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> pre_perm_defs <span class="main">=</span> pre_perm_def inv_VDMInt_def inv_True_def

<span class="keyword1"><span class="command">lemma</span></span> l_pre_perm_trivial<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>pre_perm <span class="free">m</span> <span class="free">n</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">0</span> <span class="main">&lt;</span> <span class="free">r</span> <span class="main">‚à®</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="free">n</span><span class="main">)</span> <span class="main">‚ü∂</span> <span class="free">m</span><span class="main">+</span><span class="free">n</span><span class="main">+</span><span class="free">r</span> <span class="main">&gt;</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> pre_perm_def inv_VDMInt_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>domintros<span class="main">)</span>
  <span class="entity">perm</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‚ÄπVDMInt <span class="main">‚áí</span> VDMInt <span class="main">‚áí</span> VDMInt <span class="main">‚áí</span> VDMInt‚Ä∫</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">perm</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">if</span> pre_perm <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">then</span>
      <span class="main">(</span>     <span class="keyword1">if</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">then</span> <span class="free">perm</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> 
       <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> <span class="free">perm</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span>
       <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> 
    <span class="keyword1">else</span>
      undefined<span class="main">)</span>
  ‚Ä∫</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">pat_completeness</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> 
  <span class="entity">perm_wf_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‚Äπ<span class="main">(</span><span class="main">(</span>VDMInt <span class="main">√ó</span> VDMInt <span class="main">√ó</span> VDMInt<span class="main">)</span> <span class="main">√ó</span> <span class="main">(</span>VDMInt <span class="main">√ó</span> VDMInt <span class="main">√ó</span> VDMInt<span class="main">)</span><span class="main">)</span> VDMSet‚Ä∫</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">perm_wf_rel</span> <span class="main">‚â°</span> 
      <span class="main">(</span><span class="main">{</span> <span class="main">(</span><span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">r</span><span class="main">-</span><span class="main">1</span><span class="main">,</span> <span class="bound">n</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">n</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main">|</span> <span class="bound">m</span> <span class="bound">r</span> <span class="bound">n</span> <span class="main">.</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="bound">r</span> <span class="main">‚àß</span> pre_perm <span class="bound">m</span> <span class="bound">n</span> <span class="bound">r</span><span class="main">}</span> 
      <span class="main">‚à™</span>
      <span class="main">{</span> <span class="main">(</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">n</span><span class="main">-</span><span class="main">1</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">n</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main">|</span> <span class="bound">m</span> <span class="bound">r</span> <span class="bound">n</span> <span class="main">.</span> <span class="main">¬¨</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="bound">r</span> <span class="main">‚àß</span> <span class="main">0</span> <span class="main">&lt;</span> <span class="bound">n</span> <span class="main">‚àß</span> pre_perm <span class="bound">m</span> <span class="bound">n</span> <span class="bound">r</span> <span class="main">}</span>
      <span class="main">)</span>    
  ‚Ä∫</span></span>

<span class="keyword1"><span class="command">lemma</span></span> l_perm_wf_rel<span class="main">:</span> <span class="quoted"><span class="quoted">"wf perm_wf_rel"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπThe Isabelle measure projection reflects the VDM measure: the sum of each parameter.
        ending up at zero (i.e. if negative, ignore).‚Ä∫</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"perm_wf_rel <span class="main">‚äÜ</span> measure <span class="main">(</span><span class="main">Œª</span> <span class="main">(</span><span class="bound">m</span><span class="main">,</span> <span class="bound">r</span><span class="main">,</span> <span class="bound">n</span><span class="main">)</span> <span class="main">.</span> nat <span class="main">(</span>max <span class="main">0</span> <span class="main">(</span><span class="bound">m</span><span class="main">+</span><span class="bound">r</span><span class="main">+</span><span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> subsetI<span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> perm_wf_rel_def case_prod_beta max_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> disjE conjE<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span> 
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> impI conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπThe setup with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">perm_wf_rel</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> works here if the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">pre_perm</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
      specifically curbs negative sums of parameters. Yet, the termination proof fails. 
      Tried various variations on gr or geq etc, no luck. Trying the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‚Äπmlex_prod‚Ä∫</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> style nest instead.‚Ä∫</span></span>
    <span class="keyword1"><span class="command">nitpick</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> wf_subset <span class="main"><span class="main">[</span></span><span class="operator">OF</span> wf_measure<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπWith the added precondition on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">pre_perm</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> about case when sum has to be positive,
      and the well founded proof above, the result worked well‚Ä∫</span></span>
<span class="keyword1"><span class="command">termination</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">‚Äπperm_wf_rel‚Ä∫</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_perm_wf_rel<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> perm_wf_rel_def<span class="main">)</span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‚ÄπTakeuchi's function (from HOL/Examples/Functions.thy)‚Ä∫</span></span>

<span class="keyword1"><span class="command">function</span></span> 
  <span class="entity">tak</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"VDMInt <span class="main">‚áí</span> VDMInt <span class="main">‚áí</span> VDMInt <span class="main">‚áí</span> VDMInt"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">tak</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">‚â§</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">else</span> <span class="free">tak</span> <span class="main">(</span><span class="free">tak</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">tak</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">tak</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> tak_pcorrect<span class="main">:</span>
  <span class="quoted"><span class="quoted">"tak_dom <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span> <span class="main">‚üπ</span> tak <span class="free">x</span> <span class="free">y</span> <span class="free">z</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">‚â§</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="free">y</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">y</span> <span class="main">‚â§</span> <span class="free">z</span> <span class="keyword1">then</span> <span class="free">z</span> <span class="keyword1">else</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">thm</span></span> tak.pinduct tak.psimps
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span> <span class="quoted"><span class="free">z</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> tak.pinduct<span class="main">)</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tak.psimps<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tak_m1</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">tak_m1</span> <span class="main">=</span> <span class="main">(</span><span class="main">Œª</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">‚â§</span> <span class="bound">y</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="main">1</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tak_m2</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">tak_m2</span> <span class="main">=</span> <span class="main">(</span><span class="main">Œª</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">.</span> nat <span class="main">(</span>Max <span class="main">{</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">,</span> <span class="bound">z</span><span class="main">}</span> <span class="main">-</span> Min <span class="main">{</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">,</span> <span class="bound">z</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tak_m3</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">tak_m3</span> <span class="main">=</span> <span class="main">(</span><span class="main">Œª</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">.</span> nat <span class="main">(</span><span class="bound">x</span> <span class="main">-</span> Min <span class="main">{</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">,</span> <span class="bound">z</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">x1</span><span class="main">,</span><span class="free">y1</span><span class="main">,</span><span class="free">z1</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">x2</span><span class="main">,</span><span class="free">y2</span><span class="main">,</span><span class="free">z2</span><span class="main">)</span><span class="main">)</span> <span class="main">‚àà</span> tak_m3 <span class="keyword1">&lt;*mlex*&gt;</span> <span class="main">{}</span><span class="main">)</span> <span class="main">‚ü∑</span> <span class="main">(</span>nat <span class="main">(</span><span class="free">x1</span> <span class="main">-</span> Min <span class="main">{</span><span class="free">x1</span><span class="main">,</span> <span class="free">y1</span><span class="main">,</span> <span class="free">z1</span><span class="main">}</span><span class="main">)</span> <span class="main">&lt;</span> nat <span class="main">(</span><span class="free">x2</span> <span class="main">-</span> Min <span class="main">{</span><span class="free">x2</span><span class="main">,</span> <span class="free">y2</span><span class="main">,</span> <span class="free">z2</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mlex_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> tak_m3_def
  <span class="comment1">(*apply (simp only: case_prod_beta fst_conv snd_conv) *)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">‚Äπ<span class="main">(</span><span class="main">(</span><span class="free">x1</span><span class="main">,</span><span class="free">y1</span><span class="main">,</span><span class="free">z1</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">x2</span><span class="main">,</span><span class="free">y2</span><span class="main">,</span><span class="free">z2</span><span class="main">)</span><span class="main">)</span> <span class="main">‚àà</span> <span class="main">(</span>tak_m2 <span class="keyword1">&lt;*mlex*&gt;</span> <span class="main">(</span>tak_m3 <span class="keyword1">&lt;*mlex*&gt;</span> <span class="main">{}</span><span class="main">)</span><span class="main">)</span>‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mlex_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> tak_m3_def tak_m2_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> case_prod_beta fst_conv snd_conv<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarify</span><span class="main">)</span>
  <span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> l_call1<span class="main">:</span> 
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">x</span> <span class="main">&gt;</span> <span class="free">y</span> <span class="main">‚üπ</span> <span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">-</span><span class="main">1</span><span class="main">,</span><span class="free">y</span><span class="main">,</span><span class="free">z</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">,</span><span class="free">z</span><span class="main">)</span><span class="main">)</span> <span class="main">‚àà</span> tak_m1 <span class="keyword1">&lt;*mlex*&gt;</span> <span class="main">(</span>tak_m2 <span class="keyword1">&lt;*mlex*&gt;</span> <span class="main">(</span>tak_m3 <span class="keyword1">&lt;*mlex*&gt;</span> <span class="main">{}</span><span class="main">)</span><span class="main">)</span>‚Ä∫</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mlex_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> tak_m3_def tak_m2_def tak_m1_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> case_prod_beta<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> min_def max_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span>if_splits<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> l_call2<span class="main">:</span>
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">x</span> <span class="main">&gt;</span> <span class="free">y</span> <span class="main">‚üπ</span> <span class="main">(</span><span class="main">(</span><span class="free">y</span><span class="main">-</span><span class="main">1</span><span class="main">,</span><span class="free">z</span><span class="main">,</span><span class="free">x</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">,</span><span class="free">z</span><span class="main">)</span><span class="main">)</span> <span class="main">‚àà</span> tak_m1 <span class="keyword1">&lt;*mlex*&gt;</span> <span class="main">(</span>tak_m2 <span class="keyword1">&lt;*mlex*&gt;</span> <span class="main">(</span>tak_m3 <span class="keyword1">&lt;*mlex*&gt;</span> <span class="main">{}</span><span class="main">)</span><span class="main">)</span>‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mlex_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> tak_m3_def tak_m2_def tak_m1_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> case_prod_beta<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span>  min_def max_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> l_call3<span class="main">:</span>
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">x</span> <span class="main">&gt;</span> <span class="free">y</span> <span class="main">‚üπ</span> <span class="main">(</span><span class="main">(</span><span class="free">z</span><span class="main">-</span><span class="main">1</span><span class="main">,</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span><span class="main">,</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">,</span><span class="free">z</span><span class="main">)</span><span class="main">)</span> <span class="main">‚àà</span> tak_m1 <span class="keyword1">&lt;*mlex*&gt;</span> <span class="main">(</span>tak_m2 <span class="keyword1">&lt;*mlex*&gt;</span> <span class="main">(</span>tak_m3 <span class="keyword1">&lt;*mlex*&gt;</span> <span class="main">{}</span><span class="main">)</span><span class="main">)</span>‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mlex_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> tak_m3_def tak_m2_def tak_m1_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> case_prod_beta<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span>  min_def max_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> l_call4<span class="main">:</span>
  <span class="quoted"><span class="quoted">‚Äπ<span class="free">x</span> <span class="main">&gt;</span><span class="free">y</span> <span class="main">‚üπ</span>  tak_dom <span class="main">(</span><span class="free">z</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">‚üπ</span>
       tak_dom <span class="main">(</span><span class="free">y</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="free">z</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">‚üπ</span>
       tak_dom <span class="main">(</span><span class="free">x</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="free">y</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span> <span class="main">‚üπ</span>
       <span class="main">(</span><span class="main">(</span>tak <span class="main">(</span><span class="free">x</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="free">y</span> <span class="free">z</span><span class="main">,</span> tak <span class="main">(</span><span class="free">y</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="free">z</span> <span class="free">x</span><span class="main">,</span> tak <span class="main">(</span><span class="free">z</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span><span class="main">,</span> <span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span>
       <span class="main">‚àà</span> tak_m1 <span class="keyword1">&lt;*mlex*&gt;</span> tak_m2 <span class="keyword1">&lt;*mlex*&gt;</span> tak_m3 <span class="keyword1">&lt;*mlex*&gt;</span> <span class="main">{}</span>‚Ä∫</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mlex_iff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tak_pcorrect<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> tak_m3_def tak_m2_def tak_m1_def 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> case_prod_beta<span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span>  min_def max_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">termination</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"tak_m1 <span class="keyword1">&lt;*mlex*&gt;</span> tak_m2 <span class="keyword1">&lt;*mlex*&gt;</span> tak_m3 <span class="keyword1">&lt;*mlex*&gt;</span> <span class="main">{}</span>"</span></span><span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wf_mlex<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_call1<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_call2<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_call3<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_call4<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> tak_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"tak <span class="free">x</span> <span class="free">y</span> <span class="free">z</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">‚â§</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="free">y</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">y</span> <span class="main">‚â§</span> <span class="free">z</span> <span class="keyword1">then</span> <span class="free">z</span> <span class="keyword1">else</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span> <span class="quoted"><span class="free">z</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> tak.induct<span class="main">)</span> <span class="operator">auto</span>
<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</body>

</html>