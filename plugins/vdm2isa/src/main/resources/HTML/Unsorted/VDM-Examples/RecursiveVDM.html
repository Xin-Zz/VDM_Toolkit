<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>Theory RecursiveVDM</title>
</head>


<body>
<div class="head">
<h1>Theory RecursiveVDM</h1>
</div>

<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> RecursiveVDM
<span class="keyword2"><span class="keyword">imports</span></span> <a href="VDMToolkit.html">VDMToolkit</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="comment1">(**************************************************************************************************)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Introduction›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This paper describes a translation strategy for a variety of recursive definitions from 
VDM to Isabelle/HOL. The strategy takes into account the differences in how termination and well-foundedness 
are represented in both formalisms. 

It is an extension to a VDM to Isabelle/HOL translation strategy and 
implementation\footnote{\url{https://github.com/leouk/VDM_Toolkit}} as a plugin to 
VDMJ~\cite{Battle09} and extension to VDM-VSCode~\cite{AdvancedVSCodePaper}.›</span></span>

<span class="comment1">(**************************************************************************************************)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Background›</span></span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The VDM to Isabelle/HOL translator caters for a wide range of the VDM AST. It copes with all kinds 
of expressions, a variety VDM patterns, all VDM types, VDM imports and exports, VDM functions and specifications,
VDM traces, and some of VDM state and operations. Even though not all kinds of VDM patterns are allowed,
the translator copes with most, and where it does not, a corresponding equivalent is possible. Among the 
expressions, map comprehension is of note, given its (implicit) complexity.

One particular area we want to extend the translation into is the one over recursively defined functions. 
VDM requires the user to define a measure function to justify why recursion will terminate. It then generates
proof obligations to ensure totality and termination. 

ANYTHING ELSE? Relates work?
›</span></span>

<span class="comment1">(**************************************************************************************************)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹VDM basic types in Isabelle›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Isabelle represents natural numbers (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">ℕ</span></span>›</span></span></span></span>) as a (data) type with two constructors (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">0</span></span>›</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹Suc <span class="free"><span class="free">n</span></span>›</span></span></span></span>), 
  where all numbers are projections over such constructions (\textit{e.g.}~<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="numeral"><span class="numeral">3</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">(</span></span>Suc <span class="main"><span class="main">(</span></span>Suc <span class="main"><span class="main">(</span></span>Suc <span class="main"><span class="main">0</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span>"</span></span> <span class="keyword1"><span class="keyword"><span class="keyword1"><span class="keyword">by</span></span></span></span> <span class="operator"><span class="operator">simp</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.   
  Isabelle integers (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">ℤ</span></span>›</span></span></span></span>) are defined as quotient type involving two natural numbers. Like with integers, other
  Isabelle numeric types (\textit{e.g.}~rationals<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">ℚ</span></span>›</span></span></span></span>, reals <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">ℝ</span></span>›</span></span></span></span>, \textit{etc.}) are defined in terms of some
  involved natural number construction. Type conversions (or coercions) are then defined to allow users to jump
  between type spaces. Nevertheless, Isabelle has no implicit type widening rule for <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">ℕ</span></span>›</span></span></span></span>; instead, it takes the
  following convention:~<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">lemma</span></span> <span class="quoted"><span class="quoted">‹<span class="main"><span class="main">(</span></span><span class="main"><span class="main">0</span></span> <span class="main"><span class="main">-</span></span> <span class="free"><span class="free">x</span></span><span class="main"><span class="main">::</span></span><span class="main"><span class="main">ℕ</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">0</span></span>›</span></span> <span class="keyword1"><span class="keyword"><span class="keyword1"><span class="keyword">by</span></span></span></span> <span class="operator"><span class="operator">simp</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. For mixutre of<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">ℤ</span></span>›</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">ℕ</span></span>›</span></span></span></span>, explicit user-defined
  type coercions are needed (\textit{e.g.}~<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">lemma</span></span> <span class="quoted"><span class="quoted">‹<span class="main"><span class="main">(</span></span><span class="numeral"><span class="numeral">2</span></span><span class="main"><span class="main">::</span></span><span class="main"><span class="main">ℕ</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">-</span></span> <span class="main"><span class="main">(</span></span><span class="numeral"><span class="numeral">3</span></span><span class="main"><span class="main">::</span></span><span class="main"><span class="main">ℤ</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">-</span></span><span class="main"><span class="main">1</span></span>›</span></span> <span class="keyword1"><span class="keyword"><span class="keyword1"><span class="keyword">by</span></span></span></span> <span class="operator"><span class="operator">simp</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>).

  VDM expressions with basic-typed (\texttt{nat}, \texttt{int}) variables have specific type widening rules 
  (\textit{i.e.}~even if both variables are \texttt{nat}, the result might be \textit{int}). Therefore, our translation 
  strategy considers VDM \texttt{nat} as the Isabelle type <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹VDMNat›</span></span></span></span>, which is just a type synonym for <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">ℤ</span></span>›</span></span></span></span>. This 
  simplifies the translation process to Isabelle, such that no type coercions are necessary to encode all VDM type widenning rules. 
›</span></span>

<span class="comment1">(**************************************************************************************************)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Recursion in VDM and in Isabelle›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Recursive definitions are pervasive in most VDM models. For example, it can be used to perform 
iterations over numbers, lists, sets, \textit{etc}. An important aspect of every recursive definition
is an argument that justifies its termination (\textit{i.e.}~otherwise, the recursion might go on 
in an infinite loop).

In VDM, this is defined using a recursive measure:~it has the same input type signature as
the recursive definition, and returns a \texttt{nat}, which \textbf{must} monotonically decrease 
at each recursive call, eventually reaching zero. This is how termination of recursive definitions 
are justified in VDM. 

A simple example of VDM recursive definition is one for calculating the factorial of a given natural number
%
\begin{vdmsl}[frame=noframe,basicstyle=\ttfamily\scriptsize]
   factorial: nat -&gt; nat 
   factorial(n) == if n = 0 then 1 else n * factorial(n - 1)
   -- For the measure below, VDMJ produces a measure function as: 
   -- measure_factorial: nat -&gt; nat
   -- measure_factorial(n) == n
   measure n;   
\end{vdmsl} 
%
\noindent The VDM recursive measure simply uses \texttt{n} itself; this works because the only recursive 
call is made with a decreasing value of \texttt{n}, until it reaches \texttt{0} and terminates. VDMJ generates 
three proof obligations for the definition above.
%
\begin{vdmsl}[frame=noframe,basicstyle=\ttfamily\scriptsize]
  Proof Obligation 1: (Unproved)
  factorial; measure_factorial: total function obligation in 'RecursiveVDM' at line 10:12
  (forall n:nat &amp; is_(measure_factorial(n), nat))
  
  Proof Obligation 2: (Unproved)
  factorial: subtype obligation in 'RecursiveVDM' at line 6:57
  (forall n:nat &amp; (not (n = 0) =&gt; (n - 1) &gt;= 0))
  
  Proof Obligation 3: (Unproved)
  factorial: recursive function obligation in 'RecursiveVDM' at line 5:4
  (forall n:nat &amp; (not (n = 0) =&gt; measure_factorial(n) &gt; measure_factorial((n - 1))))
\end{vdmsl} 
%
\noindent They are trivial to discharge in Isabelle given the definition of \texttt{measure\_factorial} is just \texttt{n} 
(\textit{e.g.}~<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">lemma</span></span> <span class="quoted"><span class="quoted">‹<span class="main"><span class="main">∀</span></span> <span class="bound"><span class="bound">n</span></span><span class="main"><span class="main">::</span></span><span class="main"><span class="main">ℕ</span></span> <span class="main"><span class="main">.</span></span> <span class="main"><span class="main">¬</span></span> <span class="bound"><span class="bound">n</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">0</span></span> <span class="main"><span class="main">⟶</span></span> <span class="bound"><span class="bound">n</span></span> <span class="main"><span class="main">-</span></span> <span class="main"><span class="main">1</span></span> <span class="main"><span class="main">≥</span></span> <span class="main"><span class="main">0</span></span>›</span></span> <span class="keyword1"><span class="keyword"><span class="keyword1"><span class="keyword">by</span></span></span></span> <span class="operator"><span class="operator">simp</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">lemma</span></span> <span class="quoted"><span class="quoted">‹<span class="main"><span class="main">∀</span></span> <span class="bound"><span class="bound">n</span></span><span class="main"><span class="main">::</span></span><span class="main"><span class="main">ℕ</span></span> <span class="main"><span class="main">.</span></span> <span class="main"><span class="main">¬</span></span> <span class="bound"><span class="bound">n</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">0</span></span> <span class="main"><span class="main">⟶</span></span> <span class="bound"><span class="bound">n</span></span> <span class="main"><span class="main">&gt;</span></span> <span class="bound"><span class="bound">n</span></span> <span class="main"><span class="main">-</span></span> <span class="main"><span class="main">1</span></span>›</span></span> <span class="keyword1"><span class="keyword"><span class="keyword1"><span class="keyword">by</span></span></span></span> <span class="operator"><span class="operator">simp</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>).
 
In Isabelle, recursive definitions can be provided through primitive recursion or function definitions. 
The former insists on definition for each type constructor and only provides simplification rules; whereas
the latter allow for more sophisticated input patterns and provides simplification, elimination and 
induction rules, as well as partial function considerations. For the purposes of this paper, we only 
consider function definitions. Readers can find more about these differences in~\cite{IsaFunctionPackage}. 

Isabelle recursive functions requires a proof obligation that parameters represent a constructive and 
compatible pattern, and that recursive calls terminate. Constructive patterns relates to all constructors 
in data type being defined in the recursion (\textit{e.g.,}~one equation for each of the constructors of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">ℕ</span></span>›</span></span></span></span>, 
hence one involving <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">0</span></span>›</span></span></span></span> and another involving <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹Suc <span class="free"><span class="free">n</span></span>›</span></span></span></span>). Compatible patterns relates to multiple ways 
patterns can be constructed will boil down to the pattern completeness cases (\textit{e.g.,}~<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">n</span></span> <span class="main"><span class="main">+</span></span> <span class="numeral"><span class="numeral">2</span></span>›</span></span></span></span> being 
simply multiple calls over defined constructors like <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹Suc <span class="main"><span class="main">(</span></span>Suc <span class="free"><span class="free">n</span></span><span class="main"><span class="main">)</span></span>›</span></span></span></span>). That is important to ensure that recursion 
is well structured (\textit{i.e.,}~recursive calls will not get stuck because some constructs are not available). 
For example, if you miss the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">0</span></span>›</span></span></span></span> case, eventually the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹Suc <span class="free"><span class="free">n</span></span>›</span></span></span></span> case will reach zero and fail as no patterns for zero exist. 
The proof obligation for termination establishes that the recursion is well-founded. This has to be proved whenever 
properties of defined function are meant to be total. 

Isabelle function definitions can be given with either <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">fun</span></span>›</span></span></span></span> or <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">function</span></span>›</span></span></span></span>. The
former attempts to automatically prove the pattern constructive and compatible proofs and finds a measure 
for other termination proof obligations. The latter allows the user to do the proof manually, as well as provide a measure relation.
This relation must be well-formed, which means have a well-ordered induction principle over a partially ordered relation\footnote{For 
details on what that means in Isabelle, see the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">class</span><span class="hidden">&gt;</span></span></span>‹wellorder›</span></span> theorem <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> wf<span class="antiquote"><span class="antiquote">}</span></span></span></span> in theory \texttt{Wellfounded.thy}}. 
For example, an Isabelle definition of factorial that it automatically discovers all three proofs can be given as›</span></span>
<span class="comment1">(*
find_theorems name:wellorder
print_locale! wellorder *)</span>
<span class="keyword1"><span class="command">fun</span></span> 
  <span class="entity">factorial</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="main">ℕ</span> <span class="main">⇒</span> <span class="main">ℕ</span>›</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">factorial</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">*</span> <span class="main">(</span><span class="free">factorial</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
<span class="comment1">(*
fun 
  factorial' :: ‹ℤ ⇒ ℤ›
  where 
  "factorial' n = (if n = 0 then 1 else n * (factorial' (n - 1)))" 

function 
  factorial' :: ‹ℤ ⇒ ℤ›
  where 
  "factorial' n = (if n = 0 then 1 else n * (factorial' (n - 1)))" 
  by (pat_completeness, auto)
termination 
  sledgehammer
*)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This Isabelle definition is pretty much 1-1 with the VDM definition. Nevertheless, as mentioned above, VDM basic types widening rules 
necessitated we translate them to <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹VDMNat›</span></span></span></span>, which is just <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">ℤ</span></span>›</span></span></span></span>. Moreover, <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">ℤ</span></span>›</span></span></span></span> is defined in terms of a pair of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">ℕ</span></span>›</span></span></span></span>, 
hence recursion over <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">ℤ</span></span>›</span></span></span></span> will be involved. Thus, VDM recursive functions translation to Isabelle will be involved as well. 
For example, the same version of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹factorial›</span></span></span></span> defined for <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">ℤ</span></span>›</span></span></span></span> will fail with the error that \textit{Could not find 
lexicographic termination order}. That is, Isabelle manages to discharge the pattern proofs <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">ℤ</span></span>›</span></span></span></span>, but not the termination one. 

Even if we could avoid this VDM basic types translation technicality, the same problem would occur for VDM recursion over
non constructive types, such as sets or maps. That is, Isabelle only allow recursion over finite sets, which are not defined 
constructively but inductively (\textit{e.g.}~<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">finite</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]. Similarly, Isabelle maps are defined with specialised HOL functions, 
again with domains that are not constructively defined. The only easy recursive definition translation from VDM to Isabelle are those
involving lists, given lists in Isabelle are defined constructively and VDM sequences maps directly to them.      

Therefore, defining recursive functions over non-constructive types entail more involved compatibility and completeness proofs.
They also usually lead to partial function definitions, given Isabelle cannot tell whether termination is immediately obvious. 
In VDM, however, recursive functions on sets (as well as map domains) are common, hence the need for the extending the translation strategy.›</span></span>

<span class="comment1">(**************************************************************************************************)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹VDM recursion translation strategy›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We want to identify a translation strategy that will cater for such issues described above not only 
for basic types, but also for sets, sequences, maps, \textit{etc}. This is important to ensure that the
translator will cater for most commonly used VDM recursion definition patterns.   

As mentioned in~\cite{VDMJAnnotations,AdvancedVSCodePaper}, it is possible to define formal annotations 
(as comments), which VDMJ will process and make available for its plugins. For our general translation
strategy, we create a new annotation called \verb'@IsaMeasure'. It defines a user-provided well-founded 
measure relation that will participate in the Isabelle proofs of termination. For example, for the 
factorial function above, the user would have to write
%
\begin{vdmsl}[frame=noframe,basicstyle=\ttfamily\scriptsize]
  factorial: nat -&gt; nat 
  factorial(n) == if n = 0 then 1 else n * factorial(n-1)
  --@IsaMeasure( { (n -1, n) | n : nat &amp; n &lt;&gt; 0 } )
  measure n;
\end{vdmsl}
%
\noindent This measure relation corresponds to the relationship between the recursive call (\texttt{factorial(n-1)})
and its defining equation (\texttt{factorial(n)}), where the filtering condition determines for which values of \texttt{n}
should the relation refer to (\textit{e.g.}~non-zero values). More interesting measure relation examples are defined in Section~\ref{subsec:Complex}.  

During translation, the plugin will typecheck the \verb'@IsaMeasure' annotation (\textit{i.e.,}~it is a type correct relation over the function signature).
Next, it will translate the annotation and some automation lemmas as series of Isabelle definitions to be used during the proof
of termination of translated VDM recursive functions. If no annotation is provided, following similar principles from Isabelle, 
the plugin will try to automatically infer what the measure relation should based on the structure of the recursive function definition.
When this fails, the user is informed. Still, even if measure relation synthesis succeeds, the user still have to appropriately use it 
during Isabelle's termination proof. 

In what follows, we will detail the translation strategy for each relevant VDM type. For details over the overall translation 
strategy, see examples in the distribution\footnote{\url{https://github.com/leouk/VDM_Toolkit}} and~\cite{NimFull}. That is we impose 
various implicit VDM checks as explicit predicates. For example, VDM sets are always finite, and type invariants over set elements must
hold for every element.
%TODO: or the paper on the translation! 
›</span></span>

<span class="comment1">(*-------------------------------------------------------------------------------------------------*)</span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Recursion over VDM basic types (\texttt{nat}, \texttt{int})\label{subsec:VDMNat}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Following the general translation strategy~\cite{NimFull}, we first encode the implicit precondition of 
factorial that insists that the given parameter <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">n</span></span>›</span></span></span></span> is a <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹VDMNat›</span></span></span></span>, alongside a list of defining constants 
that are useful for proof strategy synthesis.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> 
  <span class="entity">pre_vdm_factorial</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹VDMNat <span class="main">⇒</span> <span class="main">𝔹</span>›</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‹<span class="free">pre_vdm_factorial</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">≡</span> inv_VDMNat <span class="free"><span class="bound"><span class="entity">n</span></span></span>›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> pre_vdm_factorial_defs <span class="main">=</span> pre_vdm_factorial_def inv_VDMNat_def 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Next, we define the factorial function through recursion. When the precondition fails, 
  we return <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹undefined›</span></span></span></span>, which is a term that cannot be reasoned with in Isabelle (\textit{i.e.}~it is a dead end).
   Otherwise, we define factorial pretty much as in the VDM definition.

The <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">domintros</span></span>›</span></span></span></span> tag tells Isabelle to generate domain predicates, in case this function is not total. 
Domain predicates are important to our strategy because of course every VDM function will be undefined, when
applied outside its precondition. It also generates domain-predicate sensitive proof rules listed below.›</span></span>
<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>domintros<span class="main">)</span> <span class="entity">vdm_factorial</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹VDMNat <span class="main">⇒</span> VDMNat›</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‹<span class="free">vdm_factorial</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">if</span> pre_vdm_factorial <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span>
      <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> 
        <span class="main">1</span>
      <span class="keyword1">else</span>
        <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">*</span> <span class="main">(</span><span class="free">vdm_factorial</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>
      <span class="main">)</span>
    <span class="keyword1">else</span>
      undefined<span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The proof obligations for pattern compatibility and completeness are next <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">goals</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]›</span></span>
  
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  They are discharged with the usual Isabelle proof strategy for simple recursive patterns with the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">method</span></span> pat_completeness<span class="antiquote"><span class="antiquote">}</span></span></span></span> method.
  In the general (see more complex recursive call cases below in Section~\ref{subsec:Complex}), 
  the user might have goals to discharge.›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">pat_completeness</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Various theorems are made available, such as:
  <span class="antiquoted"><span class="antiquoted">▪</span></span> Case analysis <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> vdm_factorial.cases<span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]
  <span class="antiquoted"><span class="antiquoted">▪</span></span> Elimination rules (partial) <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> vdm_factorial.pelims<span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]
  <span class="antiquoted"><span class="antiquoted">▪</span></span> Induction rules (partial) <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> vdm_factorial.pinduct<span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]
  <span class="antiquoted"><span class="antiquoted">▪</span></span> Simplification rules (partial) <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> vdm_factorial.psimps<span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]

  Note the last two are partial, module a domain predicate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">vdm_factorial_dom</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  which represents a well-founded relation that ensures termination. That is, if the user does not want
  (or know how to) to prove termination, such domain predicates will follow every application of the 
  factorial definition, hence imposing users the requirement that such well-founded relation is still missing.
 
  If/when the termination proof is discharged, these p-rules can be simplified into total rules that 
  do not depend on a domain predicate, given a well-founded relation has been provided. Domain predicates
  will complicate user proofs, and also make proof strategy synthesis harder to figure out.

  Termination proof is discharged by establishing a well-founded relation associated with 
  the function recursive call(s) with respect to its declaration. In our case, the \verb'@IsaMeasure'
  annotation is translated as the Isabelle abbreviation. We also implicitly add the filter that the 
  function precondition holds:~this is important to ensure the termination proof never reaches the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹undefined›</span></span></span></span> case.  
  The other filter comes from the negated test in the definition if-statement. More complex definitions will
  have more involved filters (see Section~\ref{subsec:Complex}. 
  We use abbreviation instead of definition to avoid needing to expand the defined term.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> 
  <span class="entity">vdm_factorial_wf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span>VDMNat <span class="main">×</span> VDMNat<span class="main">)</span> set›</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">vdm_factorial_wf</span> <span class="main">≡</span> <span class="main">{</span> <span class="main">(</span><span class="bound">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="bound">n</span><span class="main">)</span> <span class="main">|</span> <span class="bound">n</span> <span class="main">.</span> pre_vdm_factorial <span class="bound">n</span> <span class="main">∧</span> <span class="bound">n</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Given <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹vdm_factorial›</span></span></span></span> is a simple (non-mutual, single call-site, easy measure relation choice) recursion, 
  thankfully the setup is not as complex to establish well-foundedness. For recursions of this nature, we can 
  piggyback on some Isabelle machinery to help prove well foundedness by using the terms:

    <span class="antiquoted"><span class="antiquoted">▸</span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">gen_VDMNat_term</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]
    <span class="antiquoted"><span class="antiquoted">▸</span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">int_ge_less_than</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]

  The first term is defined in terms of the second, which is a subset of our well-formed relation <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹vdm_factorial_wf›</span></span></span></span>. 
  Isabelle has proofs about the term's well formedness <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹int_ge_less_than›</span></span></span></span> 

  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> wf_int_ge_less_than<span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]

  Thus, making the proof our term being well founded trivial, and easily discovered with proof tools like
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span>. As part of the translation strategy, we then define (and automatically discover the proof of)
  the following lemma. This follows the strategy described in~\cite{KrausSCNP}. 
    %\url{https://www21.in.tum.de/~krauss/papers/scnp-wst.pdf}.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> l_vdm_factorial_term_wf<span class="main">:</span> <span class="quoted"><span class="quoted">"wf <span class="main">(</span>gen_VDMNat_term vdm_factorial_wf<span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wf_int_ge_less_than wf_Int1<span class="main">)</span>

<span class="keyword1"><span class="command">termination</span></span> 
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, we prove termination using the previously proved lemma using the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">method</span></span> relation<span class="antiquote"><span class="antiquote">}</span></span></span></span> for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">goals</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]
  This simplifies the goal into well formedness of termination relation and that the precondition implies it,
  both of which are easily proved with simplification in this case.›</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span>gen_VDMNat_term vdm_factorial_wf<span class="main">)</span>›</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This transforms the mysterious/abstract domain predicate into two new subgoals <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]›</span></span>
  <span class="keyword1"><span class="command">using</span></span> l_vdm_factorial_term_wf <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">presburger</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_vdm_factorial_defs int_ge_less_than_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For this simple example, these goals are proved with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span>. In general, the user will be
  have to either find the proof, or deal with domain predicates in proofs involving the recursive call.

  After the termination proof is discharged, Isabelle provides total versions of useful rules as:
  <span class="antiquoted"><span class="antiquoted">▪</span></span> Elimination rules (total) <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> vdm_factorial.elims<span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]   
  <span class="antiquoted"><span class="antiquoted">▪</span></span> Induction rules (total)  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> vdm_factorial.induct<span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]
  <span class="antiquoted"><span class="antiquoted">▪</span></span> Simplification rules (total) <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> vdm_factorial.simps<span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹To make sure our choice is valid (\textit{e.g.}~doesn't lead to the empty relation), we ensure
  that indeed the termination relation is in fact the same as the well founded predicate by proving the next goal.
  This is something users might want to do, but is not part of the translation strategy. In case the measure relation 
  is empty, the recursive call simplification rules will not be useful anyhow.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> l_vdm_factorial_term_valid<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>gen_VDMNat_term vdm_factorial_wf<span class="main">)</span> <span class="main">=</span> vdm_factorial_wf"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_vdm_factorial_defs<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> equalityI subsetI<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_ge_less_than_def case_prod_beta<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="comment1">(*-------------------------------------------------------------------------------------------------*)</span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Recursion over VDM sets\label{subsec:VDMSet}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Next, we extend the translation strategy for basic types for VDM sets. For this, we will use a 
 recursively defined VDM function over sets that sums the set elements as
%
\begin{vdmsl}[frame=noframe,basicstyle=\ttfamily\scriptsize]
    sumset: set of nat -&gt; nat 
    sumset(s) == if s = {} then 0 else let e in set s in sumset(s - {e}) + e
    --@IsaMeasure( { (x - { let e in set x in e }, x) | x : set of nat &amp; x &lt;&gt; {} } ) 
    --@Witness(sumset({ 1 }))
    measure card s;
\end{vdmsl}
%
\noindent Like most common VDM recursion over sets, the function consumes the set by picking each 
set element and them calling the recursive call without the element picked, until the set is empty. 
The VDM measure states that the recursion is based on the cardinality of the input parameter;~this is 
not useful for Isabelle's recursive definition proofs and is ignored during translation.

    In Isabelle, the implicit VDM checks are defined as the precondition, which ensures 
    that the given set contains only natural numbers, and is finite, as defined by <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹inv_VDMSet'›</span></span></span></span>[display]›</span></span>

<span class="keyword1"><span class="command">definition</span></span> 
  <span class="entity">pre_sumset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"VDMNat VDMSet <span class="main">⇒</span> <span class="main">𝔹</span>"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pre_sumset</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> inv_VDMSet' inv_VDMNat <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> pre_sumset_defs <span class="main">=</span> pre_sumset_def inv_VDMSet'_defs inv_VDMNat_def

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define the VDM recursive function in Isabelle next. It checks whether the given
      set satisfy the function precondition, returning <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹undefined›</span></span></span></span> if not.
      If it does, then each case is encoded pretty much 1-1 from VDM. The translation strategy for
      VDM \verb'let-in-set' patterns uses Isabelle's Hilbert's choice operator (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">ϵ</span></span> <span class="bound"><span class="bound">x</span></span> <span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">x</span></span> <span class="main"><span class="main">∈</span></span> <span class="free"><span class="free">s</span></span>›</span></span></span></span>).
    Note this naturally extends to VDM's \verb'let-be-st' patterns as well.›</span></span>
<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>domintros<span class="main">)</span>
  <span class="entity">sumset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"VDMNat VDMSet <span class="main">⇒</span> VDMNat"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">sumset</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> 
    <span class="main">(</span><span class="keyword1">if</span> pre_sumset <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">then</span> 
        <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span> 
            <span class="main">0</span> 
         <span class="keyword1">else</span> 
            <span class="keyword1">let</span> <span class="bound">e</span> <span class="main">=</span> <span class="main">(</span><span class="main">ϵ</span> <span class="bound">x</span> <span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="keyword1">in</span> 
              <span class="free">sumset</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">-</span> <span class="main">{</span><span class="bound">e</span><span class="main">}</span><span class="main">)</span> <span class="main">+</span> <span class="bound">e</span><span class="main">)</span> 
     <span class="keyword1">else</span> 
        undefined
    <span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The pattern completeness and compatibility goals are given as 
        <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">goals</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]

        We follow the usual proof strategy for this using <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">method</span></span> pat_completeness<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
        For more general examples, if that fails, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span> should be used.
       ›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">pat_completeness</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The measure relation for termination is defined with the \verb'@IsaMeasure' annotation above as 
   the smaller set after picking <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">e</span></span>›</span></span></span></span> (\textit{e.g.}~<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">s</span></span> <span class="main"><span class="main">-</span></span> <span class="main"><span class="main">{</span></span><span class="main"><span class="main">(</span></span><span class="main"><span class="main">ϵ</span></span> <span class="bound"><span class="bound">e</span></span> <span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">e</span></span> <span class="main"><span class="main">∈</span></span> <span class="free"><span class="free">s</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">}</span></span>›</span></span></span></span>), 
    and the set used at the entry call, leading to the pairs <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">(</span></span><span class="free"><span class="free">s</span></span> <span class="main"><span class="main">-</span></span> <span class="main"><span class="main">{</span></span><span class="main"><span class="main">(</span></span><span class="main"><span class="main">ϵ</span></span> <span class="bound"><span class="bound">e</span></span> <span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">e</span></span> <span class="main"><span class="main">∈</span></span> <span class="free"><span class="free">s</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">}</span></span><span class="main"><span class="main">,</span></span> <span class="free"><span class="free">s</span></span><span class="main"><span class="main">)</span></span>›</span></span></span></span>. 
    Finally, we ensure all the relation elements satisfy the function precondition (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹pre_sumset›</span></span></span></span>),
   and that the if-test is negated.
›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> 
  <span class="entity">sumset_wf_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>VDMNat VDMSet <span class="main">×</span> VDMNat VDMSet<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sumset_wf_rel</span> <span class="main">≡</span> <span class="main">{</span> <span class="main">(</span><span class="bound">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="main">ϵ</span> <span class="bound">e</span> <span class="main">.</span> <span class="bound">e</span> <span class="main">∈</span> <span class="bound">s</span><span class="main">)</span><span class="main">}</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">|</span> <span class="bound">s</span> <span class="main">.</span> pre_sumset <span class="bound">s</span> <span class="main">∧</span> <span class="bound">s</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Given this is a simple (non-mutual, single call-site, easy set element choice) recursion, again
   we can piggyback on Isabelle machinery by using the terms:

    <span class="antiquoted"><span class="antiquoted">▸</span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">gen_set_term</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]
    <span class="antiquoted"><span class="antiquoted">▸</span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">finite_psubset</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]

    They establishes that a relation where the first element is strictly smaller set than the 
    second element in the relation pair is well-formed. This makes the proof of well-foundedness easy 
    for <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹sumset_wf_rel›</span></span></span></span> through <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span>. ›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> l_sumset_rel_wf<span class="main">:</span> <span class="quoted"><span class="quoted">"wf <span class="main">(</span>gen_set_term sumset_wf_rel<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> l_gen_set_term_wf <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">termination</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Next, we tackle the termination proof, with the same setup with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">method</span></span> relation<span class="antiquote"><span class="antiquote">}</span></span></span></span> again.›</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> <span class="quoted">"termination"</span><span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span>gen_set_term sumset_wf_rel<span class="main"><span class="main">)</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> l_sumset_rel_wf <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Unfortunately, using <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span> fails to discharge the second subgoal <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]›</span></span>
  <span class="keyword1"><span class="command">oops</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Fortunately, for most simple situations, this is easy to decompose in general. The translation strategy takes the 
    \verb'@IsaMeasure' expression and decompose its parts, such that the filtering predicates are assumptions, and
    the element in the relation belong to the well-formed measure chosen. For the concrete set example, this is defined 
  in the next lemma, which require some manual intervention to tell Isabelle what definitions to unfold and simplify with. 
  Then, Isabelle's <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span> can finish the proof.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> l_pre_sumset_sumset_wf_rel<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"pre_sumset <span class="free">s</span> <span class="main">⟹</span> <span class="free">s</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">s</span> <span class="main">-</span> <span class="main">{</span><span class="main">(</span><span class="main">ϵ</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">s</span><span class="main">)</span><span class="main">}</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>gen_set_term sumset_wf_rel<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> gen_set_term_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_sumset_defs<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Diff_subset member_remove psubsetI remove_def some_in_eq<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The intuition behind this lemma is that, elements in the measure relation satisfy well-formedness under the function 
  precondition and the filtering case (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="free"><span class="free">s</span></span> <span class="main"><span class="main">≠</span></span> <span class="main"><span class="main">{}</span></span>›</span></span></span></span>) where the recursive call is made. That is, the precondition and 
  filtering condition help establish the terminating relation. For this particular proof, the only aspect needed from the 
  precondition (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹pre_sumset›</span></span></span></span>) is that the set is finite. 

  With this, we can try the termination proof again, which now <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span> find proofs for all subgoals.›</span></span>
<span class="keyword1"><span class="command">termination</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> <span class="quoted">"termination"</span><span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span>gen_set_term sumset_wf_rel<span class="main"><span class="main">)</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> l_sumset_rel_wf <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">using</span></span> l_pre_sumset_sumset_wf_rel <span class="keyword1"><span class="command">by</span></span> <span class="operator">presburger</span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">lemma</span></span> l_pre_vdm_factorial_wf_rel'<span class="main">:</span> <span class="quoted"><span class="quoted">"pre_vdm_factorial <span class="free">n</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span> <span class="main">∈</span> gen_VDMNat_term vdm_factorial_wf"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> gen_VDMNat_term_def gen_VDMInt_term_def
  <span class="keyword1"><span class="command">using</span></span> l_vdm_factorial_term_valid <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Note we omit such lemma over termination and precondition for the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹VDMNat›</span></span></span></span> case in Section~\ref{subsec:VDMNat}. 
  The translation strategy does define it following the same recipe:~recursive function precondition and filtering predicate 
  as assumptions, and chosen termination relation element containment, where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span> find the proof once more.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> l_pre_vdm_factorial_wf_rel<span class="main">:</span> <span class="quoted"><span class="quoted">"pre_vdm_factorial <span class="free">n</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="free">n</span><span class="main">)</span> <span class="main">∈</span> gen_VDMNat_term vdm_factorial_wf"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> gen_VDMNat_term_def gen_VDMInt_term_def
  <span class="keyword1"><span class="command">using</span></span> inv_VDMNat_def l_less_than_VDMNat_subset_int_ge_less_than pre_vdm_factorial_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We also choose to show the relation finite subset trick to
make well-founded induction proofs easier does not compromise the well founded relation itself.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> l_sumset_wf_rel_valid<span class="main">:</span> <span class="quoted"><span class="quoted">"gen_set_term sumset_wf_rel <span class="main">=</span> sumset_wf_rel"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> equalityI subsetI<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> l_pre_sumset_sumset_wf_rel <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, even though this was not necessary for this proof, we encourage users to always provide a witness for the top recursive call.
  This is done by using the \verb'@Witness' annotation~\cite{EdwardWitness,AdvancedVSCodePaper}:~it provides a concrete example for the function 
  input parameters. This witness is useful for existentially quantified predicates present in more involved termination proofs (see Section~\ref{subsec:Complex}).›</span></span>

<span class="comment1">(*-------------------------------------------------------------------------------------------------*)</span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Recursion over VDM maps\label{subsec:VDMMap}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Recursive functions over VDM maps are a special case of VDM sets, given map recursion usually 
iterates over the map's domain. For example, the function that sums the elements of the map range 
can be defined as  
%
\begin{vdmsl}[frame=noframe,basicstyle=\ttfamily\scriptsize]
  sum_elems: map nat to nat -&gt; nat
  sum_elems(m) == 
    if m = {|-&gt;} then 0 else
      let d in set dom m in m(d) + sum_elems({d}&lt;-:m)
  --@IsaMeasure( { ({d} &lt;-: m, m) | m : map nat to nat, d: nat &amp; m &lt;&gt; {} and d in set dom m } )
  --@Witness( sum_elems({ 1 |-&gt; 1 }) )
  measure card dom m;
\end{vdmsl}
%
\noindent As with sets, it iterates over the map by picking a domain element, performing the necessary 
computation, and then recurse on the map filtered by removing the chosen element, until the map is 
empty and the function terminates. As before, the measure relation follows the same pattern:~recursive call 
site related with defining site, where both the if-test and the \verb'let-in' choice is part of the filtering predicate.

Following the general translation strategy for maps~\cite{NimFull}, we define the function precondition using <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹inv_Map›</span></span></span></span>[display]
It insists that both the map domain and range are finite, and that all domain and range elements satisfy their corresponding type invariant. 
Note that if the recursion was defined over sets other than the domain and range, Isabelle might require you to prove such set is finite. 
Given both domain and range sets are themselves finite, this should be easy enough to do, if needed. 
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> 
  <span class="entity">pre_sum_elems</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span>VDMNat <span class="main">⇀</span> VDMNat<span class="main">)</span> <span class="main">⇒</span> <span class="main">𝔹</span>›</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‹<span class="free">pre_sum_elems</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">≡</span> inv_Map inv_VDMNat inv_VDMNat <span class="free"><span class="bound"><span class="entity">m</span></span></span>›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> pre_sum_elems_defs <span class="main">=</span> pre_sum_elems_def inv_Map_defs inv_VDMNat_def 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹VDM maps in Isabelle (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">(</span></span>VDMNat <span class="main"><span class="main">⇀</span></span> VDMNat<span class="main"><span class="main">)</span></span>›</span></span></span></span>) are defined as a HOL function which maps to an optional result. 
That is, if the element is in the domain, the map results in a non \texttt{\textbf{nil}} value, whereas if the element
does not belong to the domain, the map results in a \texttt{\textbf{nil}} value. This effectively makes all maps total,
where values outside the domain map to \texttt{\textbf{nil}}. The Isabelle translation and compatibility proof follows 
patterns used before and are given as›</span></span>
<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>domintros<span class="main">)</span> 
  <span class="entity">sum_elems</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span>VDMNat <span class="main">⇀</span> VDMNat<span class="main">)</span> <span class="main">⇒</span> VDMNat›</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‹<span class="free">sum_elems</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> 
      <span class="main">(</span><span class="keyword1">if</span> pre_sum_elems <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="keyword1">then</span>
          <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> Map.empty <span class="keyword1">then</span>
            <span class="main">0</span>
          <span class="keyword1">else</span>
            <span class="keyword1">let</span> <span class="bound">d</span> <span class="main">=</span> <span class="main">(</span><span class="main">ϵ</span> <span class="bound">e</span> <span class="main">.</span> <span class="bound">e</span> <span class="main">∈</span> dom <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="keyword1">in</span> the<span class="main">(</span><span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="bound">d</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">sum_elems</span> <span class="main">(</span><span class="main">{</span><span class="bound">d</span><span class="main">}</span> <span class="main">-◃</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span><span class="main">)</span>
          <span class="main">)</span>
       <span class="keyword1">else</span>
          undefined
      <span class="main">)</span>
  ›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">pat_completeness</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Similarly, the well-formed relation from \verb'@IsaMeasure' is translated next, where the precondition is also included 
as part of the relation's filter. The <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">{</span></span><span class="free"><span class="free">d</span></span><span class="main"><span class="main">}</span></span><span class="main"><span class="main">-◃</span></span><span class="free"><span class="free">m</span></span>›</span></span></span></span> corresponds to VDM domain anti-filtering operator \verb'&lt;-:'.›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">sum_elems_wf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="main">(</span>VDMNat <span class="main">⇀</span> VDMNat<span class="main">)</span> <span class="main">×</span> <span class="main">(</span>VDMNat <span class="main">⇀</span> VDMNat<span class="main">)</span><span class="main">)</span> VDMSet›</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">‹<span class="free">sum_elems_wf</span> <span class="main">≡</span> <span class="main">{</span> <span class="main">(</span><span class="main">(</span><span class="main">{</span><span class="bound">d</span><span class="main">}</span> <span class="main">-◃</span> <span class="bound">m</span><span class="main">)</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span> <span class="main">|</span> <span class="bound">m</span> <span class="bound">d</span> <span class="main">.</span> pre_sum_elems <span class="bound">m</span> <span class="main">∧</span> <span class="bound">m</span> <span class="main">≠</span> Map.empty <span class="main">∧</span> <span class="bound">d</span> <span class="main">∈</span> dom <span class="bound">m</span> <span class="main">}</span>›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For the well-formed lemma over the recursive measure relation, there are no available Isabelle help, 
and projecting the domain element of the maps within the relation is awkward. Thus, we have to prove the 
lemma directly. This will not be automatic in general. This is one difference in terms of translation of VDM 
recursive functions over sets and maps.

Fortunately, the proof strategy for such situations is somewhat known:~it follows a similar strategy to
the proof of well formedness of the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹finite_psubset›</span></span></span></span> as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> wf_finite_psubset<span class="antiquote"><span class="antiquote">}</span></span></span></span>[display]. The proof uses
the VDM measure expression to extract the right projection of interest, then follows the proof for <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹finite_psubset›</span></span></span></span>. 
Finally, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span> can figure out the final steps.   
›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> l_sum_elems_wf<span class="main">:</span> <span class="quoted"><span class="quoted">"wf sum_elems_wf"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> wf_measure<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">λ</span></span> <span class="bound"><span class="bound">m</span></span> <span class="main"><span class="main">.</span></span> card <span class="main"><span class="main">(</span></span>dom <span class="bound"><span class="bound">m</span></span><span class="main"><span class="main">)</span></span>›</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> wf_subset<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_def inv_image_def less_than_def less_eq<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> case_prod_beta<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> exE conjE<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_VDMMap_filtering_card pre_sum_elems_defs<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The precondition subgoal and the termination proof follow the same patterns as before. Again,
their proof was discovered with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> sledgehammer<span class="antiquote"><span class="antiquote">}</span></span></span></span>, yet this will not be the case in general.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> l_pre_sum_elems_sum_elems_wf<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"pre_sum_elems <span class="free">m</span> <span class="main">⟹</span> <span class="free">m</span> <span class="main">≠</span> Map.empty <span class="main">⟹</span> <span class="main">(</span><span class="main">{</span><span class="main">(</span><span class="main">ϵ</span> <span class="bound">e</span><span class="main">.</span> <span class="bound">e</span> <span class="main">∈</span> dom <span class="free">m</span><span class="main">)</span><span class="main">}</span> <span class="main">-◃</span> <span class="free">m</span><span class="main">,</span> <span class="free">m</span><span class="main">)</span> <span class="main">∈</span> sum_elems_wf"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_sum_elems_defs<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> domIff empty_iff some_in_eq<span class="main">)</span>

<span class="keyword1"><span class="command">termination</span></span>   
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> <span class="quoted">"termination"</span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> l_sum_elems_wf<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> l_pre_sum_elems_sum_elems_wf <span class="keyword1"><span class="command">by</span></span> <span class="operator">presburger</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, we also prove that the well founded termination relation (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹sum_elems_wf›</span></span></span></span>) is not 
empty, as we did for sets and \texttt{nat} recursion. Note that here the \verb'@Witness' annotation is 
useful in discharging the actual value to use as the witness demonstrating the relation is not empty.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> l_sum_elems_wf_valid<span class="main">:</span> <span class="quoted"><span class="quoted">"sum_elems_wf <span class="main">≠</span> <span class="main">{}</span>"</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> equalityE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subset_eq<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">‹<span class="main">[</span><span class="main">1</span> <span class="main">↦</span> <span class="main">1</span><span class="main">]</span>›</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> allE<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pre_sum_elems_defs<span class="main">)</span> 

<span class="comment1">(*-------------------------------------------------------------------------------------------------*)</span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹VDM recursion involving complex measures\label{subsec:Complex}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
\begin{vdmsl}[frame=noframe,basicstyle=\ttfamily\scriptsize]
    ack: nat * nat -&gt; nat 
    ack(m,n) ==
             if m = 0 then n+1
        else if n = 0 then ack(m-1, 1)
        else               ack(m-1, ack(m, (n-1)))
    --@IsaMeasure( pair_less_VDMNat )
    --@Witness( ack(2, 1) )
    measure is not yet specified;
\end{vdmsl}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The plugin has examples of a couple other more complicated recursion. These are Nipkow's 
permutation function~\cite{TermRewriting} and Takeuchi's 
function\footnote{\url{https://isabelle.in.tum.de/library/HOL/HOL-Examples/Functions.html}}.
%
\begin{vdmsl}[frame=noframe,basicstyle=\ttfamily\scriptsize]
    perm: int * int * int -&gt; int --nat
    perm(m,n,r) == 
             if 0 &lt; r then perm(m, r-1, n) 
        else if 0 &lt; n then perm(r, n-1, m) else m
    pre ((0 &lt; r or 0 &lt; n) =&gt; m+n+r &gt; 0)
    measure maxs({m+n+r, 0});      

    tak: int * int * int -&gt; int
    tak(x,y,z) == 
        if x &lt;= y then y  
        else           tak(tak(x-1,y,z), tak(y-1,z,x), tak(z-1,x,y))
    measure is not yet specified;
\end{vdmsl}
%
\noindent The Takeuchi's function is particularly challenging in proofs and the translation strategy 
stands no chance of finding proofs for such definitions automatically.›</span></span>

<span class="comment1">(**************************************************************************************************)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Limitations›</span></span>

<span class="comment1">(**************************************************************************************************)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Discussion and conclusion›</span></span>

<span class="keyword1"><span class="command">paragraph</span></span> <span class="quoted"><span class="plain_text">‹Future work.~›</span></span>


<span class="keyword1"><span class="command">lemma</span></span> l_sumset_rel_wf'<span class="main">:</span> <span class="quoted"><span class="quoted">"wf sumset_wf_rel"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> wf_measure<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">‹<span class="main"><span class="main">λ</span></span> <span class="bound"><span class="bound">s</span></span> <span class="main"><span class="main">.</span></span> card <span class="bound"><span class="bound">s</span></span>›</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> wf_subset<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_def inv_image_def less_than_def less_eq<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> case_prod_beta<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> exE conjE<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> card_Diff1_less_iff fst_conv inv_Map_defs<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> inv_Map_defs<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> pre_sumset_defs<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> snd_conv some_in_eq<span class="main">)</span>

<span class="keyword1"><span class="command">paragraph</span></span> <span class="quoted"><span class="plain_text">‹Acknowledgements.~›</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</body>

</html>