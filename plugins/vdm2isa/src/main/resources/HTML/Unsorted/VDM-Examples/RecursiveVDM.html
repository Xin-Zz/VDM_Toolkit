<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>Theory RecursiveVDM</title>
</head>


<body>
<div class="head">
<h1>Theory RecursiveVDM</h1>
</div>

<pre class="source"><span class="comment1"><span>(</span><span>*</span><span>&lt;</span><span>*</span><span>)</span></span><span>
</span><span class="comment1"><span>(</span><span>*</span><span>:maxLineLen=78:</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>theory</span></span></span><span> </span><span>RecursiveVDM</span><span>
</span><span class="keyword2"><span class="keyword"><span>imports</span></span></span><span> </span><a href="VDMToolkit.html"><span>VDMToolkit</span></a><span>
</span><span class="keyword2"><span class="keyword"><span>begin</span></span></span><span>
</span><span class="comment1"><span>(</span><span>*</span><span>&gt;</span><span>*</span><span>)</span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>************************************************************************************************</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>section</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Introduction\label{sec:Intro}</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>This paper describes a translation strategy for a variety of recursive 
</span><span>definitions from VDM to Isabelle/HOL. The strategy takes 
</span><span>into account the differences in how termination and well-foundedness 
</span><span>are represented in both formalisms. 
</span><span>
</span><span>Beyond overcoming technical practicalities, which we discuss, a major objective is to create
</span><span>translation strategy templates. These templates must cover a wide variety of VDM 
</span><span>recursive definitions, as well as having their proof obligations being highly automated.
</span><span>The result is an extension to a VDM to Isabelle/HOL translation strategy and implementation 
</span><span>as a plugin to VDMJ~</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>cite</span></span><span> </span><span>Battle09</span><span class="antiquote"><span>}</span></span></span><span> and extension to VDM-VSCode </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>cite</span></span><span> </span><span>AdvancedVSCodePaper</span><span class="antiquote"><span>}</span></span></span><span>.
</span><span>
</span><span>Isabelle uses literate programming, where formal specification, proofs and documentation are
</span><span>all within the same environment. We omit proofs scripts below; the full VDM and Isabelle sources 
</span><span>and proofs can be found at the VDM toolkit repository at
</span><span> </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπ./plugins/vdm2isa/src/main/resources/RecursiveVDM.*‚Ä∫</span></span></span><span class="antiquoted"><span class="operator"><span>‚Åã</span></span><span class="plain_text"><span>‚Äπ</span><span>in~</span><span class="antiquoted"><span class="operator"><span>üåê</span></span><span>‚Äπhttps://github.com/leouk/VDM_Toolkit‚Ä∫</span></span><span>‚Ä∫</span></span></span><span>.
</span><span>
</span><span>In the next section, we present background on VDM and Isabelle recursion and measure relations.
</span><span>In Section~\ref{sec:VDMTypes} we briefly discuss VDM basic types translation and their
</span><span>consequence for recursion. Next, Section~\ref{sec:Recursion} describes how both VDM
</span><span>and Isabelle recursive definitions work and how they differ. Our translation strategy
</span><span>is then presented in Section~\ref{sec:Strategy} for basic types, sets, maps, and 
</span><span>complex recursive patterns. Finally, we conclude in Section~\ref{sec:Conclusion}.</span><span> 
</span><span>‚Ä∫</span></span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>************************************************************************************************</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>section</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Background\label{sec:Background}</span><span>‚Ä∫</span></span></span><span> 

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>The VDM to Isabelle/HOL translator caters for a wide range of the VDM AST. It copes with all kinds 
</span><span>of expressions, a variety of patterns, almost all types, imports and exports, functions and specifications,
</span><span>traces, and some of state and operations. Even though not all kinds of VDM patterns are allowed,
</span><span>the translator copes with most, and where it does not, a corresponding equivalent is possible. Among the 
</span><span>expressions, map comprehension is of note, given its complexity. Details can be found at 
</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>cite</span></span><span> </span><span>NimFull</span><span> </span><span class="quasi_keyword"><span>and</span></span><span> </span><span>AdvancedVSCodePaper</span><span class="antiquote"><span>}</span></span></span><span>.
</span><span>
</span><span>One particular area we want to extend translation is over recursively defined functions. 
</span><span>VDM requires the user to define a measure function to justify why recursion will 
</span><span>terminate. It then generates proof obligations to ensure totality and termination. 
</span><span>
</span><span>Finally, our translation strategy follows the size-change termination (SCT) proof 
</span><span>strategy described in </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>cite</span></span><span> </span><span>SCT_POPL</span><span> </span><span class="quasi_keyword"><span>and</span></span><span> </span><span>SCNP_POPL</span><span class="antiquote"><span>}</span></span></span><span>. In particular, its SCP (polynomial) and SCNP (non-polynomial)
</span><span>subclass of recursive definitions within the SCT, which permits efficient termination certificate checking. 
</span><span>Effectively, if every infinite computation would give rise to an infinitely decreasing value sequence 
</span><span>(according to the size-change principle), then no infinite computation is possible. Termination problems in 
</span><span>this class have a global ranking function of a certain form, which can be found using SAT solving, hence 
</span><span>increasing automation.
</span><span>
</span><span class="antiquoted"><span class="operator"><span>‚ùô</span></span><span class="plain_text"><span>‚Äπ</span><span>ANYTHING ELSE? Related work?</span><span>‚Ä∫</span></span></span><span>
</span><span>‚Ä∫</span></span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>************************************************************************************************</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>section</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>VDM basic types in Isabelle\label{sec:VDMTypes}</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Isabelle represents natural numbers (</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñï</span></span><span>‚Ä∫</span></span></span><span>) as a (data) type with two constructors (</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>0</span></span><span class="main"><span>::</span></span><span class="main"><span>‚Ñï</span></span><span>‚Ä∫</span></span></span><span> and </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span>Suc</span><span> </span><span class="free"><span>n</span></span><span>‚Ä∫</span></span></span><span>), 
</span><span>  where all numbers are projections over such constructions (</span><span class="antiquoted"><span class="operator"><span>‚àó</span></span><span class="plain_text"><span>‚Äπ</span><span>e.g.</span><span>‚Ä∫</span></span></span><span>~</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>lemma</span></span><span> </span><span class="quoted"><span>"</span><span class="numeral"><span>3</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span>Suc</span><span> </span><span class="main"><span>(</span></span><span>Suc</span><span> </span><span class="main"><span>(</span></span><span>Suc</span><span> </span><span class="main"><span>0</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>"</span></span><span> </span><span class="quasi_keyword"><span>by</span></span><span> </span><span class="operator"><span>simp</span></span><span class="antiquote"><span>}</span></span></span><span>).   
</span><span>  Isabelle integers (</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñ§</span></span><span>‚Ä∫</span></span></span><span>) are defined as a quotient type involving two natural numbers. Isabelle quotient types are 
</span><span>  injections into a constructively defined type. Like with integers, other
</span><span>  Isabelle numeric types (</span><span class="antiquoted"><span class="operator"><span>‚àó</span></span><span class="plain_text"><span>‚Äπ</span><span>e.g.,</span><span>‚Ä∫</span></span></span><span>~rationals </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñö</span></span><span>‚Ä∫</span></span></span><span>, reals </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñù</span></span><span>‚Ä∫</span></span></span><span>, </span><span class="antiquoted"><span class="operator"><span>‚àó</span></span><span class="plain_text"><span>‚Äπ</span><span>etc</span><span>‚Ä∫</span></span></span><span>.) are defined in terms of some
</span><span>  involved natural number construction. Type conversions (or coercions) are then defined to allow users to jump
</span><span>  between type spaces. Nevertheless, Isabelle has no implicit type widening rule for </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñï</span></span><span>‚Ä∫</span></span></span><span>; instead, it takes 
</span><span>  conventions like </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>lemma</span></span><span>[</span><span>show_types</span><span>] </span><span class="quoted"><span>‚Äπ</span><span class="main"><span>(</span></span><span class="main"><span>0</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="free"><span>x</span></span><span class="main"><span>::</span></span><span class="main"><span>‚Ñï</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>0</span></span><span>‚Ä∫</span></span><span> </span><span class="quasi_keyword"><span>by</span></span><span> </span><span class="operator"><span>simp</span></span><span class="antiquote"><span>}</span></span></span><span>. For expressions involving 
</span><span>a mixutre of </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñ§</span></span><span>‚Ä∫</span></span></span><span> and </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñï</span></span><span>‚Ä∫</span></span></span><span> typed terms, explicit user-defined
</span><span>  type coercions are needed (</span><span class="antiquoted"><span class="operator"><span>‚àó</span></span><span class="plain_text"><span>‚Äπ</span><span>e.g.,</span><span>‚Ä∫</span></span></span><span>~</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>lemma</span></span><span>[</span><span>show_types</span><span>] </span><span class="quoted"><span>‚Äπ</span><span class="main"><span>(</span></span><span class="numeral"><span>2</span></span><span class="main"><span>::</span></span><span class="main"><span>‚Ñï</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>(</span></span><span class="numeral"><span>3</span></span><span class="main"><span>::</span></span><span class="main"><span>‚Ñ§</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>-</span></span><span class="main"><span>1</span></span><span>‚Ä∫</span></span><span> </span><span class="quasi_keyword"><span>by</span></span><span> </span><span class="operator"><span>simp</span></span><span class="antiquote"><span>}</span></span></span><span>).
</span><span> 
</span><span>   VDM expressions with basic-typed (</span><span class="antiquoted"><span class="operator"><span>‚ùô</span></span><span class="plain_text"><span>‚Äπ</span><span>nat</span><span>‚Ä∫</span></span></span><span>, </span><span class="antiquoted"><span class="operator"><span>‚ùô</span></span><span class="plain_text"><span>‚Äπ</span><span>int</span><span>‚Ä∫</span></span></span><span>) variables have specific type widening rules.
</span><span>  For example, even if both variables are </span><span class="antiquoted"><span class="operator"><span>‚ùô</span></span><span class="plain_text"><span>‚Äπ</span><span>nat</span><span>‚Ä∫</span></span></span><span>, the result might be </span><span class="antiquoted"><span class="operator"><span>‚ùô</span></span><span class="plain_text"><span>‚Äπ</span><span>int</span><span>‚Ä∫</span></span></span><span>. 
</span><span>(</span><span class="antiquoted"><span class="operator"><span>‚àó</span></span><span class="plain_text"><span>‚Äπ</span><span>e.g.,</span><span>‚Ä∫</span></span></span><span>~in VDM </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπ0 - x:nat = -x:int‚Ä∫</span></span></span><span>). Therefore, our translation 
</span><span>  strategy considers VDM </span><span class="antiquoted"><span class="operator"><span>‚ùô</span></span><span class="plain_text"><span>‚Äπ</span><span>nat</span><span>‚Ä∫</span></span></span><span> as the Isabelle type </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span>‚Ä∫</span></span></span><span>, which is just a type synonym for </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñ§</span></span><span>‚Ä∫</span></span></span><span>. This 
</span><span>  simplifies the translation process to Isabelle, such that no type coercions are necessary to encode all VDM type widenning rules. 
</span><span>  On the other hand, this design decision means encoding of recursive functions over </span><span class="antiquoted"><span class="operator"><span>‚ùô</span></span><span class="plain_text"><span>‚Äπ</span><span>nat</span><span>‚Ä∫</span></span></span><span> to be more complicated 
</span><span>  than expected, given VDM </span><span class="antiquoted"><span class="operator"><span>‚ùô</span></span><span class="plain_text"><span>‚Äπ</span><span>nat</span><span>‚Ä∫</span></span></span><span> is represented as Isabelle's </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñ§</span></span><span>‚Ä∫</span></span></span><span>.
</span><span>
</span><span>  Despite this design decision over basic types and their consequences, recursion
</span><span>over VDM </span><span class="antiquoted"><span class="operator"><span>‚ùô</span></span><span class="plain_text"><span>‚Äπ</span><span>int</span><span>‚Ä∫</span></span></span><span>, sets or maps will still be involved. That is because these types 
</span><span>are not constructively defined in Isabelle.</span><span>‚Ä∫</span></span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>************************************************************************************************</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>section</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Recursion in VDM and in Isabelle\label{sec:Recursion}</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Recursive definitions are pervasive in VDM models. 
</span><span>An important aspect of every recursive definition
</span><span>is an argument that justifies its termination. Otherwise, the recursion might go on 
</span><span>in an infinite loop.
</span><span>
</span><span>In VDM, this is defined using a recursive measure:~it has the same input type signature as
</span><span>the recursive definition, and returns a </span><span class="antiquoted"><span class="operator"><span>‚ùô</span></span><span class="plain_text"><span>‚Äπ</span><span>nat</span><span>‚Ä∫</span></span></span><span>, which </span><span class="antiquoted"><span class="operator"><span>‚ùô</span></span><span class="plain_text"><span>‚Äπ</span><span>must</span><span>‚Ä∫</span></span></span><span> monotonically decrease 
</span><span>at each recursive call, eventually reaching zero. This is how termination of recursive definitions 
</span><span>are justified in VDM. 
</span><span>
</span><span>A simple example of VDM recursive definition is one for calculating the factorial of a given natural number
</span><span>\begin{vdmsl}[frame=none,basicstyle=\ttfamily\scriptsize]
</span><span>   fact: nat -&gt; nat 
</span><span>   fact(n) == if n = 0 then 1 else n * fact(n - 1)   measure n;   
</span><span>\end{vdmsl} 
</span><span>%
</span><span>%   -- For the measure below, VDMJ produces a measure function as: 
</span><span>%   -- measure_fact: nat -&gt; nat
</span><span>%   -- measure_fact(n) == n
</span><span>\noindent The VDM recursive measure simply uses the </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπn‚Ä∫</span></span></span><span> input itself. This works because the only recursive 
</span><span>call is made with a decreasing value of </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπn‚Ä∫</span></span></span><span>, until it reaches </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπ0‚Ä∫</span></span></span><span> and terminates. VDMJ generates 
</span><span>three proof obligations for the definition above.
</span><span>%
</span><span>\begin{vdmsl}[frame=none,basicstyle=\ttfamily\scriptsize]
</span><span>Proof Obligation 1: (Unproved)
</span><span>fact; measure_fact: total function obligation at line 10:12
</span><span>(forall n:nat &amp; is_(measure_fact(n), nat))
</span><span>
</span><span>Proof Obligation 2: (Unproved) fact: subtype obligation at line 6:57
</span><span>(forall n:nat &amp; (not (n = 0) =&gt; (n - 1) &gt;= 0))
</span><span>
</span><span>Proof Obligation 3: (Unproved) fact: recursive function obligation at line 5:4
</span><span>(forall n:nat &amp; (not (n=0) =&gt; measure_fact(n) &gt; measure_fact((n-1))))
</span><span>\end{vdmsl} 
</span><span>%
</span><span>\noindent They are trivial to discharge in Isabelle given the measure definition expanded is just 
</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>lemma</span></span><span> </span><span class="quoted"><span>‚Äπ</span><span class="main"><span>(</span></span><span class="main"><span>‚àÄ</span></span><span> </span><span class="bound"><span>n</span></span><span class="main"><span>::</span></span><span class="main"><span>‚Ñï</span></span><span> </span><span class="main"><span>.</span></span><span> </span><span class="main"><span>¬¨</span></span><span> </span><span class="bound"><span>n</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="main"><span>‚ü∂</span></span><span> </span><span class="bound"><span>n</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>1</span></span><span> </span><span class="main"><span>‚â•</span></span><span> </span><span class="main"><span>0</span></span><span class="main"><span>)</span></span><span>‚Ä∫</span></span><span> </span><span class="quasi_keyword"><span>by</span></span><span> </span><span class="operator"><span>simp</span></span><span class="antiquote"><span>}</span></span></span><span> and 
</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>lemma</span></span><span> </span><span class="quoted"><span>‚Äπ</span><span class="main"><span>(</span></span><span class="main"><span>‚àÄ</span></span><span> </span><span class="bound"><span>n</span></span><span class="main"><span>::</span></span><span class="main"><span>‚Ñï</span></span><span> </span><span class="main"><span>.</span></span><span> </span><span class="main"><span>¬¨</span></span><span> </span><span class="bound"><span>n</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="main"><span>‚ü∂</span></span><span> </span><span class="bound"><span>n</span></span><span> </span><span class="main"><span>&gt;</span></span><span> </span><span class="bound"><span>n</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span>‚Ä∫</span></span><span> </span><span class="quasi_keyword"><span>by</span></span><span> </span><span class="operator"><span>simp</span></span><span class="antiquote"><span>}</span></span></span><span>.
</span><span>
</span><span>Moreover, even though measures over recursive type structures are impossible to define in VDM, they are 
</span><span>easily described in Isabelle. For example, it is not possible to write a measure in VDM for a 
</span><span>recursive function over a recursive record defining a linked list, such as </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚ÄπR :: v: nat n: R‚Ä∫</span></span></span><span>. 
</span><span>This is automatically generated for our representation of VDM records in Isabelle as a datatype.
</span><span>Other complex recursive patterns are hard/impossible to represent in VDM (see Section~\ref{subsec:Complex}).   
</span><span>  
</span><span>In Isabelle, recursive definitions can be provided through primitive recursion over inputs are 
</span><span>constructively defined, or more general function definitions that produces proof obligations. 
</span><span>The former insists on definition for each type constructor and only provides simplification rules; whereas
</span><span>the latter allow for more sophisticated input patterns and provides simplification, elimination and 
</span><span>induction rules, as well as partial function considerations. For the purposes of this paper, we only 
</span><span>consider function definitions. Readers can find more about these differences in~</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>cite</span></span><span> </span><span>IsaFunctionPackage</span><span class="antiquote"><span>}</span></span></span><span>. 
</span><span>
</span><span>Isabelle recursive functions requires a proof obligation that parameters represent a constructive and 
</span><span>compatible pattern, and that recursive calls terminate. Constructive patterns relates to all constructors 
</span><span>in data type being used in the recursion inputs (</span><span class="antiquoted"><span class="operator"><span>‚àó</span></span><span class="plain_text"><span>‚Äπ</span><span>e.g.,</span><span>‚Ä∫</span></span></span><span>~one equation for each of the constructors of </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñï</span></span><span>‚Ä∫</span></span></span><span>, 
</span><span>hence one involving </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>0</span></span><span class="main"><span>::</span></span><span class="main"><span>‚Ñï</span></span><span>‚Ä∫</span></span></span><span> and another involving </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span>Suc</span><span> </span><span class="free"><span>n</span></span><span>‚Ä∫</span></span></span><span>). Compatible patterns relates to multiple ways 
</span><span>patterns can be constructed will boil down to the pattern completeness cases (</span><span class="antiquoted"><span class="operator"><span>‚àó</span></span><span class="plain_text"><span>‚Äπ</span><span>e.g.,</span><span>‚Ä∫</span></span></span><span>~</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="free"><span>n</span></span><span> </span><span class="main"><span>+</span></span><span> </span><span class="numeral"><span>2</span></span><span class="main"><span>::</span></span><span class="main"><span>‚Ñï</span></span><span>‚Ä∫</span></span></span><span> being 
</span><span>simply multiple calls over defined constructors like </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span>Suc</span><span> </span><span class="main"><span>(</span></span><span>Suc</span><span> </span><span class="free"><span>n</span></span><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span>). This is important to ensure that recursion 
</span><span>is well structured (</span><span class="antiquoted"><span class="operator"><span>‚àó</span></span><span class="plain_text"><span>‚Äπ</span><span>i.e.,</span><span>‚Ä∫</span></span></span><span>~recursive calls will not get stuck because some constructs are not available). 
</span><span>For example, if you miss the </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>0</span></span><span class="main"><span>::</span></span><span class="main"><span>‚Ñï</span></span><span>‚Ä∫</span></span></span><span> case, eventually the </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span>Suc</span><span> </span><span class="free"><span>n</span></span><span>‚Ä∫</span></span></span><span> case will reach zero and fail, as no patterns for zero exist. 
</span><span>The proof obligation for termination establishes that the recursion is well-founded. This has to be proved whenever 
</span><span>properties of the defined function are meant to be total. 
</span><span>
</span><span>Isabelle function definitions can be given with either </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="free"><span>fun</span></span><span>‚Ä∫</span></span></span><span> or </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="free"><span>function</span></span><span>‚Ä∫</span></span></span><span> syntax. The
</span><span>former attempts to automatically prove the pattern constructive and compatible proofs and finds a measure 
</span><span>for the termination proof obligation. The latter requires the user to do these proofs manually 
</span><span>by providing a measure relation. It is better suited for cases where </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="free"><span>fun</span></span><span>‚Ä∫</span></span></span><span> declarations fail, 
</span><span>which usually involve complex or ill-defined recursion. 
</span><span>
</span><span>The termination relation must be well-formed, which means have a
</span><span>well-ordered induction principle over a partially ordered relation defined as</span><span class="antiquoted"><span class="operator"><span>‚Åã</span></span><span class="plain_text"><span>‚Äπ</span><span>For 
</span><span>details on what well-ordered induction means in Isabelle, see the </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">class</span><span class="hidden">&gt;</span></span></span><span>‚Äπ</span><span>wellorder</span><span>‚Ä∫</span></span><span> theorem </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><span>wf</span><span class="antiquote"><span>}</span></span></span><span> in 
</span><span>theory </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚ÄπWellfounded.thy‚Ä∫</span></span></span><span> within Isabelle's distribution.</span><span>‚Ä∫</span></span></span><span>
</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span>[</span><span>display</span><span>,</span><span>show_types</span><span>] </span><span>wf_def</span><span class="antiquote"><span>}</span></span></span><span>. 
</span><span>For example, an Isabelle definition of factorial that it automatically discovers all three proofs can be given as</span><span>‚Ä∫</span></span></span><span>
</span><span class="comment1"><span>(</span><span>*</span><span>
find_theorems name:wellorder
print_locale! wellorder </span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.fact&apos;.elims|fact"><span class="entity_def" id="RecursiveVDM.fact&apos;.induct|fact"><span class="entity_def" id="RecursiveVDM.fact&apos;.simps|fact"><span class="entity_def" id="RecursiveVDM.fact&apos;.pelims|fact"><span class="entity_def" id="RecursiveVDM.fact&apos;.cases|fact"><span class="entity_def" id="RecursiveVDM.fact&apos;.termination|fact"><span class="entity_def" id="RecursiveVDM.fact&apos;.pinduct|fact"><span class="entity_def" id="RecursiveVDM.fact&apos;.psimps|fact"><span class="entity_def" id="RecursiveVDM.fact&apos;_rel.inducts|fact"><span class="entity_def" id="RecursiveVDM.fact&apos;_rel.simps|fact"><span class="entity_def" id="RecursiveVDM.fact&apos;_rel.induct|fact"><span class="entity_def" id="RecursiveVDM.fact&apos;_rel.cases|fact"><span class="entity_def" id="RecursiveVDM.fact&apos;_rel.intros|fact"><span class="entity_def" id="RecursiveVDM.fact&apos;_graph.inducts|fact"><span class="entity_def" id="RecursiveVDM.fact&apos;_graph.simps|fact"><span class="entity_def" id="RecursiveVDM.fact&apos;_graph.induct|fact"><span class="entity_def" id="RecursiveVDM.fact&apos;_graph.cases|fact"><span class="entity_def" id="RecursiveVDM.fact&apos;_graph.intros|fact"><span class="entity_def" id="RecursiveVDM.fact&apos;.elims|thm"><span class="entity_def" id="RecursiveVDM.fact&apos;.induct|thm"><span class="entity_def" id="RecursiveVDM.fact&apos;.simps|thm"><span class="entity_def" id="RecursiveVDM.fact&apos;.pelims|thm"><span class="entity_def" id="RecursiveVDM.fact&apos;.cases|thm"><span class="entity_def" id="RecursiveVDM.fact&apos;.termination|thm"><span class="entity_def" id="RecursiveVDM.fact&apos;.pinduct|thm"><span class="entity_def" id="RecursiveVDM.fact&apos;.psimps|thm"><span class="entity_def" id="RecursiveVDM.fact&apos;_rel.inducts|thm"><span class="entity_def" id="RecursiveVDM.fact&apos;_rel.simps|thm"><span class="entity_def" id="RecursiveVDM.fact&apos;_rel.induct|thm"><span class="entity_def" id="RecursiveVDM.fact&apos;_rel.cases|thm"><span class="entity_def" id="RecursiveVDM.fact&apos;_rel.intros|thm"><span class="entity_def" id="RecursiveVDM.fact&apos;_graph.inducts|thm"><span class="entity_def" id="RecursiveVDM.fact&apos;_graph.simps|thm"><span class="entity_def" id="RecursiveVDM.fact&apos;_graph.induct|thm"><span class="entity_def" id="RecursiveVDM.fact&apos;_graph.cases|thm"><span class="entity_def" id="RecursiveVDM.fact&apos;_graph.intros|thm"><span class="entity_def" id="RecursiveVDM.fact&apos;_def|axiom"><span class="entity_def" id="RecursiveVDM.fact&apos;_rel_def|axiom"><span class="entity_def" id="RecursiveVDM.fact&apos;_sumC_def|axiom"><span class="entity_def" id="RecursiveVDM.fact&apos;_graph_def|axiom"><span class="entity_def" id="RecursiveVDM.fact&apos;_dom|const"><span class="entity_def" id="RecursiveVDM.fact&apos;_rel|const"><span class="entity_def" id="RecursiveVDM.fact&apos;_sumC|const"><span class="entity_def" id="RecursiveVDM.fact&apos;_graph|const"><span>fun</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.fact&apos;|const"><span>fact'</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñï</span></span><span> </span><span class="main"><span>‚áí</span></span><span> </span><span class="main"><span>‚Ñï</span></span><span>‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>fact'</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>if</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span class="main"><span>1</span></span><span> </span><span class="keyword1"><span>else</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>*</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>fact'</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span> 
</span><span class="comment1"><span>(</span><span>*</span><span>
fun 
  fact'' :: ‚Äπ‚Ñ§ ‚áí ‚Ñ§‚Ä∫
  where 
  "fact'' n = (if n = 0 then 1 else n * (fact'' (n - 1)))" 

function 
  fact''' :: ‚Äπ‚Ñ§ ‚áí ‚Ñ§‚Ä∫
  where 
  "fact''' n = (if n = 0 then 1 else n * (fact''' (n - 1)))" 
  by (pat_completeness, auto)
termination 
  sledgehammer
</span><span>*</span><span>)</span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>This Isabelle definition is pretty much 1-1 with the VDM definition. 
</span><span>Nevertheless, as mentioned above, VDM basic types widening rules 
</span><span>necessitated we translate them to </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span>‚Ä∫</span></span></span><span>, which is just </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñ§</span></span><span>‚Ä∫</span></span></span><span>. 
</span><span>The same version of </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span>fact</span><span>‚Ä∫</span></span></span><span> defined for </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñ§</span></span><span>‚Ä∫</span></span></span><span> will fail with 
</span><span>the error that ``</span><span class="antiquoted"><span class="operator"><span>‚àó</span></span><span class="plain_text"><span>‚Äπ</span><span>Could not find lexicographic termination order</span><span>‚Ä∫</span></span></span><span>''. That is, 
</span><span>Isabelle manages to discharge the pattern proofs for </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñ§</span></span><span>‚Ä∫</span></span></span><span>, but not the termination one. 
</span><span>This is because the user must provide a projection relation from the </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñ§</span></span><span>‚Ä∫</span></span></span><span> 
</span><span>quotient type back into the constructive type </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñï</span></span><span>‚Ä∫</span></span></span><span>.
</span><span>
</span><span>Even if we could avoid these VDM basic types translation technicality, 
</span><span>the same problem would occur for VDM recursion over non constructive types, 
</span><span>such as sets or maps. That is, Isabelle only allow recursion over finite sets, 
</span><span>which are not defined constructively but inductively. 
</span><span>Similarly, Isabelle maps are defined with specialised HOL functions, 
</span><span>again with domains that are not constructively defined. The only easy 
</span><span>recursive definition translation from VDM to Isabelle are those
</span><span>involving lists, given lists in Isabelle are defined constructively and VDM 
</span><span>sequences maps directly to them.      
</span><span>
</span><span>Therefore, defining recursive functions over non-constructive types entail 
</span><span>more involved compatibility and completeness proofs.
</span><span>They also usually lead to partial function definitions, given Isabelle cannot 
</span><span>tell whether termination is immediately obvious. 
</span><span>In VDM, however, recursive functions on sets (as well as map domains) are common, 
</span><span>hence the need for extending our translation strategy.</span><span>‚Ä∫</span></span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>************************************************************************************************</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>section</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>VDM recursion translation strategy\label{sec:Strategy}</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>We want to identify a translation strategy that will cater for such issues described above not only 
</span><span>for basic types, but also for sets, sequences, maps, </span><span class="antiquoted"><span class="operator"><span>‚àó</span></span><span class="plain_text"><span>‚Äπ</span><span>etc</span><span>‚Ä∫</span></span></span><span>. This is important to ensure that the
</span><span>translator will cater for most commonly used VDM recursion definition patterns.   
</span><span>
</span><span>As mentioned in~</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>cite</span></span><span> </span><span>VDMJAnnotations</span><span> </span><span class="quasi_keyword"><span>and</span></span><span> </span><span>AdvancedVSCodePaper</span><span class="antiquote"><span>}</span></span></span><span>, it is possible to define formal annotations 
</span><span>(as comments), which VDMJ will process and make available for its plugins. For our translation
</span><span>strategy, we create a new annotation called </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπ@IsaMeasure‚Ä∫</span></span></span><span>. It defines a user-provided well-founded 
</span><span>measure relation that will participate in the Isabelle proofs of termination. For example, for the 
</span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπfact‚Ä∫</span></span></span><span> function above, the user would have to write an annotation before the VDM measure as
</span><span>%
</span><span>\begin{vdmsl}[frame=none,basicstyle=\ttfamily\scriptsize]
</span><span>  --@IsaMeasure( { (n -1, n) | n : nat &amp; n &lt;&gt; 0 } )
</span><span>\end{vdmsl}
</span><span>%
</span><span>\noindent This measure relation corresponds to the relationship between the recursive 
</span><span>call (</span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπfact(n-1)‚Ä∫</span></span></span><span>) and its defining equation (</span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπfact(n)‚Ä∫</span></span></span><span>), where the 
</span><span>filtering condition determines for which values of </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπn‚Ä∫</span></span></span><span>
</span><span>should the relation refer to (</span><span class="antiquoted"><span class="operator"><span>‚àó</span></span><span class="plain_text"><span>‚Äπ</span><span>e.g.,</span><span>‚Ä∫</span></span></span><span>~non-zero values). More interesting measure 
</span><span>relation examples are defined in Section~\ref{subsec:Complex}.  
</span><span>
</span><span>During translation, the plugin will typecheck the </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπ@IsaMeasure‚Ä∫</span></span></span><span> annotation 
</span><span>(</span><span class="antiquoted"><span class="operator"><span>‚àó</span></span><span class="plain_text"><span>‚Äπ</span><span>i.e.,</span><span>‚Ä∫</span></span></span><span>~it is a type correct relation over the function signature).
</span><span>Next, it will translate the annotation and some automation lemmas as series of 
</span><span>Isabelle definitions to be used during the proof
</span><span>of termination of translated VDM recursive functions. If no annotation is provided, 
</span><span>following similar principles from Isabelle, then the plugin will try to automatically 
</span><span>infer what the measure relation should be based on the structure of the recursive 
</span><span>function definition. When this fails, then the user is informed. Still, even if
</span><span> measure-relation synthesis succeeds, the user still have to appropriately use it 
</span><span>during Isabelle's termination proof. 
</span><span>
</span><span>In what follows, we will detail the translation strategy for each relevant VDM type. 
</span><span>For details over the overall translation strategy, see examples in the 
</span><span>distribution</span><span class="antiquoted"><span class="operator"><span>‚Åã</span></span><span class="plain_text"><span>‚Äπ</span><span class="antiquoted"><span class="operator"><span>üåê</span></span><span>‚Äπhttps://github.com/leouk/VDM_Toolkit‚Ä∫</span></span><span>‚Ä∫</span></span></span><span> and~</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>cite</span></span><span> </span><span>NimFull</span><span class="antiquote"><span>}</span></span></span><span>. That 
</span><span>is, we impose various implicit VDM checks as explicit predicates. For example, VDM 
</span><span>sets are always finite, and type invariants over set elements must hold for every element.</span><span>‚Ä∫</span></span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>-------------------------------------------------------------------------------------------------</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Recursion over VDM basic types (</span><span class="antiquoted"><span class="operator"><span>‚ùô</span></span><span class="plain_text"><span>‚Äπ</span><span>nat</span><span>‚Ä∫</span></span></span><span>, </span><span class="antiquoted"><span class="operator"><span>‚ùô</span></span><span class="plain_text"><span>‚Äπ</span><span>int</span><span>‚Ä∫</span></span></span><span>)\label{subsec:VDMNat}</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Following the general translation strategy~</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>cite</span></span><span> </span><span>NimFull</span><span class="antiquote"><span>}</span></span></span><span>, we first encode the implicit precondition of 
</span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπfact‚Ä∫</span></span></span><span>, which insists that the given parameter </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="free"><span>n</span></span><span>‚Ä∫</span></span></span><span> is a </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span>‚Ä∫</span></span></span><span>, alongside a list of defining constants 
</span><span>that are useful for proof strategy synthesis.</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.pre_fact_def|fact"><span class="entity_def" id="RecursiveVDM.pre_fact_def|thm"><span class="entity_def" id="RecursiveVDM.pre_fact_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.pre_fact|const"><span>pre_fact</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><span class="main"><span>ùîπ</span></span><span>‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>pre_fact</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>‚â°</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMNat|const"><span>inv_VDMNat</span></a><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemmas</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.pre_fact_defs|fact"><span class="entity_def" id="RecursiveVDM.pre_fact_defs(2)|thm"><span class="entity_def" id="RecursiveVDM.pre_fact_defs(1)|thm"><span>pre_fact_defs</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_fact_def|fact"><span>pre_fact_def</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMNat_def|fact"><span>inv_VDMNat_def</span></a><span> 

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Next, we define the </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπfact‚Ä∫</span></span></span><span> recursively. When the precondition fails, 
</span><span>  we return </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span>undefined</span><span>‚Ä∫</span></span></span><span>, which is a term that cannot be reasoned with in Isabelle (</span><span class="antiquoted"><span class="operator"><span>‚àó</span></span><span class="plain_text"><span>‚Äπ</span><span>i.e.,</span><span>‚Ä∫</span></span></span><span>~it is a dead end).
</span><span>
</span><span>The </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="free"><span>domintros</span></span><span>‚Ä∫</span></span></span><span> tag tells Isabelle to generate domain predicates, in case this function is not total. 
</span><span>Domain predicates are important to our strategy because every VDM function will be undefined, when
</span><span>applied outside its precondition. It also generates domain-predicate sensitive proof rules listed below.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.fact.domintros|fact"><span class="entity_def" id="RecursiveVDM.fact.pelims|fact"><span class="entity_def" id="RecursiveVDM.fact.cases|fact"><span class="entity_def" id="RecursiveVDM.fact.termination|fact"><span class="entity_def" id="RecursiveVDM.fact.pinduct|fact"><span class="entity_def" id="RecursiveVDM.fact.psimps|fact"><span class="entity_def" id="RecursiveVDM.fact_rel.inducts|fact"><span class="entity_def" id="RecursiveVDM.fact_rel.simps|fact"><span class="entity_def" id="RecursiveVDM.fact_rel.induct|fact"><span class="entity_def" id="RecursiveVDM.fact_rel.cases|fact"><span class="entity_def" id="RecursiveVDM.fact_rel.intros|fact"><span class="entity_def" id="RecursiveVDM.fact_graph.inducts|fact"><span class="entity_def" id="RecursiveVDM.fact_graph.simps|fact"><span class="entity_def" id="RecursiveVDM.fact_graph.induct|fact"><span class="entity_def" id="RecursiveVDM.fact_graph.cases|fact"><span class="entity_def" id="RecursiveVDM.fact_graph.intros|fact"><span class="entity_def" id="RecursiveVDM.fact.domintros|thm"><span class="entity_def" id="RecursiveVDM.fact.pelims|thm"><span class="entity_def" id="RecursiveVDM.fact.cases|thm"><span class="entity_def" id="RecursiveVDM.fact.termination|thm"><span class="entity_def" id="RecursiveVDM.fact.pinduct|thm"><span class="entity_def" id="RecursiveVDM.fact.psimps|thm"><span class="entity_def" id="RecursiveVDM.fact_rel.inducts|thm"><span class="entity_def" id="RecursiveVDM.fact_rel.simps|thm"><span class="entity_def" id="RecursiveVDM.fact_rel.induct|thm"><span class="entity_def" id="RecursiveVDM.fact_rel.cases|thm"><span class="entity_def" id="RecursiveVDM.fact_rel.intros|thm"><span class="entity_def" id="RecursiveVDM.fact_graph.inducts|thm"><span class="entity_def" id="RecursiveVDM.fact_graph.simps|thm"><span class="entity_def" id="RecursiveVDM.fact_graph.induct|thm"><span class="entity_def" id="RecursiveVDM.fact_graph.cases|thm"><span class="entity_def" id="RecursiveVDM.fact_graph.intros|thm"><span class="entity_def" id="RecursiveVDM.fact_def|axiom"><span class="entity_def" id="RecursiveVDM.fact_rel_def|axiom"><span class="entity_def" id="RecursiveVDM.fact_sumC_def|axiom"><span class="entity_def" id="RecursiveVDM.fact_graph_def|axiom"><span class="entity_def" id="RecursiveVDM.fact_dom|const"><span class="entity_def" id="RecursiveVDM.fact_rel|const"><span class="entity_def" id="RecursiveVDM.fact_sumC|const"><span class="entity_def" id="RecursiveVDM.fact_graph|const"><span>function</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span>domintros</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.fact|const"><span>fact</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span>‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>fact</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>if</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_fact|const"><span>pre_fact</span></a><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>if</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span class="main"><span>1</span></span><span> </span><span class="keyword1"><span>else</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>*</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>fact</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
                </span><span class="keyword1"><span>else</span></span><span> </span><span>undefined</span><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span>

  </span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>The proof obligations for pattern compatibility and completeness are next.
</span><span> They are discharged with the usual Isabelle proof strategy for simple recursive patterns with the </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>method</span></span><span> </span><span>pat_completeness</span><span class="antiquote"><span>}</span></span></span><span> method.
</span><span>  In the general case discussed in Section~\ref{subsec:Complex}), 
</span><span>  the user might have goals to discharge.</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>pat_completeness</span></span><span class="main"><span class="keyword3"><span>,</span></span></span><span> </span><span class="operator"><span>auto</span></span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Various theorems are made available, such as: case analysis; and (partial) rules
</span><span>for elimination, induction and simplification.
</span><span>%Case analysis </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.fact.cases|fact"><span>fact.cases</span></a><span class="antiquote"><span>}</span></span></span><span>
</span><span>%Elimination rules (partial) </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.fact.pelims|fact"><span>fact.pelims</span></a><span class="antiquote"><span>}</span></span></span><span>
</span><span>%Induction rules (partial) </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.fact.pinduct|fact"><span>fact.pinduct</span></a><span class="antiquote"><span>}</span></span></span><span>
</span><span>%Simplification rules (partial) </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.fact.psimps|fact"><span>fact.psimps</span></a><span class="antiquote"><span>}</span></span></span><span>
</span><span>
</span><span>Note the last two are partial, module the domain predicate </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.fact_dom|const"><span>fact_dom</span></a></span><span class="antiquote"><span>}</span></span></span><span>,
</span><span>which represents a well-founded relation that ensures termination. That is, if the user does not want
</span><span>(or knows how) to prove termination, such domain predicates will follow every application of the 
</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.fact|const"><span>fact</span></a><span>‚Ä∫</span></span></span><span> definition, hence imposing users the requirement that such well-founded relation is still missing.
</span><span>
</span><span>If/when the termination proof is discharged, these p-rules can be simplified into total rules that 
</span><span>do not depend on a domain predicate, given a well-founded relation has been provided. Domain predicates
</span><span>will complicate user proofs, and also make proof strategy synthesis harder to automate.
</span><span>
</span><span>Termination proof is discharged by establishing a well-founded relation associated with 
</span><span>the function recursive call(s) with respect to its declaration. In our case, the </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπ@IsaMeasure‚Ä∫</span></span></span><span>
</span><span>annotation is translated as an Isabelle abbreviation. We also implicitly add the filter that the 
</span><span>function precondition holds:~this is important to ensure the termination proof never reaches the </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span>undefined</span><span>‚Ä∫</span></span></span><span> case.  
</span><span>The other filter comes from the negated test in the definition if-statement. More complex definitions will
</span><span>have more involved filters. 
</span><span>We use abbreviation instead of definition to avoid needing to expand the defined term.</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>abbreviation</span></span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.fact_wf|const"><span>fact_wf</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><span class="main"><span>√ó</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span class="main"><span>)</span></span><span> </span><span>set</span><span>‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>fact_wf</span></span><span> </span><span class="main"><span>‚â°</span></span><span> </span><span class="main"><span>{</span></span><span> </span><span class="main"><span>(</span></span><span class="bound"><span>n</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>1</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>n</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>|</span></span><span> </span><span class="bound"><span>n</span></span><span> </span><span class="main"><span>.</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_fact|const"><span>pre_fact</span></a><span> </span><span class="bound"><span>n</span></span><span> </span><span class="main"><span>‚àß</span></span><span> </span><span class="bound"><span>n</span></span><span> </span><span class="main"><span>‚â†</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="main"><span>}</span></span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Given </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.fact|const"><span>fact</span></a><span>‚Ä∫</span></span></span><span> is a simple (non-mutual, single call-site, easy measure relation choice) recursion, 
</span><span>  thankfully the setup is not as complex to establish well-foundedness. For recursions of this nature, we can 
</span><span>  piggyback on some Isabelle machinery to help prove well foundedness by using the terms </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_VDMNat_term|const"><span>gen_VDMNat_term</span></a></span><span class="antiquote"><span>}</span></span></span><span> and
</span><span>  </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span>int_ge_less_than</span></span><span class="antiquote"><span>}</span></span></span><span>.
</span><span>
</span><span>  The first term is defined in terms of the second, which is a subset of our well-formed relation </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.fact_wf|const"><span>fact_wf</span></a><span>‚Ä∫</span></span></span><span>. 
</span><span>  Isabelle has proofs about the term's well formedness of </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span>int_ge_less_than</span><span>‚Ä∫</span></span></span><span>.
</span><span>  Thus, making the proof our term being well-founded trivial, and easily discovered with proof tools like
</span><span>  </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command</span></span><span> </span><span>sledgehammer</span><span class="antiquote"><span>}</span></span></span><span>. As part of the translation strategy, we then define (and automatically discover the proof of)
</span><span>  the following lemma. This follows the strategy described in~</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>cite</span></span><span> </span><span>KrausSCNP</span><span class="antiquote"><span>}</span></span></span><span>. 
</span><span>    %\url{https://www21.in.tum.de/~krauss/papers/scnp-wst.pdf}.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_fact_term_wf|fact"><span class="entity_def" id="RecursiveVDM.l_fact_term_wf|thm"><span>l_fact_term_wf</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span>wf</span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_VDMNat_term|const"><span>gen_VDMNat_term</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.fact_wf|const"><span>fact_wf</span></a><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>wf_int_ge_less_than</span><span> </span><span>wf_Int1</span><span class="main"><span>)</span></span><span> 

</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.fact.elims|fact"><span class="entity_def" id="RecursiveVDM.fact.induct|fact"><span class="entity_def" id="RecursiveVDM.fact.simps|fact"><span class="entity_def" id="RecursiveVDM.fact.elims|thm"><span class="entity_def" id="RecursiveVDM.fact.induct|thm"><span class="entity_def" id="RecursiveVDM.fact.simps|thm"><span>termination</span></span></span></span></span></span></span></span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Finally, we prove termination using the previously proved lemma using the </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>method</span></span><span> </span><span>relation</span><span class="antiquote"><span>}</span></span></span><span>.
</span><span>  This simplifies the goal into well-formedness of termination relation and that the precondition implies it,
</span><span>  both of which are easily proved with simplification in this case.</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>relation</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_VDMNat_term|const"><span>gen_VDMNat_term</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.fact_wf|const"><span>fact_wf</span></a><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>This transforms the abstract domain predicate into two new subgoals as </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>subgoals</span></span><span>[</span><span>display</span><span>]</span><span class="antiquote"><span>}</span></span></span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.l_fact_term_wf|fact"><span>l_fact_term_wf</span></a><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="operator"><span>presburger</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_fact_defs|fact"><span>pre_fact_defs</span></a><span> </span><span>int_ge_less_than_def</span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>For this simple example, these subgoals are proved with </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command</span></span><span> </span><span>sledgehammer</span><span class="antiquote"><span>}</span></span></span><span>. In general, the user will be
</span><span>  have to either find the proof, or deal with domain predicates in proofs involving the recursive call.
</span><span> After the termination proof is discharged, Isabelle provides versions of rules 
</span><span>for elimination, induction and simplification that are total and do not depend on 
</span><span>the abstract domain predicate.</span><span> 
</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>To make sure our choice does not lead to the empty relation, we ensure
</span><span>  that indeed the termination relation is in fact the same as the well founded predicate by proving the next goal.
</span><span>  This is something users might want to do, but is not part of the translation strategy. In case the measure relation 
</span><span>  is empty, the recursive call simplification rules will not be useful anyhow.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_fact_term_valid|fact"><span class="entity_def" id="RecursiveVDM.l_fact_term_valid|thm"><span>l_fact_term_valid</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_VDMNat_term|const"><span>gen_VDMNat_term</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.fact_wf|const"><span>fact_wf</span></a><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.fact_wf|const"><span>fact_wf</span></a><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_fact_defs|fact"><span>pre_fact_defs</span></a><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>intro</span></span><span> </span><span>equalityI</span><span> </span><span>subsetI</span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp_all</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>int_ge_less_than_def</span><span> </span><span>case_prod_beta</span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>auto</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>-------------------------------------------------------------------------------------------------</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Recursion over VDM sets\label{subsec:VDMSet}</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Next, we extend the translation strategy for basic types for VDM sets. For this, we will use a 
</span><span> recursively defined VDM function over sets that sums the set elements as
</span><span>%
</span><span>\begin{vdmsl}[frame=none,basicstyle=\ttfamily\scriptsize]
</span><span>  sumset: set of nat -&gt; nat 
</span><span>  sumset(s) == if s = {} then 0 else let e in set s in sumset(s - {e}) + e
</span><span>  --@IsaMeasure({(x - { let e in set x in e }, x) | x : set of nat &amp; x &lt;&gt; {}}) 
</span><span>  --@Witness(sumset({ 1 }))
</span><span>  measure card s;
</span><span>\end{vdmsl}
</span><span>%
</span><span>\noindent Like most common VDM recursion over sets, the function consumes the set by picking each 
</span><span>set element and them calling the recursive call without the element picked, until the set is empty. 
</span><span>The VDM measure states that the recursion is based on the cardinality of the input parameter. VDM 
</span><span>measures are not suitable for Isabelle proofs, given Isabelle requires a relation;~hence,
</span><span>VDM measures are ignored during translation. They might still be useful during proofs as potential 
</span><span>witnesses to existentially-quantified goals.
</span><span>
</span><span>In Isabelle, the implicit VDM checks are defined as the precondition, which ensures 
</span><span>that the given set contains only natural numbers, and is finite, as defined by </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMSet&apos;|const"><span>inv_VDMSet'</span></a><span>‚Ä∫</span></span></span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.pre_sumset_def|fact"><span class="entity_def" id="RecursiveVDM.pre_sumset_def|thm"><span class="entity_def" id="RecursiveVDM.pre_sumset_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.pre_sumset|const"><span>pre_sumset</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMSet|type"><span>VDMSet</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><span class="main"><span>ùîπ</span></span><span>‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>pre_sumset</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>s</span></span></span></span><span> </span><span class="main"><span>‚â°</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMSet&apos;|const"><span>inv_VDMSet'</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMNat|const"><span>inv_VDMNat</span></a><span> </span><span class="free"><span class="bound"><span class="entity"><span>s</span></span></span></span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemmas</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.pre_sumset_defs|fact"><span class="entity_def" id="RecursiveVDM.pre_sumset_defs(5)|thm"><span class="entity_def" id="RecursiveVDM.pre_sumset_defs(4)|thm"><span class="entity_def" id="RecursiveVDM.pre_sumset_defs(3)|thm"><span class="entity_def" id="RecursiveVDM.pre_sumset_defs(2)|thm"><span class="entity_def" id="RecursiveVDM.pre_sumset_defs(1)|thm"><span>pre_sumset_defs</span></span></span></span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_sumset_def|fact"><span>pre_sumset_def</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMSet&apos;_defs|fact"><span>inv_VDMSet'_defs</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMNat_def|fact"><span>inv_VDMNat_def</span></a><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>We define the VDM recursive function in Isabelle next. It checks whether the given
</span><span>      set satisfy the function precondition, returning </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span>undefined</span><span>‚Ä∫</span></span></span><span> if not.
</span><span>      Each case is encoded pretty much 1-1 from VDM after that. The translation strategy for
</span><span>      VDM </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπlet-in-set‚Ä∫</span></span></span><span> patterns uses Isabelle's Hilbert's choice operator (</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>œµ</span></span><span> </span><span class="bound"><span>x</span></span><span> </span><span class="main"><span>.</span></span><span> </span><span class="bound"><span>x</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><span class="free"><span>s</span></span><span>‚Ä∫</span></span></span><span>).
</span><span>    Note this naturally extends to VDM's </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπlet-be-st‚Ä∫</span></span></span><span> patterns as well.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.sumset.domintros|fact"><span class="entity_def" id="RecursiveVDM.sumset.pelims|fact"><span class="entity_def" id="RecursiveVDM.sumset.cases|fact"><span class="entity_def" id="RecursiveVDM.sumset.termination|fact"><span class="entity_def" id="RecursiveVDM.sumset.pinduct|fact"><span class="entity_def" id="RecursiveVDM.sumset.psimps|fact"><span class="entity_def" id="RecursiveVDM.sumset_rel.inducts|fact"><span class="entity_def" id="RecursiveVDM.sumset_rel.simps|fact"><span class="entity_def" id="RecursiveVDM.sumset_rel.induct|fact"><span class="entity_def" id="RecursiveVDM.sumset_rel.cases|fact"><span class="entity_def" id="RecursiveVDM.sumset_rel.intros|fact"><span class="entity_def" id="RecursiveVDM.sumset_graph.inducts|fact"><span class="entity_def" id="RecursiveVDM.sumset_graph.simps|fact"><span class="entity_def" id="RecursiveVDM.sumset_graph.induct|fact"><span class="entity_def" id="RecursiveVDM.sumset_graph.cases|fact"><span class="entity_def" id="RecursiveVDM.sumset_graph.intros|fact"><span class="entity_def" id="RecursiveVDM.sumset.domintros|thm"><span class="entity_def" id="RecursiveVDM.sumset.pelims|thm"><span class="entity_def" id="RecursiveVDM.sumset.cases|thm"><span class="entity_def" id="RecursiveVDM.sumset.termination|thm"><span class="entity_def" id="RecursiveVDM.sumset.pinduct|thm"><span class="entity_def" id="RecursiveVDM.sumset.psimps|thm"><span class="entity_def" id="RecursiveVDM.sumset_rel.inducts|thm"><span class="entity_def" id="RecursiveVDM.sumset_rel.simps|thm"><span class="entity_def" id="RecursiveVDM.sumset_rel.induct|thm"><span class="entity_def" id="RecursiveVDM.sumset_rel.cases|thm"><span class="entity_def" id="RecursiveVDM.sumset_rel.intros|thm"><span class="entity_def" id="RecursiveVDM.sumset_graph.inducts|thm"><span class="entity_def" id="RecursiveVDM.sumset_graph.simps|thm"><span class="entity_def" id="RecursiveVDM.sumset_graph.induct|thm"><span class="entity_def" id="RecursiveVDM.sumset_graph.cases|thm"><span class="entity_def" id="RecursiveVDM.sumset_graph.intros|thm"><span class="entity_def" id="RecursiveVDM.sumset_def|axiom"><span class="entity_def" id="RecursiveVDM.sumset_rel_def|axiom"><span class="entity_def" id="RecursiveVDM.sumset_sumC_def|axiom"><span class="entity_def" id="RecursiveVDM.sumset_graph_def|axiom"><span class="entity_def" id="RecursiveVDM.sumset_dom|const"><span class="entity_def" id="RecursiveVDM.sumset_rel|const"><span class="entity_def" id="RecursiveVDM.sumset_sumC|const"><span class="entity_def" id="RecursiveVDM.sumset_graph|const"><span>function</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span>domintros</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.sumset|const"><span>sumset</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMSet|type"><span>VDMSet</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span>‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> 
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>sumset</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>s</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>if</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_sumset|const"><span>pre_sumset</span></a><span> </span><span class="free"><span class="bound"><span class="entity"><span>s</span></span></span></span><span> </span><span class="keyword1"><span>then</span></span><span> 
                   </span><span class="main"><span>(</span></span><span class="keyword1"><span>if</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>s</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>{}</span></span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="keyword1"><span>else</span></span><span> </span><span class="keyword1"><span>let</span></span><span> </span><span class="bound"><span>e</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>œµ</span></span><span> </span><span class="bound"><span>x</span></span><span> </span><span class="main"><span>.</span></span><span> </span><span class="bound"><span>x</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>s</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="keyword1"><span>in</span></span><span> </span><span class="free"><span>sumset</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>s</span></span></span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>{</span></span><span class="bound"><span>e</span></span><span class="main"><span>}</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>+</span></span><span> </span><span class="bound"><span>e</span></span><span class="main"><span>)</span></span><span> 
                  </span><span class="keyword1"><span>else</span></span><span> </span><span>undefined</span><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>The pattern completeness and compatibility goals are discharged with 
</span><span>  the usual proof strategy of </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>method</span></span><span> </span><span>pat_completeness</span><span class="antiquote"><span>}</span></span></span><span>.
</span><span>        For more general examples, if that fails, </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command</span></span><span> </span><span>sledgehammer</span><span class="antiquote"><span>}</span></span></span><span> should be used.</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>pat_completeness</span></span><span class="main"><span class="keyword3"><span>,</span></span></span><span> </span><span class="operator"><span>auto</span></span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>The measure relation for termination is defined with the </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπ@IsaMeasure‚Ä∫</span></span></span><span> annotation above as 
</span><span>   the smaller set after picking </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="free"><span>e</span></span><span>‚Ä∫</span></span></span><span> (</span><span class="antiquoted"><span class="operator"><span>‚àó</span></span><span class="plain_text"><span>‚Äπ</span><span>e.g.,</span><span>‚Ä∫</span></span></span><span>~</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="free"><span>s</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>{</span></span><span class="main"><span>(</span></span><span class="main"><span>œµ</span></span><span> </span><span class="bound"><span>e</span></span><span> </span><span class="main"><span>.</span></span><span> </span><span class="bound"><span>e</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><span class="free"><span>s</span></span><span class="main"><span>)</span></span><span class="main"><span>}</span></span><span>‚Ä∫</span></span></span><span>), 
</span><span>    and the set used at the entry call, leading to the pairs </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>(</span></span><span class="free"><span>s</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>{</span></span><span class="main"><span>(</span></span><span class="main"><span>œµ</span></span><span> </span><span class="bound"><span>e</span></span><span> </span><span class="main"><span>.</span></span><span> </span><span class="bound"><span>e</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><span class="free"><span>s</span></span><span class="main"><span>)</span></span><span class="main"><span>}</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>s</span></span><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span>. 
</span><span>    Finally, we ensure all the relation elements satisfy the function precondition (</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_sumset|const"><span>pre_sumset</span></a><span>‚Ä∫</span></span></span><span>),
</span><span>   and that the if-test is negated.</span><span>
</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>abbreviation</span></span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.sumset_wf_rel|const"><span>sumset_wf_rel</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMSet|type"><span>VDMSet</span></a><span> </span><span class="main"><span>√ó</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMSet|type"><span>VDMSet</span></a><span class="main"><span>)</span></span><span> </span><span>set</span><span>‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>sumset_wf_rel</span></span><span> </span><span class="main"><span>‚â°</span></span><span> </span><span class="main"><span>{</span></span><span> </span><span class="main"><span>(</span></span><span class="bound"><span>s</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>{</span></span><span class="main"><span>(</span></span><span class="main"><span>œµ</span></span><span> </span><span class="bound"><span>e</span></span><span> </span><span class="main"><span>.</span></span><span> </span><span class="bound"><span>e</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><span class="bound"><span>s</span></span><span class="main"><span>)</span></span><span class="main"><span>}</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>s</span></span><span class="main"><span>)</span></span><span class="main"><span>|</span></span><span> </span><span class="bound"><span>s</span></span><span> </span><span class="main"><span>.</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_sumset|const"><span>pre_sumset</span></a><span> </span><span class="bound"><span>s</span></span><span> </span><span class="main"><span>‚àß</span></span><span> </span><span class="bound"><span>s</span></span><span> </span><span class="main"><span>‚â†</span></span><span> </span><span class="main"><span>{}</span></span><span class="main"><span>}</span></span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Given this is a simple (non-mutual, single call-site, easy set element choice) recursion, again
</span><span>   we can piggyback on Isabelle machinery by using the terms </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_set_term|const"><span>gen_set_term</span></a></span><span class="antiquote"><span>}</span></span></span><span> and 
</span><span>   </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span>finite_psubset</span></span><span class="antiquote"><span>}</span></span></span><span>
</span><span>
</span><span>  They establishes that a relation where the first element is strictly smaller set than the 
</span><span>  second element in the relation pair is well-formed. This makes the proof of well-foundedness easy 
</span><span>  for </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.sumset_wf_rel|const"><span>sumset_wf_rel</span></a><span>‚Ä∫</span></span></span><span> through </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command</span></span><span> </span><span>sledgehammer</span><span class="antiquote"><span>}</span></span></span><span>.</span><span> </span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_sumset_rel_wf|fact"><span class="entity_def" id="RecursiveVDM.l_sumset_rel_wf|thm"><span>l_sumset_rel_wf</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span>wf</span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_set_term|const"><span>gen_set_term</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.sumset_wf_rel|const"><span>sumset_wf_rel</span></a><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.l_gen_set_term_wf|fact"><span>l_gen_set_term_wf</span></a><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>blast</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="offset_24787..24798">termination</span></span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Next, we tackle the termination proof, with the same setup with </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>method</span></span><span> </span><span>relation</span><span class="antiquote"><span>}</span></span></span><span> again.</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>rule</span></span><span> </span><span class="quoted"><span>"</span><a class="entity_ref" href="RecursiveVDM.html#offset_24787..24798"><span>termination</span></a><span>"</span></span><span class="main"><span class="main"><span>[</span></span></span><span class="operator"><span>of</span></span><span> </span><span class="quoted"><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span class="main"><span>(</span></span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_set_term|const"><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_set_term|const"><span>gen_set_term</span></a></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.sumset_wf_rel|const"><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.sumset_wf_rel|const"><span>sumset_wf_rel</span></a></a><span class="main"><span class="main"><span>)</span></span></span><span>"</span></span></span></span><span class="main"><span class="main"><span>]</span></span></span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.l_sumset_rel_wf|fact"><span>l_sumset_rel_wf</span></a><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span> 
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="operator"><span>force</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Unfortunately, using </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command</span></span><span> </span><span>sledgehammer</span><span class="antiquote"><span>}</span></span></span><span> fails to discharge the second subgoal </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>subgoals</span></span><span>[</span><span>display</span><span>]</span><span class="antiquote"><span>}</span></span></span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>oops</span></span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>

  </span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Fortunately, for most simple situations, this is easy to decompose in general. The translation strategy takes the 
</span><span>    </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπ@IsaMeasure‚Ä∫</span></span></span><span> expression and decompose its parts, such that the filtering predicates are assumptions, and
</span><span>    the element in the relation belong to the well-formed measure chosen. For the concrete set example, this is defined 
</span><span>  in the next lemma, which require some manual intervention to tell Isabelle what definitions to unfold and simplify with. 
</span><span>  Then, Isabelle's </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command</span></span><span> </span><span>sledgehammer</span><span class="antiquote"><span>}</span></span></span><span> can finish the proof.</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_pre_sumset_sumset_wf_rel|fact"><span class="entity_def" id="RecursiveVDM.l_pre_sumset_sumset_wf_rel|thm"><span>l_pre_sumset_sumset_wf_rel</span></span></span><span class="main"><span>:</span></span><span> 

  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_sumset|const"><span>pre_sumset</span></a><span> </span><span class="free"><span>s</span></span><span> </span><span class="main"><span>‚üπ</span></span><span> </span><span class="free"><span>s</span></span><span> </span><span class="main"><span>‚â†</span></span><span> </span><span class="main"><span>{}</span></span><span> </span><span class="main"><span>‚üπ</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>s</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>{</span></span><span class="main"><span>(</span></span><span class="main"><span>œµ</span></span><span> </span><span class="bound"><span>x</span></span><span class="main"><span>.</span></span><span> </span><span class="bound"><span>x</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><span class="free"><span>s</span></span><span class="main"><span>)</span></span><span class="main"><span>}</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>s</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_set_term|const"><span>gen_set_term</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.sumset_wf_rel|const"><span>sumset_wf_rel</span></a><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_set_term_def|fact"><span>gen_set_term_def</span></a><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_sumset_defs|fact"><span>pre_sumset_defs</span></a><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>metis</span></span><span> </span><span>Diff_subset</span><span> </span><span>member_remove</span><span> </span><span>psubsetI</span><span> </span><span>remove_def</span><span> </span><span>some_in_eq</span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>The intuition behind this lemma is that, elements in the measure relation satisfy well-formedness under the function 
</span><span>  precondition and the filtering case (</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="free"><span>s</span></span><span> </span><span class="main"><span>‚â†</span></span><span> </span><span class="main"><span>{}</span></span><span>‚Ä∫</span></span></span><span>) where the recursive call is made. That is, the precondition and 
</span><span>  filtering condition help establish the terminating relation. For this particular proof, the only aspect needed from the 
</span><span>  precondition (</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_sumset|const"><span>pre_sumset</span></a><span>‚Ä∫</span></span></span><span>) is that the set is finite. 
</span><span>
</span><span>  With this, we can try the termination proof again, which now </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command</span></span><span> </span><span>sledgehammer</span><span class="antiquote"><span>}</span></span></span><span> find proofs for all subgoals.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.sumset.elims|fact"><span class="entity_def" id="RecursiveVDM.sumset.induct|fact"><span class="entity_def" id="RecursiveVDM.sumset.simps|fact"><span class="entity_def" id="RecursiveVDM.sumset.elims|thm"><span class="entity_def" id="RecursiveVDM.sumset.induct|thm"><span class="entity_def" id="RecursiveVDM.sumset.simps|thm"><span class="entity_def" id="offset_26593..26604">termination</span></span></span></span></span></span></span></span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>rule</span></span><span> </span><span class="quoted"><span>"</span><a class="entity_ref" href="RecursiveVDM.html#offset_26593..26604"><span>termination</span></a><span>"</span></span><span class="main"><span class="main"><span>[</span></span></span><span class="operator"><span>of</span></span><span> </span><span class="quoted"><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span class="main"><span>(</span></span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_set_term|const"><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_set_term|const"><span>gen_set_term</span></a></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.sumset_wf_rel|const"><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.sumset_wf_rel|const"><span>sumset_wf_rel</span></a></a><span class="main"><span class="main"><span>)</span></span></span><span>"</span></span></span></span><span class="main"><span class="main"><span>]</span></span></span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.l_sumset_rel_wf|fact"><span>l_sumset_rel_wf</span></a><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="operator"><span>force</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.l_pre_sumset_sumset_wf_rel|fact"><span>l_pre_sumset_sumset_wf_rel</span></a><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>presburger</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
</span><span class="comment1"><span>(</span><span>*</span><span>&lt;</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_pre_fact_wf_rel&apos;|fact"><span class="entity_def" id="RecursiveVDM.l_pre_fact_wf_rel&apos;|thm"><span>l_pre_fact_wf_rel'</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_fact|const"><span>pre_fact</span></a><span> </span><span class="free"><span>n</span></span><span> </span><span class="main"><span>‚üπ</span></span><span> </span><span class="free"><span>n</span></span><span> </span><span class="main"><span>‚â†</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="main"><span>‚üπ</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>n</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>1</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>n</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_VDMNat_term|const"><span>gen_VDMNat_term</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.fact_wf|const"><span>fact_wf</span></a><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_VDMNat_term_def|fact"><span>gen_VDMNat_term_def</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_VDMInt_term_def|fact"><span>gen_VDMInt_term_def</span></a><span>
  </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.l_fact_term_valid|fact"><span>l_fact_term_valid</span></a><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>force</span></span><span>
</span><span class="comment1"><span>(</span><span>*</span><span>&gt;</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Note we omit such lemma over termination and precondition for the </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span>‚Ä∫</span></span></span><span> case in Section~\ref{subsec:VDMNat}. 
</span><span>  The translation strategy does define it following the same recipe:~recursive function precondition and filtering predicate 
</span><span>  as assumptions, and chosen termination relation element containment, where </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command</span></span><span> </span><span>sledgehammer</span><span class="antiquote"><span>}</span></span></span><span> find the proof once more.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_pre_fact_wf_rel|fact"><span class="entity_def" id="RecursiveVDM.l_pre_fact_wf_rel|thm"><span>l_pre_fact_wf_rel</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚ü¶</span></span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_fact|const"><span>pre_fact</span></a><span> </span><span class="free"><span>n</span></span><span class="main"><span>;</span></span><span> </span><span class="free"><span>n</span></span><span> </span><span class="main"><span>‚â†</span></span><span> </span><span class="main"><span>0</span></span><span class="main"><span>‚üß</span></span><span> </span><span class="main"><span>‚üπ</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>n</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>1</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>n</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_VDMNat_term|const"><span>gen_VDMNat_term</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.fact_wf|const"><span>fact_wf</span></a><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_VDMNat_term_def|fact"><span>gen_VDMNat_term_def</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_VDMInt_term_def|fact"><span>gen_VDMInt_term_def</span></a><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMNat_def|fact"><span>inv_VDMNat_def</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.l_less_than_VDMNat_subset_int_ge_less_than|fact"><span>l_less_than_VDMNat_subset_int_ge_less_than</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_fact_def|fact"><span>pre_fact_def</span></a><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>auto</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>We also choose to show the relation finite subset trick to
</span><span>make well-founded induction proofs easier does not compromise the well founded relation itself.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_sumset_wf_rel_valid|fact"><span class="entity_def" id="RecursiveVDM.l_sumset_wf_rel_valid|thm"><span>l_sumset_wf_rel_valid</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.gen_set_term|const"><span>gen_set_term</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.sumset_wf_rel|const"><span>sumset_wf_rel</span></a><span> </span><span class="main"><span>=</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.sumset_wf_rel|const"><span>sumset_wf_rel</span></a><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>intro</span></span><span> </span><span>equalityI</span><span> </span><span>subsetI</span><span class="main"><span class="keyword3"><span>,</span></span></span><span> </span><span class="operator"><span>simp</span></span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.l_pre_sumset_sumset_wf_rel|fact"><span>l_pre_sumset_sumset_wf_rel</span></a><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>blast</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Finally, even though this was not necessary for this proof, we encourage users to always provide a witness for the top recursive call.
</span><span>  This is done by using the </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπ@Witness‚Ä∫</span></span></span><span> annotation~</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>cite</span></span><span> </span><span>EdwardWitness</span><span> </span><span class="quasi_keyword"><span>and</span></span><span> </span><span>AdvancedVSCodePaper</span><span class="antiquote"><span>}</span></span></span><span>:~it provides a concrete example for the function 
</span><span>  input parameters. This witness is useful for existentially quantified predicates present in more involved termination proofs (see Section~\ref{subsec:Complex}).</span><span>‚Ä∫</span></span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>-------------------------------------------------------------------------------------------------</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Recursion over VDM maps\label{subsec:VDMMap}</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Recursive functions over VDM maps are a special case of VDM sets, given map recursion usually 
</span><span>iterates over the map's domain. For example, the function that sums the elements of the map range 
</span><span>can be defined as  
</span><span>%
</span><span>\begin{vdmsl}[frame=none,basicstyle=\ttfamily\scriptsize]
</span><span>  sum_elems: map nat to nat -&gt; nat
</span><span>  sum_elems(m) == 
</span><span>    if m = {|-&gt;} then 0 else let d in set dom m in m(d) + sum_elems({d}&lt;-:m)
</span><span>  --@IsaMeasure({({d} &lt;-: m, m) | m : map nat to nat, d: nat &amp; 
</span><span>                      m &lt;&gt; {} and d in set dom m})
</span><span>  --@Witness( sum_elems({ 1 |-&gt; 1 }) )
</span><span>  measure card dom m;
</span><span>\end{vdmsl}
</span><span>%
</span><span>\noindent As with sets, it iterates over the map by picking a domain element, performing the necessary 
</span><span>computation, and then recurse on the map filtered by removing the chosen element, until the map is 
</span><span>empty and the function terminates. As before, the measure relation follows the same pattern:~recursive call 
</span><span>site related with defining site, where both the if-test and the </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπlet-in-set‚Ä∫</span></span></span><span> choice is part of the filtering predicate.
</span><span>
</span><span>Following the general translation strategy for maps~</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>cite</span></span><span> </span><span>NimFull</span><span class="antiquote"><span>}</span></span></span><span>, we define the function precondition using </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_Map|const"><span>inv_Map</span></a><span>‚Ä∫</span></span></span><span>
</span><span>It insists that both the map domain and range are finite, and that all domain and range elements satisfy their corresponding type invariant. 
</span><span>Note that if the recursion was defined over sets other than the domain and range, Isabelle might require you to prove such set is finite. 
</span><span>Given both domain and range sets are themselves finite, this should be easy enough to do, if needed.</span><span> 
</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.pre_sum_elems_def|fact"><span class="entity_def" id="RecursiveVDM.pre_sum_elems_def|thm"><span class="entity_def" id="RecursiveVDM.pre_sum_elems_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.pre_sum_elems|const"><span>pre_sum_elems</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><span class="main"><span>‚áÄ</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚áí</span></span><span> </span><span class="main"><span>ùîπ</span></span><span>‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>pre_sum_elems</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="main"><span>‚â°</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_Map|const"><span>inv_Map</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMNat|const"><span>inv_VDMNat</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMNat|const"><span>inv_VDMNat</span></a><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemmas</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.pre_sum_elems_defs|fact"><span class="entity_def" id="RecursiveVDM.pre_sum_elems_defs(6)|thm"><span class="entity_def" id="RecursiveVDM.pre_sum_elems_defs(5)|thm"><span class="entity_def" id="RecursiveVDM.pre_sum_elems_defs(4)|thm"><span class="entity_def" id="RecursiveVDM.pre_sum_elems_defs(3)|thm"><span class="entity_def" id="RecursiveVDM.pre_sum_elems_defs(2)|thm"><span class="entity_def" id="RecursiveVDM.pre_sum_elems_defs(1)|thm"><span>pre_sum_elems_defs</span></span></span></span></span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_sum_elems_def|fact"><span>pre_sum_elems_def</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_Map_defs|fact"><span>inv_Map_defs</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMNat_def|fact"><span>inv_VDMNat_def</span></a><span> 

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>VDM maps in Isabelle (</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><span class="main"><span>‚áÄ</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span>) are defined as a HOL function which maps to an optional result. 
</span><span>That is, if the element is in the domain, the map results in a non {\texttt{</span><span class="antiquoted"><span class="operator"><span>‚ùô</span></span><span class="plain_text"><span>‚Äπ</span><span>nil</span><span>‚Ä∫</span></span></span><span>}} value, whereas if the element
</span><span>does not belong to the domain, the map results in a {\texttt{</span><span class="antiquoted"><span class="operator"><span>‚ùô</span></span><span class="plain_text"><span>‚Äπ</span><span>nil</span><span>‚Ä∫</span></span></span><span>}} value. This effectively makes all maps total,
</span><span>where values outside the domain map to {\texttt{</span><span class="antiquoted"><span class="operator"><span>‚ùô</span></span><span class="plain_text"><span>‚Äπ</span><span>nil</span><span>‚Ä∫</span></span></span><span>}}. The Isabelle translation and compatibility proof follows 
</span><span>patterns used before and are given as</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.sum_elems.domintros|fact"><span class="entity_def" id="RecursiveVDM.sum_elems.pelims|fact"><span class="entity_def" id="RecursiveVDM.sum_elems.cases|fact"><span class="entity_def" id="RecursiveVDM.sum_elems.termination|fact"><span class="entity_def" id="RecursiveVDM.sum_elems.pinduct|fact"><span class="entity_def" id="RecursiveVDM.sum_elems.psimps|fact"><span class="entity_def" id="RecursiveVDM.sum_elems_rel.inducts|fact"><span class="entity_def" id="RecursiveVDM.sum_elems_rel.simps|fact"><span class="entity_def" id="RecursiveVDM.sum_elems_rel.induct|fact"><span class="entity_def" id="RecursiveVDM.sum_elems_rel.cases|fact"><span class="entity_def" id="RecursiveVDM.sum_elems_rel.intros|fact"><span class="entity_def" id="RecursiveVDM.sum_elems_graph.inducts|fact"><span class="entity_def" id="RecursiveVDM.sum_elems_graph.simps|fact"><span class="entity_def" id="RecursiveVDM.sum_elems_graph.induct|fact"><span class="entity_def" id="RecursiveVDM.sum_elems_graph.cases|fact"><span class="entity_def" id="RecursiveVDM.sum_elems_graph.intros|fact"><span class="entity_def" id="RecursiveVDM.sum_elems.domintros|thm"><span class="entity_def" id="RecursiveVDM.sum_elems.pelims|thm"><span class="entity_def" id="RecursiveVDM.sum_elems.cases|thm"><span class="entity_def" id="RecursiveVDM.sum_elems.termination|thm"><span class="entity_def" id="RecursiveVDM.sum_elems.pinduct|thm"><span class="entity_def" id="RecursiveVDM.sum_elems.psimps|thm"><span class="entity_def" id="RecursiveVDM.sum_elems_rel.inducts|thm"><span class="entity_def" id="RecursiveVDM.sum_elems_rel.simps|thm"><span class="entity_def" id="RecursiveVDM.sum_elems_rel.induct|thm"><span class="entity_def" id="RecursiveVDM.sum_elems_rel.cases|thm"><span class="entity_def" id="RecursiveVDM.sum_elems_rel.intros|thm"><span class="entity_def" id="RecursiveVDM.sum_elems_graph.inducts|thm"><span class="entity_def" id="RecursiveVDM.sum_elems_graph.simps|thm"><span class="entity_def" id="RecursiveVDM.sum_elems_graph.induct|thm"><span class="entity_def" id="RecursiveVDM.sum_elems_graph.cases|thm"><span class="entity_def" id="RecursiveVDM.sum_elems_graph.intros|thm"><span class="entity_def" id="RecursiveVDM.sum_elems_def|axiom"><span class="entity_def" id="RecursiveVDM.sum_elems_rel_def|axiom"><span class="entity_def" id="RecursiveVDM.sum_elems_sumC_def|axiom"><span class="entity_def" id="RecursiveVDM.sum_elems_graph_def|axiom"><span class="entity_def" id="RecursiveVDM.sum_elems_dom|const"><span class="entity_def" id="RecursiveVDM.sum_elems_rel|const"><span class="entity_def" id="RecursiveVDM.sum_elems_sumC|const"><span class="entity_def" id="RecursiveVDM.sum_elems_graph|const"><span>function</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span>domintros</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.sum_elems|const"><span>sum_elems</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><span class="main"><span>‚áÄ</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚áí</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span>‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>sum_elems</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>if</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_sum_elems|const"><span>pre_sum_elems</span></a><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="keyword1"><span>then</span></span><span>
                      </span><span class="keyword1"><span>if</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Map.empty</span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="keyword1"><span>else</span></span><span>
           </span><span class="keyword1"><span>let</span></span><span> </span><span class="bound"><span>d</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>œµ</span></span><span> </span><span class="bound"><span>e</span></span><span> </span><span class="main"><span>.</span></span><span> </span><span class="bound"><span>e</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><span>dom</span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="keyword1"><span>in</span></span><span> </span><span>the</span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="bound"><span>d</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>+</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>sum_elems</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>{</span></span><span class="bound"><span>d</span></span><span class="main"><span>}</span></span><span> </span><span class="main"><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.dom_antirestr|const"><span>-‚óÉ</span></a></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
                  </span><span class="keyword1"><span>else</span></span><span> </span><span>undefined</span><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>pat_completeness</span></span><span class="main"><span class="keyword3"><span>,</span></span></span><span> </span><span class="operator"><span>auto</span></span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Similarly, the well-formed relation from </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπ@IsaMeasure‚Ä∫</span></span></span><span> is translated next, where the precondition is also included 
</span><span>as part of the relation's filter. The </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>{</span></span><span class="free"><span>d</span></span><span class="main"><span>}</span></span><span class="main"><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.dom_antirestr|const"><span>-‚óÉ</span></a></span><span class="free"><span>m</span></span><span>‚Ä∫</span></span></span><span> corresponds to VDM domain anti-filtering operator </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπ&lt;-:‚Ä∫</span></span></span><span>.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>abbreviation</span></span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.sum_elems_wf|const"><span>sum_elems_wf</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><span class="main"><span>‚áÄ</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span class="main"><span>)</span></span><span> </span><span class="main"><span>√ó</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><span class="main"><span>‚áÄ</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMSet|type"><span>VDMSet</span></a><span>‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>sum_elems_wf</span></span><span> </span><span class="main"><span>‚â°</span></span><span> 
  </span><span class="main"><span>{</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="main"><span>{</span></span><span class="bound"><span>d</span></span><span class="main"><span>}</span></span><span> </span><span class="main"><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.dom_antirestr|const"><span>-‚óÉ</span></a></span><span> </span><span class="bound"><span>m</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>m</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>|</span></span><span> </span><span class="bound"><span>m</span></span><span> </span><span class="bound"><span>d</span></span><span> </span><span class="main"><span>.</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_sum_elems|const"><span>pre_sum_elems</span></a><span> </span><span class="bound"><span>m</span></span><span> </span><span class="main"><span>‚àß</span></span><span> </span><span class="bound"><span>m</span></span><span> </span><span class="main"><span>‚â†</span></span><span> </span><span>Map.empty</span><span> </span><span class="main"><span>‚àß</span></span><span> </span><span class="bound"><span>d</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><span>dom</span><span> </span><span class="bound"><span>m</span></span><span> </span><span class="main"><span>}</span></span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>For the well-formed lemma over the recursive measure relation, there are no available Isabelle help, 
</span><span>and projecting the domain element of the maps within the relation is awkward. Thus, we have to prove the 
</span><span>lemma directly. This will not be automatic in general. This is one difference in terms of translation of VDM 
</span><span>recursive functions over sets and maps.
</span><span>
</span><span>Fortunately, the proof strategy for such situations is somewhat known:~it follows a similar strategy to
</span><span>the proof of well formedness of the </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span>finite_psubset</span><span>‚Ä∫</span></span></span><span> as </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><span>wf_finite_psubset</span><span class="antiquote"><span>}</span></span></span><span>. The proof uses
</span><span>the VDM measure expression to extract the right projection of interest, then follows the proof for </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span>finite_psubset</span><span>‚Ä∫</span></span></span><span>. 
</span><span>Finally, </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command</span></span><span> </span><span>sledgehammer</span><span class="antiquote"><span>}</span></span></span><span> can figure out the final steps.</span><span>   
</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_sum_elems_wf|fact"><span class="entity_def" id="RecursiveVDM.l_sum_elems_wf|thm"><span>l_sum_elems_wf</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span>wf</span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.sum_elems_wf|const"><span>sum_elems_wf</span></a><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>rule</span></span><span> </span><span>wf_measure</span><span class="main"><span class="main"><span>[</span></span></span><span class="operator"><span>of</span></span><span> </span><span class="quoted"><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span class="main"><span>Œª</span></span></span><span> </span><span class="bound"><span class="bound"><span>m</span></span></span><span> </span><span class="main"><span class="main"><span>.</span></span></span><span> </span><span>card</span><span> </span><span class="main"><span class="main"><span>(</span></span></span><span>dom</span><span> </span><span class="bound"><span class="bound"><span>m</span></span></span><span class="main"><span class="main"><span>)</span></span></span><span>‚Ä∫</span></span></span></span><span class="main"><span class="main"><span>,</span></span></span><span> </span><span class="operator"><span>THEN</span></span><span> </span><span>wf_subset</span><span class="main"><span class="main"><span>]</span></span></span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>measure_def</span><span> </span><span>inv_image_def</span><span> </span><span>less_than_def</span><span> </span><span>less_eq</span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>rule</span></span><span> </span><span>subsetI</span><span class="main"><span class="keyword3"><span>,</span></span></span><span> </span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>case_prod_beta</span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>elim</span></span><span> </span><span>exE</span><span> </span><span>conjE</span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.l_VDMMap_filtering_card|fact"><span>l_VDMMap_filtering_card</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_sum_elems_defs|fact"><span>pre_sum_elems_defs</span></a><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>The precondition subgoal and the termination proof follow the same patterns as before. Again,
</span><span>their proof was discovered with </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command</span></span><span> </span><span>sledgehammer</span><span class="antiquote"><span>}</span></span></span><span>, yet this will not be the case in general.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_pre_sum_elems_sum_elems_wf|fact"><span class="entity_def" id="RecursiveVDM.l_pre_sum_elems_sum_elems_wf|thm"><span>l_pre_sum_elems_sum_elems_wf</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚ü¶</span></span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_sum_elems|const"><span>pre_sum_elems</span></a><span> </span><span class="free"><span>m</span></span><span class="main"><span>;</span></span><span> </span><span class="free"><span>m</span></span><span> </span><span class="main"><span>‚â†</span></span><span> </span><span>Map.empty</span><span class="main"><span>‚üß</span></span><span> </span><span class="main"><span>‚üπ</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>{</span></span><span class="main"><span>(</span></span><span class="main"><span>œµ</span></span><span> </span><span class="bound"><span>e</span></span><span class="main"><span>.</span></span><span> </span><span class="bound"><span>e</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><span>dom</span><span> </span><span class="free"><span>m</span></span><span class="main"><span>)</span></span><span class="main"><span>}</span></span><span> </span><span class="main"><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.dom_antirestr|const"><span>-‚óÉ</span></a></span><span> </span><span class="free"><span>m</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>m</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.sum_elems_wf|const"><span>sum_elems_wf</span></a><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_sum_elems_defs|fact"><span>pre_sum_elems_defs</span></a><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>metis</span></span><span> </span><span>domIff</span><span> </span><span>empty_iff</span><span> </span><span>some_in_eq</span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.sum_elems.elims|fact"><span class="entity_def" id="RecursiveVDM.sum_elems.induct|fact"><span class="entity_def" id="RecursiveVDM.sum_elems.simps|fact"><span class="entity_def" id="RecursiveVDM.sum_elems.elims|thm"><span class="entity_def" id="RecursiveVDM.sum_elems.induct|thm"><span class="entity_def" id="RecursiveVDM.sum_elems.simps|thm"><span class="entity_def" id="offset_33145..33156">termination</span></span></span></span></span></span></span></span></span><span>  </span><span class="comment1"><span>‚úê</span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>rule</span></span><span> </span><span class="quoted"><span>"</span><a class="entity_ref" href="RecursiveVDM.html#offset_33145..33156"><span>termination</span></a><span>"</span></span><span class="main"><span class="main"><span>[</span></span></span><span class="operator"><span>OF</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.l_sum_elems_wf|fact"><span>l_sum_elems_wf</span></a><span class="main"><span class="main"><span>]</span></span></span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.l_pre_sum_elems_sum_elems_wf|fact"><span>l_pre_sum_elems_sum_elems_wf</span></a><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>presburger</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Finally, we also prove that the well founded termination relation (</span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.sum_elems_wf|const"><span>sum_elems_wf</span></a><span>‚Ä∫</span></span></span><span>) is not 
</span><span>empty, as we did for sets and </span><span class="antiquoted"><span class="operator"><span>‚ùô</span></span><span class="plain_text"><span>‚Äπ</span><span>nat</span><span>‚Ä∫</span></span></span><span> recursion. Note that here the </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπ@Witness‚Ä∫</span></span></span><span> annotation is 
</span><span>useful in discharging the actual value to use as the witness demonstrating the relation is not empty.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_sum_elems_wf_valid|fact"><span class="entity_def" id="RecursiveVDM.l_sum_elems_wf_valid|thm"><span>l_sum_elems_wf_valid</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.sum_elems_wf|const"><span>sum_elems_wf</span></a><span> </span><span class="main"><span>‚â†</span></span><span> </span><span class="main"><span>{}</span></span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="operator"><span>safe</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>erule</span></span><span> </span><span>equalityE</span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>subset_eq</span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>erule_tac</span></span><span> x</span><span class="main"><span class="main"><span>=</span></span></span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span>[</span></span><span class="main"><span>1</span></span><span> </span><span class="main"><span>‚Ü¶</span></span><span> </span><span class="main"><span>1</span></span><span class="main"><span>]</span></span><span>‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span>in</span></span></span></span><span> </span><span>allE</span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_sum_elems_defs|fact"><span>pre_sum_elems_defs</span></a><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>-------------------------------------------------------------------------------------------------</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>VDM recursion involving complex measures\label{subsec:Complex}</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>The class of recursive examples shown so far have cover a wide range of 
</span><span>situations, and have a good level of automation. Nevertheless, the same strategy can
</span><span>also be applied for me complex recursive definitions. The cost for the VDM user
</span><span>is the need of a more involved </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπ@IsaMeasure‚Ä∫</span></span></span><span> definition and the highly likely need for
</span><span>extra user-defined lemmas. These lemmas can be defined in VDM itself using 
</span><span>the </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπ@Lemma‚Ä∫</span></span></span><span> annotation, which will be translated to Isabelle as any other boolean 
</span><span>expression would.
</span><span>
</span><span>To illustrate this, we define in VDM the (in)famous Ackermann 
</span><span>function</span><span class="antiquoted"><span class="operator"><span>‚Åã</span></span><span class="plain_text"><span>‚Äπ</span><span class="antiquoted"><span class="operator"><span>üåê</span></span><span>‚Äπhttps://en.wikipedia.org/wiki/Ackermann_function‚Ä∫</span></span><span>‚Ä∫</span></span></span><span>, 
</span><span>which is a staple example of complex recursion, as  
</span><span>%
</span><span>\begin{vdmsl}[frame=none,basicstyle=\ttfamily\scriptsize]
</span><span>    ack: nat * nat -&gt; nat 
</span><span>    ack(m,n) == if m = 0 then n+1
</span><span>           else if n = 0 then ack(m-1, 1)
</span><span>           else               ack(m-1, ack(m, (n-1)))
</span><span>    --@IsaMeasure( pair_less_VDMNat )
</span><span>    --@Witness( ack(2, 1) )
</span><span>    measure is not yet specified;
</span><span>\end{vdmsl}
</span><span>%
</span><span>\noindent Note that the VDM measure is not defined, and that the </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπ@IsaMeasure‚Ä∫</span></span></span><span>
</span><span>uses a construct from Isabelle called </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span>pair_less</span><span>‚Ä∫</span></span></span><span>. It is part of Isabelle's 
</span><span>machinery of concrete orders for SCNP problems </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>cite</span></span><span> </span><span>KrausSCNP</span><span class="antiquote"><span>}</span></span></span><span>. 
</span><span>It considers recursions over multiple parameters, where some might 
</span><span>increase the number of calls (</span><span class="antiquoted"><span class="operator"><span>‚àó</span></span><span class="plain_text"><span>‚Äπ</span><span>e.g.</span><span>‚Ä∫</span></span></span><span>~size-change). We are not aware of a 
</span><span>mechanism to define such measures in VDM. 
</span><span>
</span><span>We instantiate </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span>pair_less</span><span>‚Ä∫</span></span></span><span> to </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span>‚Ä∫</span></span></span><span>. It is defined as the lexicographic 
</span><span>product over the transitive closure of a totally ordered relation between </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span>‚Ä∫</span></span></span><span> 
</span><span>inputs</span><span class="antiquoted"><span class="operator"><span>‚Åã</span></span><span class="plain_text"><span>‚Äπ</span><span>Details of this definition in the </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚ÄπVDMToolkit.thy‚Ä∫</span></span></span><span> file within the 
</span><span>distribution in~</span><span class="antiquoted"><span class="operator"><span>üåê</span></span><span>‚Äπhttps://github.com/leouk/VDM_Toolkit‚Ä∫</span></span><span>.</span><span>‚Ä∫</span></span></span><span>. 
</span><span>
</span><span>If VDM measures were over relations, the Ackermann measure could be defined defined in VDM,
</span><span>assuming a standard definition of transitive closure</span><span class="antiquoted"><span class="operator"><span>‚Åã</span></span><span class="plain_text"><span>‚Äπ</span><span>The </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚ÄπRelations.vdmsl‚Ä∫</span></span></span><span> provides 
</span><span>such definition in the VDM toolkit distribution.</span><span>‚Ä∫</span></span></span><span>, as
</span><span>%
</span><span>\begin{vdmsl}[frame=none,basicstyle=\ttfamily\scriptsize]
</span><span>pair_less_VDMNat: () -&gt; set of ((nat*nat) * (nat*nat))
</span><span>pair_less_VDMNat() == lex_prod[nat, nat](less_than_VDMNat(), less_than_VDMNat());
</span><span>
</span><span>less_than_VDMNat: () -&gt; set of (nat*nat)
</span><span>less_than_VDMNat() == trans_closure[nat]({ mk_(z', z) | z', z : nat &amp; z' &lt; z });
</span><span>
</span><span>lex_prod[@A,@B]: set of (@A*@A) * set of (@B*@B) -&gt; set of ((@A*@B) * (@A*@B))
</span><span>lex_prod(ra,rb) == 
</span><span>    { mk_(mk_(a, b), mk_(a', b')) | a, a': @A, b, b': @B &amp; 
</span><span>        mk_(a,a') in set ra or a = a' and mk_(b, b') in set rb };
</span><span>\end{vdmsl}
</span><span>%
</span><span>That is, the lexicographic product of possibilities that are ordered in its parameters. 
</span><span>The translation process is the same as above and produces</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.pre_ack_def|fact"><span class="entity_def" id="RecursiveVDM.pre_ack_def|thm"><span class="entity_def" id="RecursiveVDM.pre_ack_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.pre_ack|const"><span>pre_ack</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><span class="main"><span>ùîπ</span></span><span>‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>pre_ack</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>‚â°</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMNat|const"><span>inv_VDMNat</span></a><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="main"><span>‚àß</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMNat|const"><span>inv_VDMNat</span></a><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemmas</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.pre_ack_defs|fact"><span class="entity_def" id="RecursiveVDM.pre_ack_defs(2)|thm"><span class="entity_def" id="RecursiveVDM.pre_ack_defs(1)|thm"><span>pre_ack_defs</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_ack_def|fact"><span>pre_ack_def</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMNat_def|fact"><span>inv_VDMNat_def</span></a><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.ack.domintros|fact"><span class="entity_def" id="RecursiveVDM.ack.pelims|fact"><span class="entity_def" id="RecursiveVDM.ack.cases|fact"><span class="entity_def" id="RecursiveVDM.ack.termination|fact"><span class="entity_def" id="RecursiveVDM.ack.pinduct|fact"><span class="entity_def" id="RecursiveVDM.ack.psimps|fact"><span class="entity_def" id="RecursiveVDM.ack_rel.inducts|fact"><span class="entity_def" id="RecursiveVDM.ack_rel.simps|fact"><span class="entity_def" id="RecursiveVDM.ack_rel.induct|fact"><span class="entity_def" id="RecursiveVDM.ack_rel.cases|fact"><span class="entity_def" id="RecursiveVDM.ack_rel.intros|fact"><span class="entity_def" id="RecursiveVDM.ack_graph.inducts|fact"><span class="entity_def" id="RecursiveVDM.ack_graph.simps|fact"><span class="entity_def" id="RecursiveVDM.ack_graph.induct|fact"><span class="entity_def" id="RecursiveVDM.ack_graph.cases|fact"><span class="entity_def" id="RecursiveVDM.ack_graph.intros|fact"><span class="entity_def" id="RecursiveVDM.ack.domintros|thm"><span class="entity_def" id="RecursiveVDM.ack.pelims|thm"><span class="entity_def" id="RecursiveVDM.ack.cases|thm"><span class="entity_def" id="RecursiveVDM.ack.termination|thm"><span class="entity_def" id="RecursiveVDM.ack.pinduct|thm"><span class="entity_def" id="RecursiveVDM.ack.psimps|thm"><span class="entity_def" id="RecursiveVDM.ack_rel.inducts|thm"><span class="entity_def" id="RecursiveVDM.ack_rel.simps|thm"><span class="entity_def" id="RecursiveVDM.ack_rel.induct|thm"><span class="entity_def" id="RecursiveVDM.ack_rel.cases|thm"><span class="entity_def" id="RecursiveVDM.ack_rel.intros(3)|thm"><span class="entity_def" id="RecursiveVDM.ack_rel.intros(2)|thm"><span class="entity_def" id="RecursiveVDM.ack_rel.intros(1)|thm"><span class="entity_def" id="RecursiveVDM.ack_graph.inducts|thm"><span class="entity_def" id="RecursiveVDM.ack_graph.simps|thm"><span class="entity_def" id="RecursiveVDM.ack_graph.induct|thm"><span class="entity_def" id="RecursiveVDM.ack_graph.cases|thm"><span class="entity_def" id="RecursiveVDM.ack_graph.intros|thm"><span class="entity_def" id="RecursiveVDM.ack_def|axiom"><span class="entity_def" id="RecursiveVDM.ack_rel_def|axiom"><span class="entity_def" id="RecursiveVDM.ack_sumC_def|axiom"><span class="entity_def" id="RecursiveVDM.ack_graph_def|axiom"><span class="entity_def" id="RecursiveVDM.ack_dom|const"><span class="entity_def" id="RecursiveVDM.ack_rel|const"><span class="entity_def" id="RecursiveVDM.ack_sumC|const"><span class="entity_def" id="RecursiveVDM.ack_graph|const"><span>function</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span>domintros</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.ack|const"><span>ack</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span>‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>ack</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>if</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_ack|const"><span>pre_ack</span></a><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="keyword1"><span>then</span></span><span>
                       </span><span class="keyword1"><span>if</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span class="main"><span>+</span></span><span class="main"><span>1</span></span><span>
                  </span><span class="keyword1"><span>else</span></span><span> </span><span class="keyword1"><span>if</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span class="free"><span>ack</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span class="main"><span>-</span></span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>1</span></span><span>
                  </span><span class="keyword1"><span>else</span></span><span>               </span><span class="free"><span>ack</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span class="main"><span>-</span></span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>ack</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span class="main"><span>-</span></span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
                  </span><span class="keyword1"><span>else</span></span><span>               </span><span>undefined</span><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>pat_completeness</span></span><span class="main"><span class="keyword3"><span>,</span></span></span><span> </span><span class="operator"><span>auto</span></span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>abbreviation</span></span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.ack_wf|const"><span>ack_wf</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><span class="main"><span>√ó</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span class="main"><span>)</span></span><span> </span><span class="main"><span>√ó</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span> </span><span class="main"><span>√ó</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMSet|type"><span>VDMSet</span></a><span>‚Ä∫</span></span></span><span> 
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>ack_wf</span></span><span> </span><span class="main"><span>‚â°</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.pair_less_VDMNat|const"><span>pair_less_VDMNat</span></a><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.ack.elims|fact"><span class="entity_def" id="RecursiveVDM.ack.induct|fact"><span class="entity_def" id="RecursiveVDM.ack.simps|fact"><span class="entity_def" id="RecursiveVDM.ack.elims|thm"><span class="entity_def" id="RecursiveVDM.ack.induct|thm"><span class="entity_def" id="RecursiveVDM.ack.simps|thm"><span>termination</span></span></span></span></span></span></span></span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>relation</span></span><span> </span><span class="quoted"><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.ack_wf|const"><span>ack_wf</span></a></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>using</span></span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.wf_pair_less_VDMNat|fact"><span>wf_pair_less_VDMNat</span></a><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="operator"><span>blast</span></span><span>
    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMNat_def|fact"><span>inv_VDMNat_def</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.l_pair_less_VDMNat_I1|fact"><span>l_pair_less_VDMNat_I1</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_ack_def|fact"><span>pre_ack_def</span></a><span class="main"><span>)</span></span><span>
   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMNat_def|fact"><span>inv_VDMNat_def</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_ack_def|fact"><span>pre_ack_def</span></a><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMNat_def|fact"><span>inv_VDMNat_def</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.pair_less_VDMNat_def|fact"><span>pair_less_VDMNat_def</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_ack_def|fact"><span>pre_ack_def</span></a><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>The proofs are also similar, despite the more complex measure, because of
</span><span>available Isabelle automation. We also show that this version of Ackermann with
</span><span> </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMNat|type"><span>VDMNat</span></a><span>‚Ä∫</span></span></span><span> is equivalent to the usual Isabelle definition using </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñï</span></span><span>‚Ä∫</span></span></span><span>. 
</span><span>We omit details here, but have proved that they are equivalent by induction</span><span>‚Ä∫</span></span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>&lt;</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.ack&apos;.elims|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;.induct|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;.simps|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;.pelims|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;.cases|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;.termination|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;.pinduct|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;.psimps|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;_rel.inducts|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;_rel.simps|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;_rel.induct|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;_rel.cases|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;_rel.intros|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;_graph.inducts|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;_graph.simps|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;_graph.induct|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;_graph.cases|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;_graph.intros|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;.elims|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;.induct|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;.simps(3)|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;.simps(2)|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;.simps(1)|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;.pelims|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;.cases|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;.termination|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;.pinduct|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;.psimps(3)|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;.psimps(2)|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;.psimps(1)|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;_rel.inducts|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;_rel.simps|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;_rel.induct|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;_rel.cases|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;_rel.intros(3)|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;_rel.intros(2)|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;_rel.intros(1)|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;_graph.inducts|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;_graph.simps|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;_graph.induct|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;_graph.cases|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;_graph.intros(3)|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;_graph.intros(2)|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;_graph.intros(1)|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;_def|axiom"><span class="entity_def" id="RecursiveVDM.ack&apos;_rel_def|axiom"><span class="entity_def" id="RecursiveVDM.ack&apos;_sumC_def|axiom"><span class="entity_def" id="RecursiveVDM.ack&apos;_graph_def|axiom"><span class="entity_def" id="RecursiveVDM.ack&apos;_dom|const"><span class="entity_def" id="RecursiveVDM.ack&apos;_rel|const"><span class="entity_def" id="RecursiveVDM.ack&apos;_sumC|const"><span class="entity_def" id="RecursiveVDM.ack&apos;_graph|const"><span>fun</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.ack&apos;|const"><span>ack'</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñï</span></span><span> </span><span class="main"><span>‚áí</span></span><span> </span><span class="main"><span>‚Ñï</span></span><span> </span><span class="main"><span>‚áí</span></span><span> </span><span class="main"><span>‚Ñï</span></span><span>‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>ack'</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span>             </span><span class="main"><span>=</span></span><span> </span><span>Suc</span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span>"</span></span></span><span>
</span><span class="main"><span>|</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>ack'</span></span><span> </span><span class="main"><span>(</span></span><span>Suc</span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>0</span></span><span>       </span><span class="main"><span>=</span></span><span> </span><span class="free"><span>ack'</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="main"><span>1</span></span><span>"</span></span></span><span>
</span><span class="main"><span>|</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>ack'</span></span><span> </span><span class="main"><span>(</span></span><span>Suc</span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>Suc</span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="free"><span>ack'</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>ack'</span></span><span> </span><span class="main"><span>(</span></span><span>Suc</span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span class="main"><span>)</span></span><span>"</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;.elims|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;.induct|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;.simps|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;.pelims|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;.cases|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;.termination|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;.pinduct|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;.psimps|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_rel.inducts|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_rel.simps|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_rel.induct|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_rel.cases|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_rel.intros|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_graph.inducts|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_graph.simps|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_graph.induct|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_graph.cases|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_graph.intros|fact"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;.elims|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;.induct|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;.simps|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;.pelims|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;.cases|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;.termination|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;.pinduct|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;.psimps|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_rel.inducts|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_rel.simps|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_rel.induct|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_rel.cases|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_rel.intros(3)|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_rel.intros(2)|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_rel.intros(1)|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_graph.inducts|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_graph.simps|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_graph.induct|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_graph.cases|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_graph.intros|thm"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_def|axiom"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_rel_def|axiom"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_sumC_def|axiom"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_graph_def|axiom"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_dom|const"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_rel|const"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_sumC|const"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;_graph|const"><span>fun</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.ack&apos;&apos;|const"><span>ack''</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñï</span></span><span> </span><span class="main"><span>‚áí</span></span><span> </span><span class="main"><span>‚Ñï</span></span><span> </span><span class="main"><span>‚áí</span></span><span> </span><span class="main"><span>‚Ñï</span></span><span>‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>ack''</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>if</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span>Suc</span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="keyword1"><span>else</span></span><span> </span><span class="keyword1"><span>if</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span class="free"><span>ack''</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>1</span></span><span> </span><span class="keyword1"><span>else</span></span><span> </span><span class="free"><span>ack''</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span class="main"><span>-</span></span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>ack''</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>-</span></span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_ack&apos;&apos;_1|fact"><span class="entity_def" id="RecursiveVDM.l_ack&apos;&apos;_1|thm"><span>l_ack''_1</span></span></span><span class="main"><span>[</span></span><span class="operator"><span>simp</span></span><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.ack&apos;&apos;|const"><span>ack''</span></a><span> </span><span class="main"><span>0</span></span><span> </span><span class="free"><span>n</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Suc</span><span> </span><span class="free"><span>n</span></span><span>‚Ä∫</span></span></span><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>simp</span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_ack&apos;&apos;_2|fact"><span class="entity_def" id="RecursiveVDM.l_ack&apos;&apos;_2|thm"><span>l_ack''_2</span></span></span><span class="main"><span>[</span></span><span class="operator"><span>simp</span></span><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.ack&apos;&apos;|const"><span>ack''</span></a><span> </span><span class="main"><span>(</span></span><span>Suc</span><span> </span><span class="free"><span>m</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="main"><span>=</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.ack&apos;&apos;|const"><span>ack''</span></a><span> </span><span class="free"><span>m</span></span><span> </span><span class="main"><span>1</span></span><span>‚Ä∫</span></span></span><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>simp</span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_ack&apos;&apos;_3|fact"><span class="entity_def" id="RecursiveVDM.l_ack&apos;&apos;_3|thm"><span>l_ack''_3</span></span></span><span class="main"><span>[</span></span><span class="operator"><span>simp</span></span><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.ack&apos;&apos;|const"><span>ack''</span></a><span> </span><span class="main"><span>(</span></span><span>Suc</span><span> </span><span class="free"><span>m</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>Suc</span><span> </span><span class="free"><span>n</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.ack&apos;&apos;|const"><span>ack''</span></a><span> </span><span class="free"><span>m</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.ack&apos;&apos;|const"><span>ack''</span></a><span> </span><span class="main"><span>(</span></span><span>Suc</span><span> </span><span class="free"><span>m</span></span><span class="main"><span>)</span></span><span> </span><span class="free"><span>n</span></span><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>simp</span></span><span>
</span><span class="comment1"><span>(</span><span>*</span><span>&gt;</span><span>*</span><span>)</span></span><span>

</span><span class="keyword1"><span class="command"><span>theorem</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.ack_correct|fact"><span class="entity_def" id="RecursiveVDM.ack_correct|thm"><span>ack_correct</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.ack&apos;|const"><span>ack'</span></a><span> </span><span class="free"><span>m</span></span><span> </span><span class="free"><span>n</span></span><span> </span><span class="main"><span>=</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.ack|const"><span>ack</span></a><span> </span><span class="free"><span>m</span></span><span> </span><span class="free"><span>n</span></span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>induction</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>m</span></span><span>‚Ä∫</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>n</span></span><span>‚Ä∫</span></span></span><span> </span><span class="quasi_keyword"><span>rule</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.ack&apos;.induct|fact"><span>ack'.induct</span></a><span class="main"><span>)</span></span><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_ack_defs|fact"><span>pre_ack_defs</span></a><span class="main"><span>)</span></span><span class="main"><span class="keyword3"><span>+</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>In general, each complex recursion function will require such a setup. Fortunately, 
</span><span>Isabelle has a number of options available. Yet, in general, the more complex the recursion, 
</span><span>the more users will have to provide further automation.</span><span>‚Ä∫</span></span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>************************************************************************************************</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>subsection</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Harder examples\label{subsec:Hard}</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>The next two examples are from the Isabelle 
</span><span>distribution</span><span class="antiquoted"><span class="operator"><span>‚Åã</span></span><span class="plain_text"><span>‚Äπ</span><span class="antiquoted"><span class="operator"><span>üåê</span></span><span>‚Äπhttps://isabelle.in.tum.de/library/HOL/HOL-Examples/Functions.html‚Ä∫</span></span><span>‚Ä∫</span></span></span><span> 
</span><span>and require an elaborate setup. Nipkow's permutation function~</span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>cite</span></span><span> </span><span>TermRewriting</span><span class="antiquote"><span>}</span></span></span><span> 
</span><span>shows permuting decreasing parameters with an involved measure. The precondition 
</span><span>was required for finishing the termination proof and shows an example why proofs over </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span class="main"><span>‚Ñ§</span></span><span>‚Ä∫</span></span></span><span>
</span><span>can be harder.
</span><span>%
</span><span>\begin{vdmsl}[frame=none,basicstyle=\ttfamily\scriptsize]
</span><span>    perm: int * int * int -&gt; int 
</span><span>    perm(m,n,r) == if 0 &lt; r then perm(m, r-1, n) 
</span><span>              else if 0 &lt; n then perm(r, n-1, m) else m
</span><span>    --@IsaMeasure({mk_(mk_(m, r-1, n), mk_(m,n,r)) | ... &amp; 0 &lt; r} union 
</span><span>    --            {mk_(mk_(r, n-1, m), mk_(m,n,r)) | ... &amp; not 0 &lt; r and 0 &lt; n})
</span><span>    pre ((0 &lt; r or 0 &lt; n) =&gt; m+n+r &gt; 0)   measure maxs({m+n+r, 0});      
</span><span>
</span><span>    tak: int * int * int -&gt; int
</span><span>    tak(x,y,z) == if x &lt;= y then y  
</span><span>                  else           tak(tak(x-1,y,z), tak(y-1,z,x), tak(z-1,x,y))
</span><span>    measure is not yet specified;
</span><span>\end{vdmsl}
</span><span>%
</span><span>\noindent The Takeuchi's function is particularly challenging because it permutes 
</span><span>parameters like </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπperm‚Ä∫</span></span></span><span>, and like Ackermann's function, have 
</span><span>inner recursive calls as part of an outer recursive call. The translation 
</span><span>strategy works for these definitions, yet stands little chance of finding proofs 
</span><span>automatically. Nipkow's permutation function follows the earlier process.</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.pre_perm_def|fact"><span class="entity_def" id="RecursiveVDM.pre_perm_def|thm"><span class="entity_def" id="RecursiveVDM.pre_perm_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.pre_perm|const"><span>pre_perm</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMInt|type"><span>VDMInt</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMInt|type"><span>VDMInt</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMInt|type"><span>VDMInt</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><span class="main"><span>ùîπ</span></span><span>‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>pre_perm</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>r</span></span></span></span><span> </span><span class="main"><span>‚â°</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMInt|const"><span>inv_VDMInt</span></a><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="main"><span>‚àß</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMInt|const"><span>inv_VDMInt</span></a><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="main"><span>‚àß</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMInt|const"><span>inv_VDMInt</span></a><span> </span><span class="free"><span class="bound"><span class="entity"><span>r</span></span></span></span><span> </span><span class="main"><span>‚àß</span></span><span> 
                    </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="main"><span>0</span></span><span> </span><span class="main"><span>&lt;</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>r</span></span></span></span><span> </span><span class="main"><span>‚à®</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="main"><span>&lt;</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚ü∂</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span class="main"><span>+</span></span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span class="main"><span>+</span></span><span class="free"><span class="bound"><span class="entity"><span>r</span></span></span></span><span> </span><span class="main"><span>&gt;</span></span><span> </span><span class="main"><span>0</span></span><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>lemmas</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.pre_perm_defs|fact"><span class="entity_def" id="RecursiveVDM.pre_perm_defs(3)|thm"><span class="entity_def" id="RecursiveVDM.pre_perm_defs(2)|thm"><span class="entity_def" id="RecursiveVDM.pre_perm_defs(1)|thm"><span>pre_perm_defs</span></span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_perm_def|fact"><span>pre_perm_def</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMInt_def|fact"><span>inv_VDMInt_def</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_True_def|fact"><span>inv_True_def</span></a><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_pre_perm_trivial|fact"><span class="entity_def" id="RecursiveVDM.l_pre_perm_trivial|thm"><span>l_pre_perm_trivial</span></span></span><span class="main"><span>[</span></span><span class="operator"><span>simp</span></span><span class="main"><span>]</span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>(</span></span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_perm|const"><span>pre_perm</span></a><span> </span><span class="free"><span>m</span></span><span> </span><span class="free"><span>n</span></span><span> </span><span class="free"><span>r</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="main"><span>0</span></span><span> </span><span class="main"><span>&lt;</span></span><span> </span><span class="free"><span>r</span></span><span> </span><span class="main"><span>‚à®</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="main"><span>&lt;</span></span><span> </span><span class="free"><span>n</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚ü∂</span></span><span> </span><span class="free"><span>m</span></span><span class="main"><span>+</span></span><span class="free"><span>n</span></span><span class="main"><span>+</span></span><span class="free"><span>r</span></span><span> </span><span class="main"><span>&gt;</span></span><span> </span><span class="main"><span>0</span></span><span class="main"><span>)</span></span><span>"</span></span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_perm_def|fact"><span>pre_perm_def</span></a><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_VDMInt_def|fact"><span>inv_VDMInt_def</span></a><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>simp</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.perm.domintros|fact"><span class="entity_def" id="RecursiveVDM.perm.pelims|fact"><span class="entity_def" id="RecursiveVDM.perm.cases|fact"><span class="entity_def" id="RecursiveVDM.perm.termination|fact"><span class="entity_def" id="RecursiveVDM.perm.pinduct|fact"><span class="entity_def" id="RecursiveVDM.perm.psimps|fact"><span class="entity_def" id="RecursiveVDM.perm_rel.inducts|fact"><span class="entity_def" id="RecursiveVDM.perm_rel.simps|fact"><span class="entity_def" id="RecursiveVDM.perm_rel.induct|fact"><span class="entity_def" id="RecursiveVDM.perm_rel.cases|fact"><span class="entity_def" id="RecursiveVDM.perm_rel.intros|fact"><span class="entity_def" id="RecursiveVDM.perm_graph.inducts|fact"><span class="entity_def" id="RecursiveVDM.perm_graph.simps|fact"><span class="entity_def" id="RecursiveVDM.perm_graph.induct|fact"><span class="entity_def" id="RecursiveVDM.perm_graph.cases|fact"><span class="entity_def" id="RecursiveVDM.perm_graph.intros|fact"><span class="entity_def" id="RecursiveVDM.perm.domintros|thm"><span class="entity_def" id="RecursiveVDM.perm.pelims|thm"><span class="entity_def" id="RecursiveVDM.perm.cases|thm"><span class="entity_def" id="RecursiveVDM.perm.termination|thm"><span class="entity_def" id="RecursiveVDM.perm.pinduct|thm"><span class="entity_def" id="RecursiveVDM.perm.psimps|thm"><span class="entity_def" id="RecursiveVDM.perm_rel.inducts|thm"><span class="entity_def" id="RecursiveVDM.perm_rel.simps|thm"><span class="entity_def" id="RecursiveVDM.perm_rel.induct|thm"><span class="entity_def" id="RecursiveVDM.perm_rel.cases|thm"><span class="entity_def" id="RecursiveVDM.perm_rel.intros(2)|thm"><span class="entity_def" id="RecursiveVDM.perm_rel.intros(1)|thm"><span class="entity_def" id="RecursiveVDM.perm_graph.inducts|thm"><span class="entity_def" id="RecursiveVDM.perm_graph.simps|thm"><span class="entity_def" id="RecursiveVDM.perm_graph.induct|thm"><span class="entity_def" id="RecursiveVDM.perm_graph.cases|thm"><span class="entity_def" id="RecursiveVDM.perm_graph.intros|thm"><span class="entity_def" id="RecursiveVDM.perm_def|axiom"><span class="entity_def" id="RecursiveVDM.perm_rel_def|axiom"><span class="entity_def" id="RecursiveVDM.perm_sumC_def|axiom"><span class="entity_def" id="RecursiveVDM.perm_graph_def|axiom"><span class="entity_def" id="RecursiveVDM.perm_dom|const"><span class="entity_def" id="RecursiveVDM.perm_rel|const"><span class="entity_def" id="RecursiveVDM.perm_sumC|const"><span class="entity_def" id="RecursiveVDM.perm_graph|const"><span>function</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span>domintros</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.perm|const"><span>perm</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMInt|type"><span>VDMInt</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMInt|type"><span>VDMInt</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMInt|type"><span>VDMInt</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMInt|type"><span>VDMInt</span></a><span>‚Ä∫</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>perm</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>r</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>if</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_perm|const"><span>pre_perm</span></a><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>r</span></span></span></span><span> </span><span class="keyword1"><span>then</span></span><span>
                         </span><span class="keyword1"><span>if</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="main"><span>&lt;</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>r</span></span></span></span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span class="free"><span>perm</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>r</span></span></span></span><span class="main"><span>-</span></span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> 
                    </span><span class="keyword1"><span>else</span></span><span> </span><span class="keyword1"><span>if</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="main"><span>&lt;</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span class="free"><span>perm</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>r</span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>n</span></span></span></span><span class="main"><span>-</span></span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span> </span><span class="keyword1"><span>else</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>m</span></span></span></span><span>
                 </span><span class="keyword1"><span>else</span></span><span> </span><span>undefined</span><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>pat_completeness</span></span><span class="main"><span class="keyword3"><span>,</span></span></span><span> </span><span class="operator"><span>auto</span></span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>perm_wf_rel :: ‚Äπ((VDMInt √ó VDMInt √ó VDMInt) √ó (VDMInt √ó VDMInt √ó VDMInt)) VDMSet‚Ä∫
  where</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.perm_wf_rel_def|fact"><span class="entity_def" id="RecursiveVDM.perm_wf_rel_def|thm"><span class="entity_def" id="RecursiveVDM.perm_wf_rel_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span class="entity_def" id="RecursiveVDM.perm_wf_rel|const"><span>perm_wf_rel</span></span></span><span> </span><span class="main"><span>‚â°</span></span><span> 
   </span><span class="main"><span>{</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="bound"><span>m</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>r</span></span><span class="main"><span>-</span></span><span class="main"><span>1</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>n</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="bound"><span>m</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>n</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>r</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>|</span></span><span> </span><span class="bound"><span>m</span></span><span> </span><span class="bound"><span>r</span></span><span> </span><span class="bound"><span>n</span></span><span> </span><span class="main"><span>.</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_perm|const"><span>pre_perm</span></a><span> </span><span class="bound"><span>m</span></span><span> </span><span class="bound"><span>n</span></span><span> </span><span class="bound"><span>r</span></span><span> </span><span class="main"><span>‚àß</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="main"><span>&lt;</span></span><span> </span><span class="bound"><span>r</span></span><span> </span><span class="main"><span>}</span></span><span> </span><span class="main"><span>‚à™</span></span><span> 
   </span><span class="main"><span>{</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="bound"><span>r</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>n</span></span><span class="main"><span>-</span></span><span class="main"><span>1</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>m</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="bound"><span>m</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>n</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>r</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>|</span></span><span> </span><span class="bound"><span>m</span></span><span> </span><span class="bound"><span>r</span></span><span> </span><span class="bound"><span>n</span></span><span> </span><span class="main"><span>.</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_perm|const"><span>pre_perm</span></a><span> </span><span class="bound"><span>m</span></span><span> </span><span class="bound"><span>n</span></span><span> </span><span class="bound"><span>r</span></span><span> </span><span class="main"><span>‚àß</span></span><span> </span><span class="main"><span>¬¨</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="main"><span>&lt;</span></span><span> </span><span class="bound"><span>r</span></span><span> </span><span class="main"><span>‚àß</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="main"><span>&lt;</span></span><span> </span><span class="bound"><span>n</span></span><span> </span><span class="main"><span>}</span></span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Its measure relation contains elements for each recursive call, 
</span><span>filtered for the corresponding if-then case. The proof of well-formedness of 
</span><span>such measure relations involving multiple recursive calls require further 
</span><span>proof engineering, which is stated with the next lemma.</span><span>‚Ä∫</span></span></span><span> 

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_perm_wf_rel_VDM_measure|fact"><span class="entity_def" id="RecursiveVDM.l_perm_wf_rel_VDM_measure|thm"><span>l_perm_wf_rel_VDM_measure</span></span></span><span class="main"><span>:</span></span><span> 
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.perm_wf_rel|const"><span>perm_wf_rel</span></a><span> </span><span class="main"><span>‚äÜ</span></span><span> </span><span>measure</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>Œª</span></span><span> </span><span class="main"><span>(</span></span><span class="bound"><span>m</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>r</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>n</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>.</span></span><span> </span><span>nat</span><span> </span><span class="main"><span>(</span></span><span>max</span><span> </span><span class="main"><span>0</span></span><span> </span><span class="main"><span>(</span></span><span class="bound"><span>m</span></span><span class="main"><span>+</span></span><span class="bound"><span>r</span></span><span class="main"><span>+</span></span><span class="bound"><span>n</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>proof</span></span></span><span> </span><span class="operator"><span>-</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
   </span><span class="keyword3"><span class="command"><span>show</span></span></span><span> </span><span class="var"><span class="quoted"><span class="var"><span>?thesis</span></span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>intro</span></span><span> </span><span>subsetI</span><span class="main"><span class="keyword3"><span>,</span></span></span><span> </span><span class="operator"><span>case_tac</span></span><span> </span><span class="quoted"><span class="improper"><span>x</span></span></span><span class="main"><span>)</span></span><span>
    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.perm_wf_rel_def|fact"><span>perm_wf_rel_def</span></a><span> </span><span>case_prod_beta</span><span> </span><span>max_def</span><span class="main"><span>)</span></span><span>
    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>elim</span></span><span> </span><span>disjE</span><span> </span><span>conjE</span><span class="main"><span class="keyword3"><span>,</span></span></span><span> </span><span class="operator"><span>simp</span></span><span class="main"><span>)</span></span><span> 
     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>intro</span></span><span> </span><span>impI</span><span> </span><span>conjI</span><span class="main"><span class="keyword3"><span>,</span></span></span><span> </span><span class="operator"><span>simp_all</span></span><span class="main"><span>)</span></span><span>
    </span><span class="keyword1"><span class="command"><span>nitpick</span></span></span><span>
    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>done</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span>qed</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>The Isabelle </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‚Äπ</span><span>measure</span><span>‚Ä∫</span></span></span><span> function projects the inverse 
</span><span>image</span><span class="antiquoted"><span class="operator"><span>‚Åã</span></span><span class="plain_text"><span>‚Äπ</span><span>Inverse image is defined as </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span>[</span><span>display</span><span>] </span><span class="quoted"><span>inv_image</span></span><span class="antiquote"><span>}</span></span></span><span> or </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><span>inv_image_def</span><span class="antiquote"><span>}</span></span></span><span>.</span><span>‚Ä∫</span></span></span><span> 
</span><span>of a given function as the recursive measure relation. Here the VDM-defined measure
</span><span>is given as such measure function projection. This highlights to the VDM user 
</span><span>the relationship (and differences) between VDM and Isabelle recursive measures.</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_perm_wf_rel|fact"><span class="entity_def" id="RecursiveVDM.l_perm_wf_rel|thm"><span>l_perm_wf_rel</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span>wf</span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.perm_wf_rel|const"><span>perm_wf_rel</span></a><span>"</span></span></span><span> 
</span><span class="keyword1"><span class="command"><span>proof</span></span></span><span> </span><span class="operator"><span>-</span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>from</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.l_perm_wf_rel_VDM_measure|fact"><span>l_perm_wf_rel_VDM_measure</span></a><span> </span><span class="keyword3"><span class="command"><span>show</span></span></span><span> </span><span class="var"><span class="quoted"><span class="var"><span>?thesis</span></span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>rule</span></span><span> </span><span>wf_subset</span><span> </span><span class="main"><span class="main"><span>[</span></span></span><span class="operator"><span>OF</span></span><span> </span><span>wf_measure</span><span class="main"><span class="main"><span>]</span></span></span><span class="main"><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>qed</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>This enables us to establish </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.perm_wf_rel|const"><span>perm_wf_rel</span></a></span><span class="antiquote"><span>}</span></span></span><span> is well formed. The setup
</span><span>works here if the </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_perm|const"><span>pre_perm</span></a></span><span class="antiquote"><span>}</span></span></span><span> specifically curbs negative sums of parameters. 
</span><span>This was not immediately obvious. With the added precondition the termination proof 
</span><span>is discovered by </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>command</span></span><span> </span><span>sledgehammer</span><span class="antiquote"><span>}</span></span></span><span>.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.perm.elims|fact"><span class="entity_def" id="RecursiveVDM.perm.induct|fact"><span class="entity_def" id="RecursiveVDM.perm.simps|fact"><span class="entity_def" id="RecursiveVDM.perm.elims|thm"><span class="entity_def" id="RecursiveVDM.perm.induct|thm"><span class="entity_def" id="RecursiveVDM.perm.simps|thm"><span>termination</span></span></span></span></span></span></span></span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>relation</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.perm_wf_rel|const"><span>perm_wf_rel</span></a><span>‚Ä∫</span></span></span><span class="main"><span>)</span></span><span>
    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.l_perm_wf_rel|fact"><span>l_perm_wf_rel</span></a><span class="main"><span>)</span></span><span>
   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp_all</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.perm_wf_rel_def|fact"><span>perm_wf_rel_def</span></a><span class="main"><span>)</span></span><span>  
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>done</span></span></span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Finally, the Takeuchi's function, which contains both permutation and inner
</span><span>recursion is defined next, where the important part is the SCNP setup using multi-sets </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>cite</span></span><span> </span><span>KrausSCNP</span><span class="antiquote"><span>}</span></span></span><span>,
</span><span>given that ordered lexicographic products are not strong enough to capture these 
</span><span>type of recursion.</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.tak.pelims|fact"><span class="entity_def" id="RecursiveVDM.tak.cases|fact"><span class="entity_def" id="RecursiveVDM.tak.termination|fact"><span class="entity_def" id="RecursiveVDM.tak.pinduct|fact"><span class="entity_def" id="RecursiveVDM.tak.psimps|fact"><span class="entity_def" id="RecursiveVDM.tak_rel.inducts|fact"><span class="entity_def" id="RecursiveVDM.tak_rel.simps|fact"><span class="entity_def" id="RecursiveVDM.tak_rel.induct|fact"><span class="entity_def" id="RecursiveVDM.tak_rel.cases|fact"><span class="entity_def" id="RecursiveVDM.tak_rel.intros|fact"><span class="entity_def" id="RecursiveVDM.tak_graph.inducts|fact"><span class="entity_def" id="RecursiveVDM.tak_graph.simps|fact"><span class="entity_def" id="RecursiveVDM.tak_graph.induct|fact"><span class="entity_def" id="RecursiveVDM.tak_graph.cases|fact"><span class="entity_def" id="RecursiveVDM.tak_graph.intros|fact"><span class="entity_def" id="RecursiveVDM.tak.pelims|thm"><span class="entity_def" id="RecursiveVDM.tak.cases|thm"><span class="entity_def" id="RecursiveVDM.tak.termination|thm"><span class="entity_def" id="RecursiveVDM.tak.pinduct|thm"><span class="entity_def" id="RecursiveVDM.tak.psimps|thm"><span class="entity_def" id="RecursiveVDM.tak_rel.inducts|thm"><span class="entity_def" id="RecursiveVDM.tak_rel.simps|thm"><span class="entity_def" id="RecursiveVDM.tak_rel.induct|thm"><span class="entity_def" id="RecursiveVDM.tak_rel.cases|thm"><span class="entity_def" id="RecursiveVDM.tak_rel.intros(4)|thm"><span class="entity_def" id="RecursiveVDM.tak_rel.intros(3)|thm"><span class="entity_def" id="RecursiveVDM.tak_rel.intros(2)|thm"><span class="entity_def" id="RecursiveVDM.tak_rel.intros(1)|thm"><span class="entity_def" id="RecursiveVDM.tak_graph.inducts|thm"><span class="entity_def" id="RecursiveVDM.tak_graph.simps|thm"><span class="entity_def" id="RecursiveVDM.tak_graph.induct|thm"><span class="entity_def" id="RecursiveVDM.tak_graph.cases|thm"><span class="entity_def" id="RecursiveVDM.tak_graph.intros|thm"><span class="entity_def" id="RecursiveVDM.tak_def|axiom"><span class="entity_def" id="RecursiveVDM.tak_rel_def|axiom"><span class="entity_def" id="RecursiveVDM.tak_sumC_def|axiom"><span class="entity_def" id="RecursiveVDM.tak_graph_def|axiom"><span class="entity_def" id="RecursiveVDM.tak_dom|const"><span class="entity_def" id="RecursiveVDM.tak_rel|const"><span class="entity_def" id="RecursiveVDM.tak_sumC|const"><span class="entity_def" id="RecursiveVDM.tak_graph|const"><span>function</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> 
  </span><span class="entity"><span class="entity_def" id="RecursiveVDM.tak|const"><span>tak</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMInt|type"><span>VDMInt</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMInt|type"><span>VDMInt</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMInt|type"><span>VDMInt</span></a><span> </span><span class="main"><span>‚áí</span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.VDMInt|type"><span>VDMInt</span></a><span>"</span></span></span><span> 
  </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
  </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>tak</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>x</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>y</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>z</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>if</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>x</span></span></span></span><span> </span><span class="main"><span>‚â§</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>y</span></span></span></span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>y</span></span></span></span><span> </span><span class="keyword1"><span>else</span></span><span> </span><span class="free"><span>tak</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>tak</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>x</span></span></span></span><span class="main"><span>-</span></span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>y</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>z</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>tak</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>y</span></span></span></span><span class="main"><span>-</span></span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>z</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>x</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>tak</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span class="bound"><span class="entity"><span>z</span></span></span></span><span class="main"><span>-</span></span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>x</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>y</span></span></span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>auto</span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>&lt;</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.tak_pcorrect|fact"><span class="entity_def" id="RecursiveVDM.tak_pcorrect|thm"><span>tak_pcorrect</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_dom|const"><span>tak_dom</span></a><span> </span><span class="main"><span>(</span></span><span class="free"><span>x</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>y</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>z</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚üπ</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak|const"><span>tak</span></a><span> </span><span class="free"><span>x</span></span><span> </span><span class="free"><span>y</span></span><span> </span><span class="free"><span>z</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>if</span></span><span> </span><span class="free"><span>x</span></span><span> </span><span class="main"><span>‚â§</span></span><span> </span><span class="free"><span>y</span></span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span class="free"><span>y</span></span><span> </span><span class="keyword1"><span>else</span></span><span> </span><span class="keyword1"><span>if</span></span><span> </span><span class="free"><span>y</span></span><span> </span><span class="main"><span>‚â§</span></span><span> </span><span class="free"><span>z</span></span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span class="free"><span>z</span></span><span> </span><span class="keyword1"><span>else</span></span><span> </span><span class="free"><span>x</span></span><span class="main"><span>)</span></span><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>thm</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak.pinduct|fact"><span>tak.pinduct</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak.psimps|fact"><span>tak.psimps</span></a><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>induction</span></span><span> </span><span class="quoted"><span class="free"><span>x</span></span></span><span> </span><span class="quoted"><span class="free"><span>y</span></span></span><span> </span><span class="quoted"><span class="free"><span>z</span></span></span><span> </span><span class="quasi_keyword"><span>rule</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak.pinduct|fact"><span>tak.pinduct</span></a><span class="main"><span>)</span></span><span> 
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak.psimps|fact"><span>tak.psimps</span></a><span class="main"><span>)</span></span><span>
</span><span class="comment1"><span>(</span><span>*</span><span>&gt;</span><span>*</span><span>)</span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Each case (including non-recursive call) is represented in the SCNP setup, and then
</span><span>their measure-lexicographic</span><span class="antiquoted"><span class="operator"><span>‚Åã</span></span><span class="plain_text"><span>‚Äπ</span><span>The measure-lexicographic product is represented as the 
</span><span>inverse image of the lexicographic product defined as </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><span>mlex_prod_def</span><span class="antiquote"><span>}</span></span></span><span>.</span><span>‚Ä∫</span></span></span><span> 
</span><span>composition is used as the measure relation for the termination proof.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.tak_m1_def|fact"><span class="entity_def" id="RecursiveVDM.tak_m1_def|thm"><span class="entity_def" id="RecursiveVDM.tak_m1_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.tak_m1|const"><span>tak_m1</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>tak_m1</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>Œª</span></span><span class="main"><span>(</span></span><span class="bound"><span>x</span></span><span class="main"><span>,</span></span><span class="bound"><span>y</span></span><span class="main"><span>,</span></span><span class="bound"><span>z</span></span><span class="main"><span>)</span></span><span class="main"><span>.</span></span><span> </span><span class="keyword1"><span>if</span></span><span> </span><span class="bound"><span>x</span></span><span> </span><span class="main"><span>‚â§</span></span><span> </span><span class="bound"><span>y</span></span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span class="main"><span>0</span></span><span> </span><span class="keyword1"><span>else</span></span><span> </span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span>"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.tak_m2_def|fact"><span class="entity_def" id="RecursiveVDM.tak_m2_def|thm"><span class="entity_def" id="RecursiveVDM.tak_m2_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.tak_m2|const"><span>tak_m2</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>tak_m2</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>Œª</span></span><span class="main"><span>(</span></span><span class="bound"><span>x</span></span><span class="main"><span>,</span></span><span class="bound"><span>y</span></span><span class="main"><span>,</span></span><span class="bound"><span>z</span></span><span class="main"><span>)</span></span><span class="main"><span>.</span></span><span> </span><span>nat</span><span> </span><span class="main"><span>(</span></span><span>Max</span><span> </span><span class="main"><span>{</span></span><span class="bound"><span>x</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>y</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>z</span></span><span class="main"><span>}</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span>Min</span><span> </span><span class="main"><span>{</span></span><span class="bound"><span>x</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>y</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>z</span></span><span class="main"><span>}</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.tak_m3_def|fact"><span class="entity_def" id="RecursiveVDM.tak_m3_def|thm"><span class="entity_def" id="RecursiveVDM.tak_m3_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="RecursiveVDM.tak_m3|const"><span>tak_m3</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>tak_m3</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>Œª</span></span><span class="main"><span>(</span></span><span class="bound"><span>x</span></span><span class="main"><span>,</span></span><span class="bound"><span>y</span></span><span class="main"><span>,</span></span><span class="bound"><span>z</span></span><span class="main"><span>)</span></span><span class="main"><span>.</span></span><span> </span><span>nat</span><span> </span><span class="main"><span>(</span></span><span class="bound"><span>x</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span>Min</span><span> </span><span class="main"><span>{</span></span><span class="bound"><span>x</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>y</span></span><span class="main"><span>,</span></span><span> </span><span class="bound"><span>z</span></span><span class="main"><span>}</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>"</span></span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>&lt;</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="free"><span>x1</span></span><span class="main"><span>,</span></span><span class="free"><span>y1</span></span><span class="main"><span>,</span></span><span class="free"><span>z1</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span class="main"><span>(</span></span><span class="free"><span>x2</span></span><span class="main"><span>,</span></span><span class="free"><span>y2</span></span><span class="main"><span>,</span></span><span class="free"><span>z2</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m3|const"><span>tak_m3</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><span class="main"><span>{}</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚ü∑</span></span><span> </span><span class="main"><span>(</span></span><span>nat</span><span> </span><span class="main"><span>(</span></span><span class="free"><span>x1</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span>Min</span><span> </span><span class="main"><span>{</span></span><span class="free"><span>x1</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>y1</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>z1</span></span><span class="main"><span>}</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>&lt;</span></span><span> </span><span>nat</span><span> </span><span class="main"><span>(</span></span><span class="free"><span>x2</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span>Min</span><span> </span><span class="main"><span>{</span></span><span class="free"><span>x2</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>y2</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>z2</span></span><span class="main"><span>}</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>mlex_iff</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m3_def|fact"><span>tak_m3_def</span></a><span>
  </span><span class="comment1"><span>(</span><span>*</span><span>apply (simp only: case_prod_beta fst_conv snd_conv) </span><span>*</span><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="operator"><span>simp</span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="free"><span>x1</span></span><span class="main"><span>,</span></span><span class="free"><span>y1</span></span><span class="main"><span>,</span></span><span class="free"><span>z1</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span class="main"><span>(</span></span><span class="free"><span>x2</span></span><span class="main"><span>,</span></span><span class="free"><span>y2</span></span><span class="main"><span>,</span></span><span class="free"><span>z2</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m2|const"><span>tak_m2</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m3|const"><span>tak_m3</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><span class="main"><span>{}</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>mlex_iff</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m3_def|fact"><span>tak_m3_def</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m2_def|fact"><span>tak_m2_def</span></a><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>only</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>case_prod_beta</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span class="main"><span class="keyword3"><span>,</span></span></span><span> </span><span class="operator"><span>clarify</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>oops</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_call1|fact"><span class="entity_def" id="RecursiveVDM.l_call1|thm"><span>l_call1</span></span></span><span class="main"><span>:</span></span><span> 
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>x</span></span><span> </span><span class="main"><span>&gt;</span></span><span> </span><span class="free"><span>y</span></span><span> </span><span class="main"><span>‚üπ</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="free"><span>x</span></span><span class="main"><span>-</span></span><span class="main"><span>1</span></span><span class="main"><span>,</span></span><span class="free"><span>y</span></span><span class="main"><span>,</span></span><span class="free"><span>z</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span class="main"><span>(</span></span><span class="free"><span>x</span></span><span class="main"><span>,</span></span><span class="free"><span>y</span></span><span class="main"><span>,</span></span><span class="free"><span>z</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m1|const"><span>tak_m1</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m2|const"><span>tak_m2</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m3|const"><span>tak_m3</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><span class="main"><span>{}</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span> 
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>mlex_iff</span><span class="main"><span>)</span></span><span>  </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m3_def|fact"><span>tak_m3_def</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m2_def|fact"><span>tak_m2_def</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m1_def|fact"><span>tak_m1_def</span></a><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>case_prod_beta</span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><span>min_def</span><span> </span><span>max_def</span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp_all</span></span><span> </span><span class="quasi_keyword"><span>split</span></span><span class="main"><span class="main"><span>:</span></span></span><span>if_splits</span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_call2|fact"><span class="entity_def" id="RecursiveVDM.l_call2|thm"><span>l_call2</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>x</span></span><span> </span><span class="main"><span>&gt;</span></span><span> </span><span class="free"><span>y</span></span><span> </span><span class="main"><span>‚üπ</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="free"><span>y</span></span><span class="main"><span>-</span></span><span class="main"><span>1</span></span><span class="main"><span>,</span></span><span class="free"><span>z</span></span><span class="main"><span>,</span></span><span class="free"><span>x</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span class="main"><span>(</span></span><span class="free"><span>x</span></span><span class="main"><span>,</span></span><span class="free"><span>y</span></span><span class="main"><span>,</span></span><span class="free"><span>z</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m1|const"><span>tak_m1</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m2|const"><span>tak_m2</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m3|const"><span>tak_m3</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><span class="main"><span>{}</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>mlex_iff</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m3_def|fact"><span>tak_m3_def</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m2_def|fact"><span>tak_m2_def</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m1_def|fact"><span>tak_m1_def</span></a><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>case_prod_beta</span><span class="main"><span>)</span></span><span>
  
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_call3|fact"><span class="entity_def" id="RecursiveVDM.l_call3|thm"><span>l_call3</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>x</span></span><span> </span><span class="main"><span>&gt;</span></span><span> </span><span class="free"><span>y</span></span><span> </span><span class="main"><span>‚üπ</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="free"><span>z</span></span><span class="main"><span>-</span></span><span class="main"><span>1</span></span><span class="main"><span>,</span></span><span class="free"><span>x</span></span><span class="main"><span>,</span></span><span class="free"><span>y</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span class="main"><span>(</span></span><span class="free"><span>x</span></span><span class="main"><span>,</span></span><span class="free"><span>y</span></span><span class="main"><span>,</span></span><span class="free"><span>z</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚àà</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m1|const"><span>tak_m1</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m2|const"><span>tak_m2</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m3|const"><span>tak_m3</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><span class="main"><span>{}</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>mlex_iff</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m3_def|fact"><span>tak_m3_def</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m2_def|fact"><span>tak_m2_def</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m1_def|fact"><span>tak_m1_def</span></a><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>case_prod_beta</span><span class="main"><span>)</span></span><span>
  
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_call4|fact"><span class="entity_def" id="RecursiveVDM.l_call4|thm"><span>l_call4</span></span></span><span class="main"><span>:</span></span><span>
  </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="free"><span>x</span></span><span> </span><span class="main"><span>&gt;</span></span><span class="free"><span>y</span></span><span> </span><span class="main"><span>‚üπ</span></span><span>  </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_dom|const"><span>tak_dom</span></a><span> </span><span class="main"><span>(</span></span><span class="free"><span>z</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>1</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>x</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>y</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚üπ</span></span><span>
       </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_dom|const"><span>tak_dom</span></a><span> </span><span class="main"><span>(</span></span><span class="free"><span>y</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>1</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>z</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>x</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚üπ</span></span><span>
       </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_dom|const"><span>tak_dom</span></a><span> </span><span class="main"><span>(</span></span><span class="free"><span>x</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>1</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>y</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>z</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>‚üπ</span></span><span>
       </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak|const"><span>tak</span></a><span> </span><span class="main"><span>(</span></span><span class="free"><span>x</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="free"><span>y</span></span><span> </span><span class="free"><span>z</span></span><span class="main"><span>,</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak|const"><span>tak</span></a><span> </span><span class="main"><span>(</span></span><span class="free"><span>y</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="free"><span>z</span></span><span> </span><span class="free"><span>x</span></span><span class="main"><span>,</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak|const"><span>tak</span></a><span> </span><span class="main"><span>(</span></span><span class="free"><span>z</span></span><span> </span><span class="main"><span>-</span></span><span> </span><span class="main"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="free"><span>x</span></span><span> </span><span class="free"><span>y</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>x</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>y</span></span><span class="main"><span>,</span></span><span> </span><span class="free"><span>z</span></span><span class="main"><span>)</span></span><span>
       </span><span class="main"><span>‚àà</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m1|const"><span>tak_m1</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m2|const"><span>tak_m2</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m3|const"><span>tak_m3</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><span class="main"><span>{}</span></span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>mlex_iff</span><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_pcorrect|fact"><span>tak_pcorrect</span></a><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>unfolding</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m3_def|fact"><span>tak_m3_def</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m2_def|fact"><span>tak_m2_def</span></a><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m1_def|fact"><span>tak_m1_def</span></a><span> 
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>case_prod_beta</span><span class="main"><span>)</span></span><span>
</span><span class="comment1"><span>(</span><span>*</span><span>&gt;</span><span>*</span><span>)</span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>The termination proof uses the measure relation </span><span class="antiquoted"><span class="antiquote"><span>@{</span></span><span class="operator"><span>term</span></span><span> </span><span class="quoted"><span>‚Äπ</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m1|const"><span>tak_m1</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m2|const"><span>tak_m2</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m3|const"><span>tak_m3</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><span class="main"><span>{}</span></span><span>‚Ä∫</span></span><span class="antiquote"><span>}</span></span></span><span>.
</span><span>  It requires user-defined lemmas for each of the four cases.</span><span>‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="entity_def" id="RecursiveVDM.tak.elims|fact"><span class="entity_def" id="RecursiveVDM.tak.induct|fact"><span class="entity_def" id="RecursiveVDM.tak.simps|fact"><span class="entity_def" id="RecursiveVDM.tak.elims|thm"><span class="entity_def" id="RecursiveVDM.tak.induct|thm"><span class="entity_def" id="RecursiveVDM.tak.simps|thm"><span>termination</span></span></span></span></span></span></span></span></span><span> </span><span class="comment1"><span>‚úê</span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>relation</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m1|const"><span>tak_m1</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m2|const"><span>tak_m2</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak_m3|const"><span>tak_m3</span></a><span> </span><span class="keyword1"><span>&lt;*mlex*&gt;</span></span><span> </span><span class="main"><span>{}</span></span><span>"</span></span></span><span class="main"><span>)</span></span><span> 
      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>wf_mlex</span><span class="main"><span>)</span></span><span> 
     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.l_call1|fact"><span>l_call1</span></a><span class="main"><span>)</span></span><span>
     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.l_call2|fact"><span>l_call2</span></a><span class="main"><span>)</span></span><span>
     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.l_call3|fact"><span>l_call3</span></a><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.l_call4|fact"><span>l_call4</span></a><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>After the termination proof, the total version of induction and simplification 
</span><span>rules are available. Then, it is possible to prove its rather simpler equivalence.</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>theorem</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.tak_correct|fact"><span class="entity_def" id="RecursiveVDM.tak_correct|thm"><span>tak_correct</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak|const"><span>tak</span></a><span> </span><span class="free"><span>x</span></span><span> </span><span class="free"><span>y</span></span><span> </span><span class="free"><span>z</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>if</span></span><span> </span><span class="free"><span>x</span></span><span> </span><span class="main"><span>‚â§</span></span><span> </span><span class="free"><span>y</span></span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span class="free"><span>y</span></span><span> </span><span class="keyword1"><span>else</span></span><span> </span><span class="keyword1"><span>if</span></span><span> </span><span class="free"><span>y</span></span><span> </span><span class="main"><span>‚â§</span></span><span> </span><span class="free"><span>z</span></span><span> </span><span class="keyword1"><span>then</span></span><span> </span><span class="free"><span>z</span></span><span> </span><span class="keyword1"><span>else</span></span><span> </span><span class="free"><span>x</span></span><span class="main"><span>)</span></span><span>"</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>induction</span></span><span> </span><span class="quoted"><span class="free"><span>x</span></span></span><span> </span><span class="quoted"><span class="free"><span>y</span></span></span><span> </span><span class="quoted"><span class="free"><span>z</span></span></span><span> </span><span class="quasi_keyword"><span>rule</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.tak.induct|fact"><span>tak.induct</span></a><span class="main"><span>)</span></span><span> </span><span class="operator"><span>auto</span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>************************************************************************************************</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>section</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Discussion and conclusion\label{sec:Conclusion}</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>In this paper we present a translation strategy from VDM to Isabelle
</span><span>for recursive function over basic types, sets and maps. We also present how 
</span><span>the strategy works for more complex recursion, such as the Ackermann's function.
</span><span>
</span><span>The complex recursion example also hints at possible VDM recursive measure extension
</span><span>to use a combination of measure relations and functions. The full VDM and Isabelle 
</span><span>sources and proofs can be found at the VDM toolkit repository 
</span><span>at </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚ÄπRecursiveVDM*.thy‚Ä∫</span></span></span><span class="antiquoted"><span class="operator"><span>‚Åã</span></span><span class="plain_text"><span>‚Äπ</span><span class="antiquoted"><span class="operator"><span>üåê</span></span><span>‚Äπhttps://github.com/leouk/VDM_Toolkit‚Ä∫</span></span><span>‚Ä∫</span></span></span><span>.</span><span>‚Ä∫</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>paragraph</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Future work.~We are implementing the translation strategy in the </span><span class="antiquoted"><span class="operator"><span>‚ñ©</span></span><span class="raw_text"><span>‚Äπvdm2isa‚Ä∫</span></span></span><span> plugin,
</span><span>which should be available soon. We also want to include mutually recursive VDM functions in future.</span><span>‚Ä∫</span></span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>&lt;</span><span>*</span><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="entity_def" id="RecursiveVDM.l_sumset_rel_wf&apos;|fact"><span class="entity_def" id="RecursiveVDM.l_sumset_rel_wf&apos;|thm"><span>l_sumset_rel_wf'</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>‚Äπ</span><span>wf</span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.sumset_wf_rel|const"><span>sumset_wf_rel</span></a><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>rule</span></span><span> </span><span>wf_measure</span><span class="main"><span class="main"><span>[</span></span></span><span class="operator"><span>of</span></span><span> </span><span class="quoted"><span class="quoted"><span class="quoted"><span>‚Äπ</span><span class="main"><span class="main"><span>Œª</span></span></span><span> </span><span class="bound"><span class="bound"><span>s</span></span></span><span> </span><span class="main"><span class="main"><span>.</span></span></span><span> </span><span>card</span><span> </span><span class="bound"><span class="bound"><span>s</span></span></span><span>‚Ä∫</span></span></span></span><span class="main"><span class="main"><span>,</span></span></span><span> </span><span class="operator"><span>THEN</span></span><span> </span><span>wf_subset</span><span class="main"><span class="main"><span>]</span></span></span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>measure_def</span><span> </span><span>inv_image_def</span><span> </span><span>less_than_def</span><span> </span><span>less_eq</span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>rule</span></span><span> </span><span>subsetI</span><span class="main"><span class="keyword3"><span>,</span></span></span><span> </span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span>case_prod_beta</span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command"><span>apply</span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>elim</span></span><span> </span><span>exE</span><span> </span><span>conjE</span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
  </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>metis</span></span><span> </span><span>card_Diff1_less_iff</span><span> </span><span>fst_conv</span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_Map_defs|fact"><span>inv_Map_defs</span></a><span class="main"><span class="main"><span>(</span></span></span><span>2</span><span class="main"><span class="main"><span>)</span></span></span><span> </span><a class="entity_ref" href="VDMToolkit.html#VDMToolkit.inv_Map_defs|fact"><span>inv_Map_defs</span></a><span class="main"><span class="main"><span>(</span></span></span><span>3</span><span class="main"><span class="main"><span>)</span></span></span><span> </span><a class="entity_ref" href="RecursiveVDM.html#RecursiveVDM.pre_sumset_defs|fact"><span>pre_sumset_defs</span></a><span class="main"><span class="main"><span>(</span></span></span><span>1</span><span class="main"><span class="main"><span>)</span></span></span><span> </span><span>snd_conv</span><span> </span><span>some_in_eq</span><span class="main"><span>)</span></span><span class="comment1"><span>‚úê</span><span class="quoted"><span>‚Äπ</span><span>tag</span><span> </span><span>invisible</span><span>‚Ä∫</span></span></span><span>
</span><span class="comment1"><span>(</span><span>*</span><span>&gt;</span><span>*</span><span>)</span></span><span>

</span><span class="keyword1"><span class="command"><span>paragraph</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>‚Äπ</span><span>Acknowledgements.~We appreciated discussions with Stephan Merz on 
</span><span>pointers for complex well-founded recursion proofs in Isabelle, and with Nick
</span><span>Battle on limits for VDM recursive measures.</span><span>‚Ä∫</span></span></span><span>

</span><span class="comment1"><span>(</span><span>*</span><span>&lt;</span><span>*</span><span>)</span></span><span>
</span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
</span><span class="comment1"><span>(</span><span>*</span><span>&gt;</span><span>*</span><span>)</span></span><span>
</span></pre>
</body>

</html>