module RecursiveVDMNat
exports all
definitions 
functions 
    ack: nat * nat -> nat 
    ack(m,n) ==
        --@Printf("ack(%1s, %2s): +=%3s, *=%4s, *'=%5s, £=%6s, $=%7s\n", 
        --          m, n, m+n, m*10+n, (m+2)*10-(n+1),
        --          if m = 0 then n else if n = 0 then m else m + n,
        --          if m >= n then (if n = 0 then m else n) else m)
        (if m = 0 then
            n+1
        else if n = 0 then
            --@Printf("\tack(%1s, %2s): n=0\n", m-1, 1)
            ack(m-1, 1)
        else 
            --@Printf("\tack(%1s, %2s): deep\n", m-1, ack(m, (n-1)))
            ack(m-1, ack(m, (n-1)))
        )
    measure 
        --@IsaMeasure( pair_less_VDMNat )
        --@doc where pair_less_VDMNat = lex_prod(less_than_VDMNat, less_than_VDMNat)
        --           less_than_VDMNat = transitive_closure({(z', z) | z' : int, z: int . 0 <= z' ∧ z' < z})
        --           lex_prod(ra,rb)  = { ((a,b), (a', b')) | a, b, 'a, b': int & (a,a') in set ra or a = a' and (b,b') in set rb}
        is not yet specified 
   ;

    --@doc see https://www21.in.tum.de/~krauss/papers/scnp-wst.pdf
   perm: int * int * int -> int --nat
   perm(m,n,r) == 
        --@Printf("perm(%1s, %2s, %3s)\n", m, n, r)
        if 0 < r then 
            perm(m, r-1, n) 
        else if 0 < n then 
            perm(r, n-1, m)
        else --if 0 <= m then 
            m
        --else 
            --0
    pre 
        m+n+r >= 0
    measure
        maxs({m+n+r, 0});      

    maxs: set1 of int -> int
	maxs(s) == 
		(iota m in set s & (forall n in set s & n <= m))
	post
		forall x in set s & x <= RESULT;

	mins: set1 of int -> int
	mins(s) == 
		(iota m in set s & (forall n in set s & m <= n))
	post
		forall x in set s & RESULT <= x;

    --@doc Takeuchi's function (from HOL/Examples/Functions.thy)
    tak: int * int * int -> int
    tak(x,y,z) == 
        --@Printf("tak(%1s, %2s, %3s)\n", x, y, z)
        if x <= y then
            y
        else    
            tak(tak(x-1,y,z), tak(y-1,z,x), tak(z-1,x,y))
    measure
        is not yet specified
    --    (if x <= y then y else if y <= z then z else x)
        -- if x <= y then 
        --     0 
        -- else if y <= z then 
        --     maxs({x,y,z}) - mins({x,y,z})
        -- else 
        --     x - mins({x,y,z})
    ;   
end RecursiveVDMNat