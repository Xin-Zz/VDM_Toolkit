module RecursiveVDMNat
exports all
definitions 
functions 
    ack: nat * nat -> nat 
    ack(m,n) ==
        --@Printf("ack(%1s, %2s): +=%3s, *=%4s, *'=%5s, Â£=%6s, $=%7s\n", 
        --          m, n, m+n, m*10+n, (m+2)*10-(n+1),
        --          if m = 0 then n else if n = 0 then m else m + n,
        --          if m >= n then (if n = 0 then m else n) else m)
        (if m = 0 then
            n+1
        else if n = 0 then
            --@Printf("\tack(%1s, %2s): n=0\n", m-1, 1)
            ack(m-1, 1)
        else 
            --@Printf("\tack(%1s, %2s): deep\n", m-1, ack(m, (n-1)))
            ack(m-1, ack(m, (n-1)))
        )
   ;

    --@doc see https://www21.in.tum.de/~krauss/papers/scnp-wst.pdf
   perm: int * int * int -> int
   perm(m,n,r) == 
        --@Printf("perm(%1s, %2s, %3s)\n", m, n, r)
        if 0 < r then 
            perm(m, r-1, n) 
        else if 0 < n then 
            perm(r, n-1, m)
        else
            m
    measure
        m+n+r;      

    maxs: set1 of int -> int
	maxs(s) == 
		(iota m in set s & (forall n in set s & n <= m))
	post
		forall x in set s & x <= RESULT;

	mins: set1 of int -> int
	mins(s) == 
		(iota m in set s & (forall n in set s & m <= n))
	post
		forall x in set s & RESULT <= x;

    --@doc Takeuchi's function (from HOL/Examples/Functions.thy)
    tak: int * int * int -> int
    tak(x,y,z) == 
        --@Printf("tak(%1s, %2s, %3s)\n", x, y, z)
        if x <= y then
            y
        else    
            tak(tak(x-1,y,z), tak(y-1,z,x), tak(z-1,x,y))
    --measure
    --    (if x <= y then y else if y <= z then z else x)
        -- if x <= y then 
        --     0 
        -- else if y <= z then 
        --     maxs({x,y,z}) - mins({x,y,z})
        -- else 
        --     x - mins({x,y,z})
    ;   
end RecursiveVDMNat