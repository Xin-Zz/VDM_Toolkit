delimiters "$", "$"

import "exp.stg"

// Isabelle theory template
theory(thy) ::= <<
(* VDM to Isabelle Translation @$thy.utc$  
   Copyright 2019-22, Leo Freitas, leo.freitas@newcastle.ac.uk
   
   $thy.comment; wrap$
   $thy.location; wrap$
*)
theory $thy.name$
imports VDMToolkit $listIt(thy.imports); wrap$
begin
$thy.body$
end 
>>

// Isabelle named claims with possible attribute 
// e.g. lemma XYZ[ATTRLIST]: EXPR; 
//TODO how to filter kind = {lemma, theorem, corollary}?
claim(clm) ::= <<
$commentIt(clm.comment)$
$clm.kind$ $clm.name$$attribute(clm.attr); wrap$:
    $innerSyntaxIt(clm.expr); wrap$  
>>

lemmas(lms) ::= <<
$commentIt(lms.comment)$
lemmas $defineIt(lms.name, listIt(lms.lemma), true)$
>>

// Isabelle type synonym and simple data type template
typedecl(tdecl) ::= <<
$commentIt(tdecl.comment)$
$tdecl.kind$ $defineIt(listIt(tdecl.name), innerSyntaxIt(listIt(tdecl.expr, " | ")), true)$
>>

record(rec) ::= <<
$commentIt(rec.comment)$
record $rec.name$ = 
    $rec.fields: { f | $signature(f)$ }; wrap, separator="\n"$
>>

// Isabelle abbreviation template 
// version with type:innerSyntaxIt() is confusing to me when multiple params?
abbreviation(abbrv) ::= <<
$commentIt(abbrv.comment)$
abbreviation 
    $signature(abbrv)$ where
    $innerSyntaxIt(defineIt(abbrv.name, abbrv.expr, false)); wrap$
>> 

// Isabelle definition template 
definition(def) ::= <<
$commentIt(def.comment)$
definition
    $signature(def)$ where
    $attributeIt(def.attr, innerSyntaxIt(defineIt(def.name, def.expr, def.eq))); wrap$
>>

fundef(fdef) ::= <<
$commentIt(fdef.comment)$
definition
    $signature(fdef)$ where
    $attributeIt(fdef.attr, innerSyntaxIt(fundefIt(fdef.name, fdef.expr, fdef.eq))); wrap$
>>

//TODO refactor some of these defs into inner templates
//don't attribute the pre_name_def, as user-defined one is likely to be different
rfundef(fdef) ::= <<
$commentIt(fdef.comment)$
declare $ndefIt("pre_", fdef.name, "_def")$ [simp]

fun (domintros) 
    $signature(fdef)$ where
    $attributeIt(fdef.attr, innerSyntaxIt(fundefIt(fdef.name, fdef.expr, true))); wrap$    

declare $ndefIt("pre_", fdef.name, "_def")$ [simp del]
>>


// Inner templates. 
//    * name can contain formal parameters; e.g. name = ["f", "x", "y"] for "f(x,y)"
//

// VDM function in Isabelle as (if pre_f_def then f)
fundefIt(name, expr, eq) ::= <<
    $listIt(name)$$if(eq)$ = $else$ \\<equiv> $endif$
        $ifexpIt(ndefIt("pre_", name), expr, "undefined"); wrap$
>>

// name definition expansion with prefix/suffix (if any)
ndefIt(prefix, name, suffix=" ") ::= <%$prefix$$first(name)$$suffix$%>

// Isabelle type signature as "name :: \\<open>type\\<close>"
signature(x) ::= <%$first(x.name)$ :: $innerSyntaxIt(x.type); wrap$%>

// Separate given list with given separator with ", " as default; ST can't have " " as default?!
listIt(l, sep=" ") ::= <%$l; separator=sep$%>

// Isabelle theorem attribute for given expression, if any, e.g. [simp,intro]
attribute(attr) ::= <%$if(attr)$ [$listIt(attr, ", ")$]  $endif$%>
attributeIt(attr, expr) ::= <%$if(attr)$ $attribute(attr)$: $endif$ $expr$%>

// Isabelle inner syntax brackets over given expression, e.g. \<open> EXPR \<close>
innerSyntaxIt(expr) ::= <%\\<open>$expr$\\<close>%>

// Isabelle named definitions as equality or equivalence 
// e.g., NAME = EXPR vs NAME == EXPR 
defineIt(name, expr, eq=false) ::= <%$listIt(name)$ $if(eq)$ = $else$ \\<equiv> $endif$$expr$%>

// Isabelle comment, if any
commentIt(cmt) ::= <%$if(cmt)$\\<comment>$innerSyntaxIt(cmt); wrap$$endif$%>