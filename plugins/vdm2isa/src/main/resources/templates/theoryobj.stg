delimiters "$", "$"

// Isabelle theory template
theory(thy) ::= <<
(* VDM to Isabelle Translation @$thy.utc$  
   Copyright 2019-22, Leo Freitas, leo.freitas@newcastle.ac.uk
   
   $thy.comment; wrap$
   $thy.location; wrap$
*)
theory $thy.name$
imports VDMToolkit $thy.imports$
begin
$thy.body$
end 
>>

// Isabelle type synonym template
typedecl(tdecl) ::= <<
$tdecl.kind$ $defineIt(listIt(tdecl.name, " "), innerSyntaxIt(listIt(tdecl.expr, " | ")), true)$
>>

recorddecl(rec) ::= <<
record $rec.name$ = 
    $rec.field.name$ : $innerSyntaxIt(listIt(rec.field.type, " ")); wrap; separator="\n"$
>>

//TODO how to pass lemma list for lemma? 
lemmas(lms) ::= <<
lemmas $defineIt(lms.name, listIt(lms.lemma, " "), true)$
>>

// Isabelle named claims with possible attribute 
// e.g. lemma XYZ[ATTRLIST]: EXPR; 
//TODO how to filter kind = {lemma, theorem, corollary}?
claim(clm) ::= <<
$clm.kind$ $clm.name$ $attribute(clm.attr); wrap$:
    $innerSyntaxIt(clm.expr); wrap$  
>>

// Isabelle abbreviation template 
// version with type:innerSyntaxIt() is confusing to me when multiple params?
abbreviation(abbrv) ::= <<
abbreviation 
    $abbrv.name$ :: $innerSyntaxIt(abbrv.type); wrap$ where
    $innerSyntaxIt(defineIt(abbrv.name, abbrv.expr, false)); wrap$
>> 

// Isabelle definition template 
definition(def) ::= <<
definition
    $def.name$ :: $innerSyntaxIt(def.type); wrap$ where
    $attributeIt(def.attr, innerSyntaxIt(defineIt(def.name, def.expr, def.eq))); wrap$
>>

// Isabelle theorem attribute for given expression, if any
// e.g. [simp, intro!]: EXPR 
listIt(l, sep=", ") ::= "$l; separator=sep$"
attribute(attr) ::= "$if(attr)$ [$listIt(attr)$] $endif$"
attributeIt(attr, expr) ::= "$if(attr)$ $attribute(attr)$: $endif$ $expr$"

// Isabelle inner syntax brackets over given expression
// e.g. \<open> EXPR \<close>
innerSyntaxIt(expr) ::= "\\<open>$expr$\\<close>"

// Isabelle named definitions as equality or equivalence 
// e.g., NAME = EXPR vs NAME == EXPR 
defineIt(name, expr, eq=false) ::= "$name$$if(eq)$ = $else$ \\<equiv> $endif$$expr$"

