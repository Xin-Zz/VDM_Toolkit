== Tell / show nick LSP looping 
	= add ExuExample to src/main/test/resources/
	= set experimental LSP server on
	= run experimental server (vdmignore being ignored for papers?)
	= loops + generates stuff inside pub? 

=== Tell nick about registry multiple copies? 
	= IsaPogcommand.getRegistry gives different ones? 

== SLIDE: exu style checker

* Originally a VDM style (extended) type checker in preparation for Isabelle translation
	* Traversal of VDM AST looking for specific constructs
	* Checks call dependencies per function (including pre/post/inv) per module
	* Checks duplicated pattern-kind use (e.g. f(mk_R(x), mk_R(y)))
	
* Currently operates on a extendable set of inner (git-style) commands
	* sort	: topologically sorts all module definitions to enforce declaration before use order 
	* graph : prints the dependency DAG between all definitions 
	* check : performs AST structural and call dependency checks 

== SLIDE: exu topological sort algorithm (2-3?)
	
-S1
1. Collect all named definitions
2. Process non-function (e.g. type) space dependencies recursively 
	- visits all type definitions
	– creates any missing inv_T calls, for all declared types T, recursively; 
	– link type and function spaces dependencies (e.g. invariant with aux. function);
3. Process function definition space dependencies recursively
	- visits all function bodies and specifications 
	– ignore recursive calls (VDMJ handles those); 
	– link function named dependencies;
4. Topological sort:
	– Checks whether topological sort is needed;
	– Kahn’s algorithm for DAG sorting of top-level names;

-S2
5. Module reconstruction:
	– Organise top-level names to separate type from function name-spaces; 
	– Reorder module definitions;
	– Optionally re-typechecks module;
	
* Discovered a case where module reordering gave different type checking results!

	- Ordered definitions lead to VSCode "red squiggles" type error!
	v0 = mk_(mk_(1,2), mk_(1,2));
	v1 = cases v0: mk_(mk_(x,y), mk_(y,z)), mk_(x, y, z) -> x+y+z end;
        
    - Unordered definition VSCode says nothing, VDMJ/DAP complains!
	v1 = cases v0: mk_(mk_(x,y), mk_(y,z)), mk_(x, y, z) -> x+y+z end;
    v0 = mk_(mk_(1,2), mk_(1,2));

-S3
* Algorithm properties and invariants
	* If sorted already sorted modules, algorithm degenerates
	* organised names must account for all original names and be within sorted names
		* original subset sorted and original = organised

* This extra check involves a further pass over AST, potentially leading to LSP lag
* In practice this is yet to manifest (e.g. we tested on FMI and EMV2 models)  
* 
=== SLIDE: exu
    
===================RECURSION TALK! 

* Wish list
	* completeness of VDM patterns to enable handling FMI models
	* including Isabelle/LSP back end IDE run in background to attempt proofs automatically
	* implement complex (and mutual) recursion templates (i.e. POC for now) 