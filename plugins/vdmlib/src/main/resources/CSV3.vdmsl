module CSV3
imports 
    from VDMUtil 
        functions 
            val2seq_of_char renamed val2seq_of_char;
    ,
    from IO
        operations 
            printf renamed printf;
exports 
    types
        struct String;
        struct String1;
        struct Path;
        struct FileStatus;
        struct Header;
        struct Headers0;
        struct Headers;
        struct Line;
        struct Col;
        struct Row;
        struct Rows;
        struct Data0;
        struct Data;
        struct CSVType;
        struct CSVTypeInv;
        struct CSVValue; 
        struct CSVParser;
    values 
        HEADER_INVARIANT_TRUE: CSVTypeInv;
        EMPTY_CSV: Data;
    functions 
        empty_csv            : Headers -> Data;
        file_status          : Path -> FileStatus;
        csv_read_data        : Path * CSVParser * Headers0 -> bool * Data0;
        csv_write_data       : Path * Data -> bool;
        csv_invariants_failed: Data0 -> set of (Line * Col);
    operations
        --@doc Loads CSV data from a given file with given parser back-end choice and
        --     specific headers. If trivial load, no invariants and just list of header types.
        --     Any IO (or VDM Value) erros can be shown if they occur.
        showError     : () ==> ();
        loadCSV       : Path * CSVParser * Headers0 ==> ();
        loadTrivialCSV: Path * CSVParser * seq1 of CSVType ==> ();
definitions
types
    String = seq of char;

    String1 = seq1 of char;

    --@doc this is treated specially by the native methods. It will be 
    --     sensitive to '/' (Linux) and '\' (Windows) path separators
    --     as well as absolute (/path) or relative (./path) files names. 
    Path = String1; 

    FileStatus = <Valid> | <DoesNotExist> | <CannotBeRead> | <CannotBeWritten> | <IsDirectory>; 

    --@todo any more types needed? @AB?
    CSVType = <Integer> | <Float> | <String>; 

    CSVValue = int | real | String;

    --@doc CSV parser IO back-end choices. Native is a variation of an implemention as a state 
    --     machine inspired online. Other implementations are linked below. They vary in clarity,
    --     speed, dependenecies, and variety of CSV formats. 
    --          Native    = https://stackoverflow.com/questions/6857248/fast-csv-parsing
    --          Apache    = https://commons.apache.org/proper/commons-csv/
    --          Univocity = https://github.com/uniVocity/univocity-parsers
    --          OpenCSV   = https://opencsv.sourceforge.net
    --          QuirkCSV  = https://github.com/bpoole6/quirk-csv
    --     
    --@todo is this too much? (i.e. many dependencies; presuming only <Native> for now)
    CSVParser = <Native> | <Apache> | <Univocity> | <OpenCSV> | <QuirkCSV>; 

    --@doc an invariant function that checks CSVValue against
    --     corresponding types.
    CSVTypeInv = CSVValue -> bool;

    --@doc each header contain a name, type and invariant.
    --     it represents a CSV column with (a "vertical") 
    --     invariant across all its rows for each column.  
    Header :: 
        name: [String1]
        type: CSVType
        invariant: CSVTypeInv;

    --@doc Raw header list representing expected types and
    --     their invariants (possibly empty), where names 
    --     might be file/data dependant (i.e. will come from)
    --     a native call.
    Headers0 = seq of Header;

    --@doc Final header, where names have been loaded from 
    --     native call. 
    Headers = Headers0
    inv h == h <> [] and (forall mk_Header(n, -, -) in set elems h & n <> nil);

    --@doc A CSV row corresponds to a sequence of CSVValue. 
    Row = seq of CSVValue;

    Rows = seq of Row;

    --@doc CSV line
    Line = nat1;

    --@doc CSV col
    --@todo perhaps have it as a Pos :: line: nat1 col: nat1;?
    Col = nat1;

    --@doc CSV data its raw headers and sequence of its rows
    --     (i.e. effectively the CSV matrix), as in:  
    --
    --       H1   |   H2   ... |   Hj
    -- R1  v(1,1) | v(1,2) ... | v(1,j)
    -- ...
    -- Ri  v(i,1) | v(i,2) ... | v(i,j)
    --
    Data0 :: 
        headers: Headers0
        --@todo do we need invariants per row? 
        rows   : Rows
    inv mk_Data0(h, r) == 
        --@doc if data is available, check that all headers have names
        (h <> [] => is_Headers(h))
        and
        line_col_size_consistency(h, r);
    
    Data = Data0 
    inv d ==
        csv_invariants_failed(d) = {}
        and
        --@doc bit expensive invariant check across the whole CSV data:
        --     for all rows d(i), check all header invariants h(j) for
        --     all cells d(i)(j)
        (forall i in set inds d.rows & 
              forall j in set inds d.headers &     
                  d.headers(j).invariant(d.rows(i)(j)));

values 
    HEADER_INVARIANT_TRUE: CSVTypeInv = (lambda -: CSVValue & true);
    EMPTY_CSV            : Data       = mk_Data0([], []);
    DEFAULT_HEADER_NAME  : String1    = "csvHeader";

functions 

    --@doc every row of data must match the expected header's length
    --     because headers might also be just names, have the @T for either
    line_col_size_consistency: Headers0 * Rows -> bool
    line_col_size_consistency(headers, rows) == 
        (forall i in set inds rows & len rows(i) = len headers);

    installed_read_headers_consistency: Headers0 * Headers -> bool 
    installed_read_headers_consistency(h, h') ==
        len h = len h' 
        and 
        --@doc headers are the same, except for the names
        (forall i in set inds h & 
            h(i).type = h'(i).type 
            and 
            --@Warning(5037) here just checking structural equality rather than computation.
            (h(i).invariant = h'(i).invariant)); 

    empty_csv: Headers -> Data
    empty_csv(headers) == mk_Data0(headers, []);
        
    --@doc checks the full path file status.
    file_status: Path -> FileStatus 
    file_status(path) == is not yet specified; 

    --@doc Reads CSV data. Usually header names are in the first line of the CSV file;
    --     empty names is allowed (i.e anonynous headers). Such headers can have invariants.
    --     Result is Data0, so that the invariants will be checked if no violations.
    --
    --     Actual CSV data comes next as a sequence of rows (i.e. CSV matrix parser).
    --     CSV parsing compliance is tricky, as there are many formats out there.
    --     e.g. https://commons.apache.org/proper/commons-csv/
    --     as well as many varied implementations (see CSVParser type).
    --
    --     We want a solution that is fast, so we checked options within  
    --     https://github.com/uniVocity/csv-parsers-comparison
    --
    --     We also want a solution with least dependencies, so were tempted with
    --     Iterable stand alone version in https://stackoverflow.com/questions/6857248/fast-csv-parsing  
    --
    --     Other useful features might be interesting, so we considered filterd CSV from
    --     https://stackoverflow.com/questions/61250600/univocity-csv-parser-skip-rows-based-on-conditions
    csv_read_data: Path * CSVParser * Headers0 -> bool * Data0
    csv_read_data(path, parser, headers) == is not yet specified
    pre file_status(path) = <Valid>
    post 
        --@doc if result is true, names size must be consistent for every row; otherwise, all empty
        (let mk_(b, data) = RESULT in
            if b then
                --@doc line/col consistency with respect to given headers
                --     (e.g. data.headers = headers + CSV header names).
                line_col_size_consistency(headers, data.rows) 
                and
                installed_read_headers_consistency(headers, data.headers)
            else 
                data.headers = [] and data.rows = []
        ); 

    csv_write_data: Path * Data -> bool
    csv_write_data(path, data) == is not yet specified
    pre file_status(path) in set {<Valid>, <DoesNotExist>};
    
    csv_invariants_failed: Data0 -> set of (Line * Col)
    csv_invariants_failed(mk_Data0(headers, rows)) == 
        --@doc For all lines (l) in the rows, check that each column (c) invariant 
        --     in the header holds, for every lement i in rows (e.g. each element of the row).
        --     Returns the set of line/column numbers where invariants are broken. 
        { 
            mk_(l, c) 
            |  
            l in set inds rows, c in set inds headers
            & 
            len rows(l) = len headers
            and
            --@doc for every row (l) and column (c), check the data values against
            --     the header's expected invariant to ensure the resulting CSV load
            --     is sound with respect to the defined Headers' invariants. 
            not headers(c).invariant(rows(l)(c))
        };

state CSV of 
    file    : [Path]
    parser  : CSVParser
    ferr    : [String1]
    headersI: Headers0
    data    : [Data]
inv mk_CSV(file, -, ferr, headersI, data) ==
        --@doc if there is an error, zero the information
        (ferr <> nil => data = nil)
        and 
        --@doc if file is set, must be valid
        (file <> nil => file_status(file) = <Valid>)
        and
        --@doc installed headers must be consistent with read headers.
        (data <> nil => installed_read_headers_consistency(headersI, data.headers))
init csv == 
        csv = mk_CSV(nil, <Native>, nil, [], nil)
end

operations 

    --@doc returns last IO error or nil if none.
    lastError: () ==> [String1]
    lastError() == is not yet specified;

    --@doc shows the error if the state registered it
    showError() ==
        (if ferr <> nil then 
            printf("CSV error %1s", [ferr]);
        )
    ext rd ferr;
    
    --@doc sets CSV file path and zeros data, registering/showing any IO error. 
    setCSVFile(path: Path, parserChoice: CSVParser) == 
        (atomic
            (file     := path;
             parser   := parserChoice;
             data     := nil;
             headersI := [];
             ferr     := lastError();
            );
         showError();
        )
    ext wr file, parser, headersI, data, ferr
    pre file_status(path) = <Valid>
    post file = path and file <> nil and parser = parserChoice and data = nil and headersI = [];

    installHeaders(invs: Headers0) ==
        (headersI := invs;
        )
    ext rd file, data wr headersI
    pre --@doc file must be loaded, but no data yet
        file <> nil and data = nil;

    loadData() == 
        (let mk_(ok, data') = csv_read_data(file, parser, headersI) in
            if ok then 
            (   --@doc check invariants using teh installed headers against read rows
                let lcs: set of (Line * Col) = csv_invariants_failed(mk_Data0(headersI, data'.rows)) in
                    if (lcs = {}) then
                    (
                        --@doc update the headers with names as well, if successful.
                        atomic (
                            data := data';
                            ferr := nil;
                        );
                    )
                    else
                    (
                        atomic (
                            data  := nil;
                            ferr  := "CSV invariant failure at cells \n\t" ^ 
                                val2seq_of_char[set of (Line * Col)](lcs);
                        );
                    )
            )
            else 
            (
                atomic (
                    data := nil;
                    ferr := lastError();
                );
                
            );
            showError();
        )
    ext rd file, parser, headersI wr data, ferr
    pre  --@doc both file and headers have been set. 
         file <> nil and headersI <> []
    post --@doc state type invariant will ensure csv_invariants_failed is empty.              
         (if ferr = nil then 
            data <> nil and 
            --@todo somewhat redundant given state invariant?
            (installed_read_headers_consistency(headersI, data.headers))
            and
            --@todo somewhat redundant given type invariant for Data0? 
            line_col_size_consistency(data.headers, data.rows)
          else 
             data = nil);  

    --@doc top-level call: given a file and typed headers (possibly with invariants)
    --     loads the CSV as part of the state
    --@todo this could also be part of a function returning Data? Then no state etc?
    loadCSV(path: Path, parserChoice: CSVParser, headersToInstall: Headers0) == 
        (
            if file_status(path) <> <Valid> then 
                showError()
            else 
            (
                setCSVFile(path, parserChoice);
                installHeaders(headersToInstall);
                loadData();
            );
        )
    ext wr CSV
    post post_loadData(CSV~, CSV);

    --@doc load file path with given headers and no invariants. 
    --     it insists on minimally knowking the header types. 
    loadTrivialCSV(path: Path, parserChoice: CSVParser, headerTypes: seq1 of CSVType) ==
        (
            let headers: Headers0 = 
                [ mk_Header(
                    DEFAULT_HEADER_NAME ^ val2seq_of_char[nat1](i), 
                    headerTypes(i), 
                    HEADER_INVARIANT_TRUE
                  ) 
                  | 
                  i in set inds headerTypes 
                ] 
            in 
                loadCSV(path, parserChoice, headers);
        )
    ext wr CSV 
    post post_loadData(CSV~, CSV);

end CSV3