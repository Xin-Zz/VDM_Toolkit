module CSV3
imports 
    from VDMUtil 
        functions 
            val2seq_of_char renamed val2seq_of_char;
    ,
    from IO
        operations 
            printf renamed printf;
exports 
    types
        struct String;
        struct String1;
        struct Path;
        struct FileStatus;
        struct Header0;
        struct Header;
        struct Headers0;
        struct Headers;
        struct Line;
        struct Col;
        struct Row;
        struct Matrix;
        struct Data0;
        struct Data;
        struct CSVType;
        struct CSVCellInv;
        struct CSVRowInv;
        struct CSVColInv;
        struct CSVValue; 
        struct CSVParser;
    values 
        HEADER_INVARIANT_TRUE: CSVCellInv;
        ROW_INVARIANT_TRUE   : CSVRowInv;
        COL_INVARIANT_TRUE   : CSVColInv;
        EMPTY_ROWS           : Matrix;
        EMPTY_CSV            : Data;
        DEFAULT_HEADER_NAME  : String1;
    functions 
        --@doc functions to process CSV data IO 
        file_status          : Path -> FileStatus;
        csv_read_data        : Path * CSVParser * Headers0 -> bool * Data0;
        csv_write_data       : Path * Data0 -> bool;
        --@doc functions on basic row and cell consistency
        row_consistency      : Headers0 * Row -> bool;
        csv_type_check       : CSVType * CSVValue -> bool;
        csv_default_value    : CSVType -> CSVValue;
        --@doc functions identifying (and purging) invalid line/columns
        csv_invariants_failed: Data0 -> set of (Line * Col);
        csv_filter_invalid   : Data0 -> Data;
        --@doc construction functions for empty and updated row invariant data
        empty_csv            : Headers0 -> Data;
        install_row_invariant: Data0 * CSVRowInv -> Data0;
    operations
        --@doc Loads CSV data from a given file with given parser back-end choice and
        --     specific headers. If trivial load, no invariants and just list of header types.
        --     Any IO (or VDM Value) erros can be shown if they occur.
        showError     : () ==> ();
        loadCSV       : Path * CSVParser * Headers0 * bool ==> ();
        loadTrivialCSV: Path * CSVParser * seq1 of CSVType * bool ==> ();
        printCSV      : Path ==> ();
definitions
types
    String = seq of char;

    String1 = seq1 of char;

    --@doc this is treated specially by the native methods. It will be 
    --     sensitive to '/' (Linux) and '\' (Windows) path separators
    --     as well as absolute (/path) or relative (./path) files names. 
    Path = String1; 

    FileStatus = <Valid> | <DoesNotExist> | <CannotBeRead> | <CannotBeWritten> | <IsDirectory>; 

    --@todo any more types needed? @AB?
    CSVType = <Integer> | <Float> | <String>; 

    CSVValue = int | real | String;

    --@doc CSV parser IO back-end choices. Native is a variation of an implemention as a state 
    --     machine inspired online. Other implementations are linked below. They vary in clarity,
    --     speed, dependenecies, and variety of CSV formats. 
    --          Native    = https://stackoverflow.com/questions/6857248/fast-csv-parsing
    --          Apache    = https://commons.apache.org/proper/commons-csv/
    --          Univocity = https://github.com/uniVocity/univocity-parsers
    --          OpenCSV   = https://opencsv.sourceforge.net
    --          QuirkCSV  = https://github.com/bpoole6/quirk-csv
    --     
    --@todo is this too much? (i.e. many dependencies; presuming only <Native> for now)
    CSVParser = <Native> | <Apache> | <Univocity> | <OpenCSV> | <QuirkCSV>; 

    --@doc CSV cell invariants. A function that checks CSVValue against corresponding type.
    --     minimal check is type agreement.
    CSVCellInv = (CSVType * CSVValue -> bool);

    --@doc CSV whole row invariant. A function that checks the row of values against all headers. 
    --     minimal check is size consistency between row and header (e.g. no short rows).
    --     A useful use case could be that value dependencies are enforced (e.g. weight+height+bmi)
    CSVRowInv = (Headers0 * Row -> bool);

    --@doc CSV whole col invariant. A function that checkls the column of values against a header. 
    --     there is no minimal check, given type agreement across column for all rows already happen at cell level.
    --     A useful use case could be ascending order of values
    --@doc The row parameter her corresponds to the transposed cells (i.e. column across all rows as a row).
    CSVColInv = (Header0 * TransposedRow -> bool);

    --@doc each header contain a name, type and invariant.
    --     it represents a CSV column with (a "vertical") 
    --     invariant (if any) across all its rows for each column (i.e. all cells).  
    Header0 :: 
        name: [String1]
        type: CSVType
        default: CSVValue
        cell_invariant: [CSVCellInv]
        col_invariant : [CSVColInv]
    inv mk_Header0(-, t, d, -, -) ==
        csv_type_check(t, d)
        --@doc no need for the cell invariant on the default
        --and (c <> nil => c(t, d))
        ;

    --@doc named header
    Header = Header0 
    inv mk_Header0(h, -, -, -, -) == h <> nil;

    --@doc Raw header list representing expected types and
    --     their invariants (possibly empty), where names 
    --     might be file/data dependant (i.e. will come from)
    --     a native call.
    Headers0 = seq of Header0;

    --@doc Final header, where names have been loaded from native call. 
    --Headers = Headers0
    --inv h == h <> [] and (forall mk_Header(n, -, -) in set elems h & n <> nil);
    Headers = seq1 of Header;

    --@doc a row is a sequence of values
    Row = seq of CSVValue;

    --@doc synonym for a column view over all rows. 
    TransposedRow = Row; 

    --@doc collection of CSV rows corresponds to a sequence of Row and a row invariant. 
    Matrix :: 
        cells: seq of Row
        invariant: [CSVRowInv];

    --@doc CSV line
    Line = nat1;

    --@doc CSV col
    Col = nat1;

    --@doc CSV data its raw headers and sequence of its rows
    --     (i.e. effectively the CSV matrix), as in:  
    --
    --       H1   |   H2   ... |   Hj
    -- R1  v(1,1) | v(1,2) ... | v(1,j)
    -- ...
    -- Ri  v(i,1) | v(i,2) ... | v(i,j)
    --
    Data0 :: 
        headers: Headers0
        matrix : Matrix
    inv mk_Data0(h, -) == 
        --@doc if data is available, check that all headers have names
        (h <> [] => is_Headers(h));
    
    Data = Data0 
    inv d ==
        --@doc bit expensive invariant check across the whole CSV data:
        --     for all rows d(i), check all header invariants h(j) for
        --     all cells d(i)(j)
        csv_invariants_failed(d) = {};

values 
    HEADER_INVARIANT_TRUE: CSVCellInv = (lambda t: CSVType, v: CSVValue & csv_type_check(t, v));
    ROW_INVARIANT_TRUE   : CSVRowInv  = (lambda h: Headers0, r: Row & row_consistency(h, r));
    COL_INVARIANT_TRUE   : CSVColInv  = (lambda h: Header, c: TransposedRow & col_consistency(h, c));
    EMPTY_ROWS           : Matrix       = mk_Matrix([], nil);
    EMPTY_CSV            : Data       = mk_Data0([], EMPTY_ROWS);
    DEFAULT_HEADER_NAME  : String1    = "CSVHeader";

functions 

    --@doc every row of data must match the expected header's length
    --     because headers might also be just names, have the @T for either
    line_col_size_consistency: Headers0 * Matrix -> bool
    line_col_size_consistency(headers, mk_Matrix(cells, -)) == 
        (forall i in set inds cells & row_consistency(headers, cells(i)));
        
    --@doc checks whether given row has the same sime as headers (e.g. no short rows) 
    row_consistency: Headers0 * Row -> bool 
    row_consistency(headers, row) ==
        len headers = len row; 

    --@doc checks all rows within the column has correct type across column
    --     somewhat redundant with the csv_type_check on cell invariant check,
    --     but could catch 
    col_consistency: Header0 * TransposedRow -> bool
    col_consistency(mk_Header0(-, t, -, -, -), col) ==
        true;--(forall i in set inds col & csv_type_check(t, col(i));

    --@doc checks installed (possibly nameless) headers match resulting headers
    --@private used by operations to ensure CSV IO header read doesn't change 
    --         user defined types and invariants     
    installed_read_headers_consistency: Headers0 * Headers -> bool 
    installed_read_headers_consistency(h, h') ==
        len h = len h' 
        and 
        --@doc headers are the same, except for the names
        (forall i in set inds h & 
            h(i).type = h'(i).type 
            and 
            --@Warning(5037) here just checking structural equality rather than computation.
            (h(i).cell_invariant = h'(i).cell_invariant)); 

    --@doc creates empty CSV data with expected headers
    empty_csv: Headers0 -> Data
    empty_csv(headers) == mk_Data0(headers, EMPTY_ROWS)
    post RESULT.headers = headers and RESULT.matrix.cells = [];
        
    --@doc checks the full path file status.
    file_status: Path -> FileStatus 
    file_status(path) == is not yet specified; 

    --@doc Reads CSV data. Usually header names are in the first line of the CSV file;
    --     empty names is allowed (i.e anonynous headers). Such headers can have invariants.
    --     Result is Data0, so that the invariants will be checked if no violations.
    --
    --     Actual CSV data comes next as a sequence of rows (i.e. CSV matrix parser).
    --     CSV parsing compliance is tricky, as there are many formats out there.
    --     e.g. https://commons.apache.org/proper/commons-csv/
    --     as well as many varied implementations (see CSVParser type).
    --
    --     We want a solution that is fast, so we checked options within  
    --     https://github.com/uniVocity/csv-parsers-comparison
    --
    --     We also want a solution with least dependencies, so were tempted with
    --     Iterable stand alone version in https://stackoverflow.com/questions/6857248/fast-csv-parsing  
    --
    --     Other useful features might be interesting, so we considered filterd CSV from
    --     https://stackoverflow.com/questions/61250600/univocity-csv-parser-skip-rows-based-on-conditions
    csv_read_data: Path * CSVParser * Headers0 -> bool * Data0
    csv_read_data(path, parser, headers) == is not yet specified
    pre file_status(path) = <Valid>
    post 
        --@doc if result is true, names size must be consistent for every row; otherwise, all empty
        (let mk_(b, mk_Data0(headers', matrix)) = RESULT in
            if b then
                --@doc line/col consistency with respect to given headers
                --     (e.g. data.headers = headers + CSV header names).
                line_col_size_consistency(headers, matrix) 
                and
                installed_read_headers_consistency(headers, headers')
            else 
                headers = [] and matrix = EMPTY_ROWS
        ); 

    --@doc prints the CSV data to the given file name; 
    --     this allows for print with invariant failures if not is_Data(data)
    csv_write_data: Path * Data0 -> bool
    csv_write_data(path, data) == is not yet specified
    pre file_status(path) in set {<Valid>, <DoesNotExist>}
    post (RESULT => file_status(path) = <Valid>);

    --@doc basic CSV types check against values
    csv_type_check: CSVType * CSVValue -> bool
    csv_type_check(t, v) == 
        cases t: 
            <Integer> -> is_int(v),
            <Float>   -> is_real(v),
            <String>  -> is_String(v),
            others    -> false 
        end;
    
    csv_default_value: CSVType -> CSVValue 
    csv_default_value(t) ==
        cases t: 
            <Integer> -> 0,
            <Float>   -> 0.0,
            <String>  -> "" 
        end;

    --@doc removes rows of invariant violating cells  
    --@todo update given col in
    csv_filter_invalid: Data0 -> Data
    csv_filter_invalid(data) == 
        --@doc avoid mk_Data0(...) on input checking invariant of Data0 at other places again
        let lcs: set of (Line * Col) = csv_invariants_failed(data) in
            --@doc same headers but filter rows where lines fail
            mk_Data0(
                data.headers,
                mk_Matrix(
                    [ data.matrix.cells(i) 
                    | 
                    i in set inds data.matrix.cells 
                    & 
                    not i in set { l | mk_(l, -) in set lcs }
                    ], 
                    data.matrix.invariant
                )
            ) 
    post data.headers = RESULT.headers 
         and 
         elems RESULT.matrix.cells subset elems data.matrix.cells
         --and
         --@doc already part of Data
         --csv_invariants_failed(RESULT) = {}
         ;

    --@doc changes the Data row invariant
    install_row_invariant: Data0 * CSVRowInv -> Data0
    install_row_invariant(mk_Data0(headers, mk_Matrix(cells, -)), invariant) == 
        mk_Data0(headers, mk_Matrix(cells, invariant));

    --@doc for given line checks the whole row is consistent 
    --     (i.e. no short rows wrt to header size) and invariant holds (if any)
    row_invariant_check: Headers0 * Matrix * Line -> bool
    row_invariant_check(headers, mk_Matrix(cells, invariant), line) ==
        row_consistency(headers, cells(line))
        and 
        (invariant <> nil => invariant(headers, cells(line)))
    pre line in set inds cells;

    col_invairant_check: Headers0 * Matrix * Col -> bool 
    col_invairant_check(headers, mk_Matrix(cells, -), col) == 
        let header: Header0       = headers(col),
            trow  : TransposedRow = [ cells(l)(col) | l in set inds cells ]
        in 
            (header.col_invariant <> nil => header.col_invariant(header, trow))
    pre col in set inds headers;

    --@doc for given line and column within row cells, check
    --     types confirm to declared header type and invariant holds (if any)
    cell_invariant_check: Headers0 * Matrix * Line * Col -> bool 
    cell_invariant_check(headers, mk_Matrix(cells, -), line, col) ==
        let type: CSVType  = headers(col).type, 
            cell: CSVValue = cells(line)(col)
        in
            csv_type_check(type, cell)
            and
            (headers(col).cell_invariant <> nil => headers(col).cell_invariant(type, cell))
    pre line in set inds cells 
        and 
        col in set inds headers 
        and 
        col in set inds cells(line)
        and
        --@todo redundant if not exporeted? or keep for intra-consistency?
        row_consistency(headers, cells(line));

    --@doc collects the Line/Col points where invariants failed. Useful for
    --     telling users where it went wrong; columns somewhat irrelevant for
    --     row filtering. 
    csv_invariants_failed: Data0 -> set of (Line * Col)
    csv_invariants_failed(mk_Data0(headers, matrix)) == 
        --@doc For all lines (l) in the rows, check that each column (c) invariant 
        --     in the header holds, for every lement i in rows (e.g. each element of the row).
        --     Returns the set of line/column numbers where invariants are broken. 
        --
        --@doc initially was creating the set directly, but then the logic of checking
        --     what failed became confusing, given the presence of nils, so decided this instead.
        let 
            all_cells: set of (Line * Col) = 
                { mk_(l, c) | l in set inds matrix.cells, c in set inds headers },
            checked_cells: set of (Line * Col) = 
                { mk_(l, c) | l in set inds matrix.cells, c in set inds headers
                  & 
                  row_invariant_check(headers, matrix, l)
                  and
                  col_invairant_check(headers, matrix, c)
                  and
                  cell_invariant_check(headers, matrix, l, c)
                }
        in
            all_cells \ checked_cells;
 
--@doc CSV state constains CSV file, which kind of CSV parser to use,
--     any computation (IO and other) erros, user-defined headers, and
--     read valid (invariant checked) CSV data.  
state CSV of 
    file    : [Path]
    parser  : CSVParser
    ferr    : [String1]
    strict  : bool
    pos     : set of (Line * Col)
    data    : Data0
inv mk_CSV(file, -, ferr, strict, pos, data) ==
        --@doc if there is an error, zero the information
        --(ferr <> nil => data = empty_csv(data.headers))
        --and 
        --@doc if file is set, must be valid
        (file <> nil => file_status(file) = <Valid>)
        and
        --@doc if strict, must be valid data (is_Data(data)), but don't calculate pos
        (strict => is_Data(data) and pos = {})  
        and 
        --@doc failed positions are within the CSV matrix 
        (pos <> {} => { l | mk_(l, -) in set pos } subset inds data.matrix.cells and 
                      { c | mk_(-, c) in set pos } subset inds data.headers)      
init csv == 
        csv = mk_CSV(nil, <Native>, nil, false, {}, empty_csv([]))
end

operations 

    --@doc returns last IO error or nil if none.
    lastError: () ==> [String1]
    lastError() == is not yet specified;

    --@doc shows the error if the state registered it
    showError() ==
        (ferr := lastError();
         if ferr <> nil then 
            --@todo remove to minimise dependency to IO?
            printf("CSV error %1s\n", [ferr]);
         if pos <> {} then 
         (
            printf("CSV invariant failure at %1s cells: ", [card pos]);
            for all mk_(l, c) in set pos do
            (
                --@todo format them nicely? 
                printf("\n\t(%1s,%2s)", [l, c]);
            );
            printf("%1s", ['\n']);
         );
        )
    ext rd pos wr ferr;
    
    --@doc sets CSV file path and zeros data, registering/showing any IO error. 
    setupCSV(path: Path, parserChoice: CSVParser, headersToInstall: Headers0, s: bool) == 
        (atomic
            (file     := path;
             parser   := parserChoice;
             strict   := s;
             pos      := {};
             data     := empty_csv(headersToInstall);
            );
         showError();
        )
    ext wr file, parser, data, strict, pos
    pre file_status(path) = <Valid> and headersToInstall <> []
    post file = path and file <> nil and 
         parser = parserChoice and strict = s and pos = {} and 
         data = empty_csv(headersToInstall);

    --@doc loads CSV data via CSV parser + IO, returing only if valid (invariant holding) data
    loadData() == 
        (let mk_(ok, data') = csv_read_data(file, parser, data.headers) in
            if ok then 
            (   --@doc check invariants using teh installed headers against read rows
                let lcs: set of (Line * Col) = csv_invariants_failed(data') in
                    if (lcs = {}) then
                    (
                        --@doc update the headers with names as well, if successful.
                        atomic (
                            data := data';
                            pos  := lcs;
                        );
                    )
                    else
                    (
                        --@doc pick the named headers and set invariant violation positions
                        --@doc if strict, zero the CSV; otherwise allow it.
                        atomic (
                            data  := if strict then empty_csv(data'.headers) else data';
                            pos   := if strict then {} else lcs;
                        );
                    )
            )
            else 
            (
                atomic (
                    data := empty_csv(data.headers);
                    pos  := {};
                );
                
            );
            showError();
        )
    ext rd file, parser, strict wr data, pos
    pre  --@doc both file and headers have been set. 
         file <> nil and data.headers <> [] and data.matrix.cells = []
    post --@doc state type invariant will ensure csv_invariants_failed is empty.              
         (strict => pos = {}); 

    --@doc top-level call: given a file and typed headers (possibly with invariants)
    --     loads the CSV as part of the state
    --@todo this could also be part of a function returning Data? Then no state etc?
    loadCSV(path: Path, parserChoice: CSVParser, headersToInstall: Headers0, s: bool) == 
        (
            if file_status(path) <> <Valid> then 
                showError()
            else 
            (
                setupCSV(path, parserChoice, headersToInstall, s);
                loadData();
            );
        )
    ext wr CSV
    pre (file_status(path) = <Valid> => headersToInstall <> [])
    post post_loadData(CSV~, CSV);

    --@doc load file path with given headers and no invariants. 
    --     it insists on minimally knowking the header types. 
    loadTrivialCSV(path: Path, parserChoice: CSVParser, headerTypes: seq1 of CSVType, s: bool) ==
        (
            let headers: Headers0 = 
                [ mk_Header0(
                    DEFAULT_HEADER_NAME ^ val2seq_of_char[nat1](i), 
                    headerTypes(i), 
                    csv_default_value(headerTypes(i)),
                    HEADER_INVARIANT_TRUE,
                    COL_INVARIANT_TRUE
                  ) 
                  | 
                  i in set inds headerTypes 
                ] 
            in 
                loadCSV(path, parserChoice, headers, s);
        )
    ext wr CSV 
    post post_loadData(CSV~, CSV);

    --@doc creates/overwrites given file path with loaded CSV data 
    printCSV(path: Path) == 
        (if (file = nil) then
            printf("CSV not yet loaded %1s",['\n'])
         else if ferr <> nil and pre_csv_write_data(path, data) then
            if file = path then 
                printf("Cannot print to the same CSV file loaded %1s\n", [file])
            else
                let ok = csv_write_data(path, data) in 
                    if ok then
                        (
                            printf("CSV print successful for %1s\n", [path]);
                        )
                    else 
                        (
                            --@doc don't set ferr to avoid zeroing data, but warn of failure
                            printf("CSV print failed for %1s\n", [path]);
                        );
          
          --@doc show any invariant violations or IO errors from csv_write_data call
          showError();
        )
    ext rd file, ferr, data
    pre file_status(path) in set {<Valid>, <DoesNotExist>};
         

end CSV3