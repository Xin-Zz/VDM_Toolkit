module CSVExample
imports from CSVLib
    types 
        Path renamed Path;
        Data renamed Data;
        Data0 renamed Data0;
        --Error renamed Error;
        Header0 renamed Header0;
        Headers renamed Headers;
        Row renamed Row;
        TransposedRow renamed TransposedRow;
        Matrix renamed Matrix;
        CSVCellInv renamed CSVCellInv;
        CSVRowInv renamed CSVRowInv;
        CSVColInv renamed CSVColInv;
        CSVType renamed CSVType;
        Headers0 renamed Headers0;
        CSVValue renamed CSVValue;
    functions 
        row_consistency renamed row_consistency;
        csv_filter_invalid renamed csv_filter_invalid;
        csv_invariants_failed renamed csv_invariants_failed;
        install_row_invariant renamed install_row_invariant;
        install_col_invariant renamed install_col_invariant;
    values 
        HEADER_INVARIANT_TRUE renamed HEADER_INVARIANT_TRUE;
    operations 
        loadCSV renamed loadCSV;
        loadTrivialCSV renamed loadTrivialCSV;
        printCSV renamed printCSV;
exports 
    functions
        VALID_DATA  : [CSVRowInv] -> Data;
        KILL_ROW_VALID_DATA: () -> Data;
    values 
        EXAMPLE_DATA: Data0;
        CAPITAL_NAMES_ROW_INV: CSVRowInv;
    operations 
        load                 : () ==> ();
        loadCSVExample       : Path * Headers0 * bool ==> ();
        loadTrivialCSVExample: Path ==> ();
definitions 

--@doc tests to show the data type usage, including dynamic invariants
values 
    MIN_AGE: nat1 = 18;
    MAX_AGE: nat1 = 60;
    MIN_BMI: nat1 = 18;
    MAX_BMI: nat1 = 35;
    PRECISION: nat1 = 3;
    MIN_WEIGHT_KG: real = 10.5;
    MAX_WEIGHT_KG: real = 100;
    MIN_HEIGHT_CM: real = 100;
    MAX_HEIGHT_CM: real = 250;
    WEIGHT_ROW_INDEX: nat1 = 3;
    HEIGHT_ROW_INDEX: nat1 = 4;
    BMI_ROW_INDEX   : nat1 = 5;
    CAPITAL_LETTERS: seq of char = "ABCDEFGHIJKLMNOPQRSTUVXYWZ";
    
    HEADER_INVARIANT_AGE: CSVCellInv =
        (lambda -: CSVType, v: CSVValue & /*csv_type_check(t, v) and */ v >= MIN_AGE and v <= MAX_AGE);

    HEADER_INVARIANT_WEIGHT: CSVCellInv =
        (lambda -: CSVType, v: CSVValue & /*csv_type_check(t, v) and*/ v >= MIN_WEIGHT_KG and v <= MAX_WEIGHT_KG);

    HEADER_INVARIANT_HEIGHT: CSVCellInv =
        (lambda -: CSVType, v: CSVValue & /*csv_type_check(t, v) and*/ v >= MIN_HEIGHT_CM and v <= MAX_HEIGHT_CM);

    HEADER_INVARIANT_BMI: CSVCellInv =
        (lambda -: CSVType, v: CSVValue & /*csv_type_check(t, v) and*/ v >= MIN_BMI and v <= MAX_BMI);

    COL_INVARIANT_UNIQUE_NAME: CSVColInv = 
        (lambda h: Header0, c: TransposedRow & h.type = <String> and card elems c = len c);

    ROW_INVARIANT_BMI_CONSISTENCY: CSVRowInv =
        (lambda h: Headers0, r: Row & BMI_ROW_INDEX <= len h and row_consistency(h, r) and (let bmi: real = calculate_bmi(r) in bmi >= MIN_BMI and bmi <= MAX_BMI));

    KILL_ROW_INVARIANT_EXAMPLE: CSVRowInv = 
        (lambda h: Headers0, r: Row & 
            --@doc all rows align with header (redundant as checked by default)
            row_consistency(h, r)
            and
            --@doc if failure anywhere in the row, kill the whole row
            (forall i in set inds h &
                (h(i).cell_invariant <> nil => h(i).cell_invariant(h(i).type, r(i)))
            )
        );

    CAPITAL_NAMES_ROW_INV: CSVRowInv = 
        (lambda h: Headers0, r: Row & 
            --@doc all rows align with header (redundant as checked by default)
            row_consistency(h, r)
            and
            --@doc row-specific check, e.g. all names must be capitalised :-) 
            --@todo this is more like a cell invariant 
            (len r(1) > 0 => r(1)(1) in set elems CAPITAL_LETTERS)  
        );

    -- Name,Age,Weight(Kg),Height(cm),BMI
    -- "Okay1",40,58.5,169,20.5
    -- "BMICalcWrong",50,70.2,180,30
    -- "Young",15,61.5,170,21.3
    -- "OldHeavy",70,150.3,180,46.4
    -- "TallBMIinvalid",40,50,270,6.86
    -- "DefaultAge",,58.5,169,20.5
    -- "RepeatedName",40,58.5,169,20.5
    -- "RepeatedName",50,58.5,179,18.26
    --@doc make it Data0, so that the invariants won't be checked at creation time. 
    EXAMPLE_DATA_HEADERS: Headers = 
        [mk_Header0("Name"      , <String> ,         "Joe", HEADER_INVARIANT_TRUE, COL_INVARIANT_UNIQUE_NAME),
         mk_Header0("Age"       , <Integer>,       MIN_AGE, HEADER_INVARIANT_AGE, nil),
         mk_Header0("Weight(Kg)", <Float>  , MIN_WEIGHT_KG, HEADER_INVARIANT_WEIGHT, nil),
         mk_Header0("Height(cm)", <Float>  , MIN_HEIGHT_CM, HEADER_INVARIANT_HEIGHT, nil),
         mk_Header0("BMI"       , <Float>  ,       MIN_BMI, HEADER_INVARIANT_BMI, nil)
        ];

    EXAMPLE_DATA: Data0 = 
        mk_Data0(
            EXAMPLE_DATA_HEADERS,
            --       C1    C2  C3        R0 (Header)
            mk_Matrix(
                [
                   ["Okay1",40,58.5,169,20.5],
                   ["BMICalcWrong",50,70.2,180,30],
                   ["Young",15,61.5,170,21.3],
                   ["OldHeavy",70,150.3,180,46.4],
                   ["TallBMIinvalid",40,50,270,6.86],
                   ["DefaultAge",MIN_AGE,58.5,169,20.5],
                   ["RepeatedName",40,58.5,169,20.5],
                   ["RepeatedName",50,58.5,179,18.26]
                ],
                -- [["Leo"  , 40, 58.5], -- R1
                --  ["Nick" , 50, 70.2], -- R2 
                --  ["Young", 15, 61.5], -- R3    Age violation (3,2)
                --  ["Heavy", 70, 150.3],-- R4    Age violation (4,2)
                --                       --    Weight violation (4,3)
                -- --@todo put something like BMI here, as current one is silly
                --  ["bad"  , 50, 60]    -- R5 Whole Row violation 
                -- ],
                ROW_INVARIANT_BMI_CONSISTENCY                
            )
        );
    
functions 
   	approx: real * nat -> real
	approx(m, precision) == m * (10**precision);

    calculate_bmi: Row -> real
    calculate_bmi(r) ==
        let 
            --@doc get values from each row; calculate height in meters
            --     if denominator (d) is aprox equal / negligeble to zero, adjust 
            w: real = r(WEIGHT_ROW_INDEX),
            h: real = r(HEIGHT_ROW_INDEX),
            h_m: real = h / 100,
            d: real = h_m * h_m
        in
            if floor(approx(d, PRECISION)) = 0 then MIN_BMI-1 else w / d 
    pre BMI_ROW_INDEX <= len r;

    VALID_DATA: [CSVRowInv] -> Data 
    VALID_DATA(rowInv) == 
        let d: Data0 = 
            if (rowInv <> nil) then 
                install_row_invariant(EXAMPLE_DATA, rowInv) 
            else 
                EXAMPLE_DATA 
        in
           csv_filter_invalid(d);

    KILL_ROW_VALID_DATA: () -> Data 
    KILL_ROW_VALID_DATA() == VALID_DATA(KILL_ROW_INVARIANT_EXAMPLE);
    
traces 
    --@do kills only specific cells that violate CAPITAL_LETTERS
    test1: csv_invariants_failed(EXAMPLE_DATA); 
            --= {mk_(3, 2), mk_(4, 2), mk_(4, 3), mk_(5, 1), mk_(5, 2), mk_(5, 3)};

    --@doc kills all lines where any cell invariant is broken
    test2: csv_invariants_failed(install_row_invariant(EXAMPLE_DATA, KILL_ROW_INVARIANT_EXAMPLE));
            --= {mk_(3, 1), mk_(3, 2), mk_(3, 3), mk_(4, 1), mk_(4, 2), mk_(4, 3)}

--@doc tests to show native CSV calls and CSV loaded state
values 
   --@doc For testing, launch.json *must* have cwd set to $VDMJTK_HOME/vdmjlib/src/main/resources !!!
   CSV_EXAMPLE_FILE: Path =
        "CSVExample.csv";
   CSV_SHORT_ROW_FILE: Path = 
        "CSVShortRowExample.csv";

operations 
    load() ==
        (
            loadCSVExample(CSV_SHORT_ROW_FILE, EXAMPLE_DATA_HEADERS, false);
            loadCSVExample(CSV_EXAMPLE_FILE, EXAMPLE_DATA_HEADERS, false);
        );
        
    loadCSVExample(path: Path, headers: Headers0, strict: bool) ==
        (
         loadCSV(path, <Native>, headers, strict);
         printCSV(path ^ ".out");
        );

    loadTrivialCSVExample(path: Path) ==
        (
         loadTrivialCSV(path, <Native>, [<String>, <Integer>, <Float>, <Float>, <Float>], false);
         printCSV(path ^ ".out");
        );

end CSVExample
