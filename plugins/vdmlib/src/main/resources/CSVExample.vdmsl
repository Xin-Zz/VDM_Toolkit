module CSVExample
imports from CSV3
    types 
        Path renamed Path;
        Data renamed Data;
        Data0 renamed Data0;
        Header renamed Header;
        Headers renamed Headers;
        Row renamed Row;
        Rows renamed Rows;
        CSVTypeInv renamed CSVTypeInv;
        CSVRowInv renamed CSVRowInv;
        CSVType renamed CSVType;
        Headers0 renamed Headers0;
        CSVValue renamed CSVValue;
    functions 
        row_consistency renamed row_consistency;
        csv_type_check renamed csv_type_check;
        csv_filter_invalid renamed csv_filter_invalid;
        csv_invariants_failed renamed csv_invariants_failed;
        install_row_invariant renamed install_row_invariant;
    values 
        HEADER_INVARIANT_TRUE renamed HEADER_INVARIANT_TRUE;
    operations 
        loadCSV renamed loadCSV;
        loadTrivialCSV renamed loadTrivialCSV;
        printCSV renamed printCSV;
exports 
    functions
        VALID_DATA  : [CSVRowInv] -> Data;
        KILL_ROW_VALID_DATA: () -> Data;
    values 
        EXAMPLE_DATA: Data0;
    operations 
        loadCSVExample       : bool ==> ();
        loadTrivialCSVExample: () ==> ();
definitions 

--@doc tests to show the data type usage, including dynamic invariants
values 
    MIN_AGE: nat1 = 18;
    MAX_AGE: nat1 = 60;
    MIN_WEIGHT: real = 10.5;
    MAX_WEIGHT: real = 100;
    CAPITAL_LETTERS: seq of char = "ABCDEFGHIJKLMNOPQRSTUVXYWZ";
    HEADER_INVARIANT_AGE: CSVTypeInv =
        (lambda t: CSVType, v: CSVValue & csv_type_check(t, v) and v >= MIN_AGE and v <= MAX_AGE);

    HEADER_INVARIANT_WEIGHT: CSVTypeInv =
        (lambda t: CSVType, v: CSVValue & csv_type_check(t, v) and v >= MIN_WEIGHT and v <= MAX_WEIGHT);

    KILL_ROW_INVARIANT_EXAMPLE: CSVRowInv = 
        (lambda h: Headers0, r: Row & 
            --@doc all rows align with header (redundant as checked by default)
            row_consistency(h, r)
            and
            --@doc if failure anywhere in the row, kill the whole row
            (forall i in set inds h &
                (h(i).invariant <> nil => h(i).invariant(h(i).type, r(i)))
            )
        );

    CAPITAL_NAMES_ROW_INV: CSVRowInv = 
        (lambda h: Headers0, r: Row & 
            --@doc all rows align with header (redundant as checked by default)
            row_consistency(h, r)
            and
            --@doc row-specific check, e.g. all names must be capitalised :-) 
            (len r(1) > 0 => r(1)(1) in set elems CAPITAL_LETTERS)  
        );

    -- Name,Age,Weight(Kg)
    -- "Leo",40,58.5
    -- "Nick",50,70.2
    -- "Young",15,61.5
    -- "Heavy",70,150.3 
    --@doc make it Data0, so that the invariants won't be checked at creation time. 
    EXAMPLE_DATA_HEADERS: Headers = 
        [mk_Header("Name"      , <String> , HEADER_INVARIANT_TRUE),
         mk_Header("Age"       , <Integer>, HEADER_INVARIANT_AGE),
         mk_Header("Weight(Kg)", <Float>  , HEADER_INVARIANT_WEIGHT)
        ];

    EXAMPLE_DATA: Data0 = 
        mk_Data0(
            EXAMPLE_DATA_HEADERS,
            --   C1    C2  C3        R0 (Header)
            mk_Rows(
                [["Leo"  , 40, 58.5], -- R1
                 ["Nick" , 50, 70.2], -- R2 
                 ["Young", 15, 61.5], -- R3    Age violation (3,2)
                 ["Heavy", 70, 150.3],-- R4    Age violation (4,2)
                                      --    Weight violation (4,3)
                 ["bad"  , 50, 60]    -- R5 Whole Row violation 
                ],
                CAPITAL_NAMES_ROW_INV                
            )
        );
    
functions 

    VALID_DATA: [CSVRowInv] -> Data 
    VALID_DATA(rowInv) == 
        let d: Data0 = 
            if (rowInv <> nil) then 
                install_row_invariant(EXAMPLE_DATA, rowInv) 
            else 
                EXAMPLE_DATA 
        in
           csv_filter_invalid(d);

    KILL_ROW_VALID_DATA: () -> Data 
    KILL_ROW_VALID_DATA() == VALID_DATA(KILL_ROW_INVARIANT_EXAMPLE);
    
traces 
    --@do kills only specific cells that violate CAPITAL_LETTERS
    test1: csv_invariants_failed(EXAMPLE_DATA); 
            --= {mk_(3, 2), mk_(4, 2), mk_(4, 3), mk_(5, 1), mk_(5, 2), mk_(5, 3)};

    --@doc kills all lines where any cell invariant is broken
    test2: csv_invariants_failed(install_row_invariant(EXAMPLE_DATA, KILL_ROW_INVARIANT_EXAMPLE));
            --= {mk_(3, 1), mk_(3, 2), mk_(3, 3), mk_(4, 1), mk_(4, 2), mk_(4, 3)}

--@doc tests to show native CSV calls and CSV loaded state
values 
    CSV_EXAMPLE_FILE: Path = "./CSVExample.csv";

operations 
    loadCSVExample(strict: bool) ==
        (
         loadCSV(CSV_EXAMPLE_FILE, <Native>, EXAMPLE_DATA_HEADERS, strict);
         printCSV(CSV_EXAMPLE_FILE ^ ".out");
        );

    loadTrivialCSVExample() ==
        (
         loadTrivialCSV(CSV_EXAMPLE_FILE, <Native>, [<String>, <Integer>, <Float>], false);
         printCSV(CSV_EXAMPLE_FILE ^ ".out");
        );

end CSVExample
